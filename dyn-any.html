<!DOCTYPE HTML>
<html lang="en" class="navy" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>dyn Any - Learning Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Advice for learning Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('navy')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Practical suggestions for building intuition around borrow errors</li><li class="chapter-item "><a href="lifetime-intuition.html"><strong aria-hidden="true">1.</strong> Sectional introduction</a></li><li class="chapter-item "><a href="community.html"><strong aria-hidden="true">2.</strong> Keep at it and participate in the community</a></li><li class="chapter-item "><a href="have-no-life.html"><strong aria-hidden="true">3.</strong> Prefer ownership over long-lived references</a></li><li class="chapter-item "><a href="dont-hide.html"><strong aria-hidden="true">4.</strong> Don't hide lifetimes</a></li><li class="chapter-item "><a href="elision.html"><strong aria-hidden="true">5.</strong> Understand elision and get a feel for when to name lifetimes</a></li><li class="chapter-item "><a href="subtypes.html"><strong aria-hidden="true">6.</strong> Get a feel for variance, references, and reborrows</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="st-model.html"><strong aria-hidden="true">6.1.</strong> The seed of a mental model</a></li><li class="chapter-item "><a href="st-types.html"><strong aria-hidden="true">6.2.</strong> Reference types</a></li><li class="chapter-item "><a href="st-bounds.html"><strong aria-hidden="true">6.3.</strong> Lifetime bounds</a></li><li class="chapter-item "><a href="st-references.html"><strong aria-hidden="true">6.4.</strong> Reference lifetimes</a></li><li class="chapter-item "><a href="st-reborrow.html"><strong aria-hidden="true">6.5.</strong> Copy and reborrows</a></li><li class="chapter-item "><a href="st-invariance.html"><strong aria-hidden="true">6.6.</strong> Nested borrows and invariance</a></li><li class="chapter-item "><a href="st-more-invariance.html"><strong aria-hidden="true">6.7.</strong> Invariance elsewhere</a></li><li class="chapter-item "><a href="st-non-references.html"><strong aria-hidden="true">6.8.</strong> Non-references</a></li></ol></li><li class="chapter-item "><a href="methods.html"><strong aria-hidden="true">7.</strong> Get a feel for borrow-returning methods</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="m-naming.html"><strong aria-hidden="true">7.1.</strong> When not to name lifetimes</a></li><li class="chapter-item "><a href="m-infect.html"><strong aria-hidden="true">7.2.</strong> Bound-related lifetimes "infect" each other</a></li><li class="chapter-item "><a href="m-no-downgrades.html"><strong aria-hidden="true">7.3.</strong> &mut inputs don't "downgrade" to &</a></li><li class="chapter-item "><a href="m-rpitit-alikes.html"><strong aria-hidden="true">7.4.</strong> async and returning impl Trait</a></li></ol></li><li class="chapter-item "><a href="fn-parameters.html"><strong aria-hidden="true">8.</strong> Understand function lifetime parameters</a></li><li class="chapter-item "><a href="lifetime-analysis.html"><strong aria-hidden="true">9.</strong> Understand borrows within a function</a></li><li class="chapter-item "><a href="pitfalls.html"><strong aria-hidden="true">10.</strong> Learn some pitfalls and antipatterns</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pf-dyn.html"><strong aria-hidden="true">10.1.</strong> dyn Trait lifetimes and Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="pf-nll3.html"><strong aria-hidden="true">10.2.</strong> Conditional return of a borrow</a></li><li class="chapter-item "><a href="pf-borrow-forever.html"><strong aria-hidden="true">10.3.</strong> Borrowing something forever</a></li><li class="chapter-item "><a href="pf-self.html"><strong aria-hidden="true">10.4.</strong> &'a mut self and Self aliasing more generally</a></li><li class="chapter-item "><a href="pf-meta.html"><strong aria-hidden="true">10.5.</strong> Avoid self-referential structs</a></li><li class="chapter-item "><a href="pf-shared-nested.html"><strong aria-hidden="true">10.6.</strong> &'a Struct&lt;'a&gt; and covariance</a></li></ol></li><li class="chapter-item "><a href="compiler.html"><strong aria-hidden="true">11.</strong> Scrutinize compiler advice</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c-signatures.html"><strong aria-hidden="true">11.1.</strong> Advice to change function signature when aliases are involved</a></li><li class="chapter-item "><a href="c-equality.html"><strong aria-hidden="true">11.2.</strong> Advice to add bound which implies lifetime equality</a></li><li class="chapter-item "><a href="c-static.html"><strong aria-hidden="true">11.3.</strong> Advice to add a static bound</a></li></ol></li><li class="chapter-item "><a href="lt-examples.html"><strong aria-hidden="true">12.</strong> Illustrative examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lt-ex-mut-slice.html"><strong aria-hidden="true">12.1.</strong> Mutable slice iterator</a></li></ol></li><li class="chapter-item "><a href="circle.html"><strong aria-hidden="true">13.</strong> Circle back</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Miscellanea</li><li class="chapter-item "><a href="miscellanea.html"><strong aria-hidden="true">14.</strong> Sectional introduction</a></li><li class="chapter-item "><a href="misc-slice.html"><strong aria-hidden="true">15.</strong> Slice layout</a></li><li class="chapter-item "><a href="misc-default-param.html"><strong aria-hidden="true">16.</strong> Default parameter mechanics</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">A tour of dyn Trait</li><li class="chapter-item "><a href="dyn-trait.html"><strong aria-hidden="true">17.</strong> Sectional introduction</a></li><li class="chapter-item "><a href="dyn-trait-overview.html"><strong aria-hidden="true">18.</strong> dyn Trait overview</a></li><li class="chapter-item "><a href="dyn-trait-impls.html"><strong aria-hidden="true">19.</strong> dyn Trait implementations</a></li><li class="chapter-item "><a href="dyn-trait-coercions.html"><strong aria-hidden="true">20.</strong> dyn Trait coercions</a></li><li class="chapter-item "><a href="dyn-safety.html"><strong aria-hidden="true">21.</strong> dyn safety (object safety)</a></li><li class="chapter-item "><a href="dyn-trait-lifetime.html"><strong aria-hidden="true">22.</strong> dyn Trait lifetimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dyn-covariance.html"><strong aria-hidden="true">22.1.</strong> Variance</a></li><li class="chapter-item "><a href="dyn-hr.html"><strong aria-hidden="true">22.2.</strong> Higher-ranked types</a></li><li class="chapter-item "><a href="dyn-elision.html"><strong aria-hidden="true">22.3.</strong> Elision rules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dyn-elision-basic.html"><strong aria-hidden="true">22.3.1.</strong> Basic guidelines</a></li><li class="chapter-item "><a href="dyn-elision-advanced.html"><strong aria-hidden="true">22.3.2.</strong> Advanced guidelines</a></li><li class="chapter-item "><a href="dyn-elision-trait-bounds.html"><strong aria-hidden="true">22.3.3.</strong> Trait bound interactions</a></li><li class="chapter-item "><a href="dyn-elision-citations.html"><strong aria-hidden="true">22.3.4.</strong> Citations</a></li></ol></li></ol></li><li class="chapter-item "><a href="dyn-trait-vs.html"><strong aria-hidden="true">23.</strong> dyn Trait vs. alternatives</a></li><li class="chapter-item "><a href="dyn-trait-examples.html"><strong aria-hidden="true">24.</strong> dyn Trait examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dyn-trait-combining.html"><strong aria-hidden="true">24.1.</strong> Combining traits</a></li><li class="chapter-item "><a href="dyn-trait-box-impl.html"><strong aria-hidden="true">24.2.</strong> impl Trait for Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="dyn-trait-clone.html"><strong aria-hidden="true">24.3.</strong> Cloneable Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="dyn-trait-eq.html"><strong aria-hidden="true">24.4.</strong> dyn PartialEq</a></li><li class="chapter-item "><a href="dyn-trait-borrow.html"><strong aria-hidden="true">24.5.</strong> Generalizing borrows</a></li><li class="chapter-item "><a href="dyn-trait-erased.html"><strong aria-hidden="true">24.6.</strong> Erased traits</a></li><li class="chapter-item "><a href="dyn-trait-hash.html"><strong aria-hidden="true">24.7.</strong> Hashable Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="dyn-any-examples.html"><strong aria-hidden="true">24.8.</strong> dyn Any examples</a></li></ol></li><li class="chapter-item expanded "><a href="dyn-any.html" class="active"><strong aria-hidden="true">25.</strong> dyn Any</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learning Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/QuineDot/rust-learning" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="more-about-dyn-any"><a class="header" href="#more-about-dyn-any">More about <code>dyn Any</code></a></h1>
<p>We've taken a lot of care to emphasize that <code>dyn Trait</code> isn't
a supertype nor a form of dynamic typing, but
<a href="dyn-trait-eq.html#downcasting-with-dyn-any-to-emulate-dynamic-typing">in one of the examples</a>
we saw that <code>dyn Any</code> <em>can</em> "downcast" back to the erased
base type.  Or <a href="https://doc.rust-lang.org/std/any/trait.Any.html">to quote the official documentation,</a>
<code>Any</code> is</p>
<blockquote>
<p>A trait to emulate dynamic typing.</p>
</blockquote>
<p>Here we take a closer look at <code>dyn Any</code> specifically.</p>
<h2 id="the-general-idea"><a class="header" href="#the-general-idea">The general idea</a></h2>
<p>The <code>Any</code> trait is implemented for all types which satisfy a <code>'static</code> bound.
It supplies a method <code>type_id</code>, which returns
<a href="https://doc.rust-lang.org/std/any/struct.TypeId.html">an opaque but unique identifier</a>
of the implementing type.  We also have
<a href="https://doc.rust-lang.org/std/any/struct.TypeId.html#method.of"><code>TypeId::of::&lt;T&gt;</code>,</a>
which lets us look up the <code>TypeId</code> of any <code>'static</code> type.</p>
<p>Together, this allows fallible downcasting by doing <a href="https://doc.rust-lang.org/src/core/any.rs.html">things along these lines:</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn downcast_ref&lt;T: Any&gt;(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        if self.is::&lt;T&gt;() {
            // SAFETY: just checked whether we are pointing to the correct type, and we can rely on
            // that check for memory safety because we have implemented Any for all types; no other
            // impls can exist as they would conflict with our impl.
            unsafe { Some(self.downcast_ref_unchecked()) }
        } else {
            None
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>And <a href="https://doc.rust-lang.org/std/any/trait.Any.html#method.is"><code>is</code></a> simply compares
<code>TypeId::of::&lt;T&gt;()</code> to <code>self.type_id()</code>.</p>
<p>Details of specific downcasts aside, that's pretty much it!  All that was
needed is the global identifier (<code>TypeId</code>).  The standard library provides
the various downcasting methods in order to encapsulate the required
<code>unsafe</code>ty.</p>
<p><a href="dyn-trait-eq.html#downcasting-with-dyn-any-to-emulate-dynamic-typing">As a reminder from before,</a>
the vtable pointers themselves are not suitable to use as a global identifier
of erased types.  The same trait can have multiple vtables due to codegen
units and linker implementations, and different traits can have the same
vtable due to deduplication optimizations.</p>
<p><a href="https://github.com/rust-lang/rust/issues/106447">Where exactly the language goes with respect to comparing vtable pointers
is an open question.</a>  It's
not unimaginable that all vtables will gain some lifetime-erased version of
<code>TypeId</code>, but <a href="#why-static">related to some discussion below,</a> this may not
be as straightforward as it may sound.</p>
<h2 id="downcasting-methods-are-not-trait-methods"><a class="header" href="#downcasting-methods-are-not-trait-methods">Downcasting methods are not trait methods</a></h2>
<p>Note that the <em>only</em> method available in the <code>Any</code> trait is <code>type_id</code>.
<a href="https://doc.rust-lang.org/std/any/trait.Any.html#implementations">All of the downcasting methods</a>
are implemented on the erased <code>dyn Any</code> directly, or on <code>Box&lt;dyn Any&gt;</code>, or
on <code>dyn Any + Send</code>, etc.  Downcasting doesn't generally make sense for a
non-erased base type -- you already know what it is!</p>
<p>Another good reason for this is that
<a href="https://doc.rust-lang.org/std/any/index.html#smart-pointers-and-dyn-any">types like <code>Box&lt;dyn Any&gt;</code> implement <code>Any</code>,</a>
making easy to accidentally call the <code>Box&lt;dyn Any&gt;</code> implementation instead of
the <code>dyn Any</code> implementation in the case of <code>type_id</code>.  It would be much more
fraught if <code>downcast_ref</code> worked like this, for example.</p>
<p>However, this does mean that having <code>Any</code> as a supertrait does not allow
downcasting for your own <code>dyn Trait</code>s.  <a href="./dyn-trait-combining.html#manual-supertrait-upcasting">Instead you have to first upcast
to dyn Any,</a> and then
downcast.  Once we have <a href="dyn-trait-coercions.html#supertrait-upcasting">built-in supertrait upcasting,</a>
the process will involve much less boilerplate when an <code>Any</code> suptertrait
bound is acceptable.</p>
<p>But note that a supertrait <code>Any</code> bound is not the only solution for custom downcasting!
<a href="#custom-downcasting">We explore another approach below.</a></p>
<h2 id="some-brief-examples"><a class="header" href="#some-brief-examples">Some brief examples</a></h2>
<p><a href="dyn-trait-eq.html#downcasting-with-dyn-any-to-emulate-dynamic-typing">In our other example,</a>
we used <a href="./dyn-trait-combining.html#manual-supertrait-upcasting">manual supertrait casting</a> to
turn a <code>dyn DynCompare</code> into a <code>dyn Any</code>.  This was a case where we really just wished we
could attempt to downcast <code>dyn DynCompare</code> itself.</p>
<p>Here we instead look at some simple examples of type erasing and downcasting concrete
types directly.</p>
<h3 id="the-basics"><a class="header" href="#the-basics">The basics</a></h3>
<p>Getting a <code>dyn Any</code> isn't any different than any other kind of type erasure:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::any::Any;
</span>let mut i = 0;
let rf: &amp;dyn Any = &amp;();
let mt: &amp;mut dyn Any = &amp;mut i;
let bx: Box&lt;dyn Any&gt; = Box::new(String::new());
<span class="boring">}</span></code></pre></pre>
<p>You have to keep in mind the <code>'static</code> requirement though:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::any::Any;
</span>let local = ();
let borrow = &amp;local;
// fails because `borrow` is not `'static`
let _: &amp;dyn Any = &amp;borrow;
<span class="boring">}</span></code></pre></pre>
<p>On the upside, <a href="dyn-elision-trait-bounds.html#the-static-case"><code>dyn Any</code> is <em>always</em> <code>dyn Any + 'static</code>,</a>
which makes many trait object related borrow check errors impossible.</p>
<p>Although <code>Any</code> is implemented for unsized types, and unsized types can
have <code>TypeId</code>s too, the <code>Sized</code> restriction for type erasure still applies:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::any::Any;
</span>// fails because `str` is not `Sized`
let _: &amp;dyn Any = "";
<span class="boring">}</span></code></pre></pre>
<p>Fallible downcasting is pretty straightforward as well.  For references
the return is an <code>Option</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::any::Any;
</span><span class="boring">let mut i = 0;
</span><span class="boring">let rf: &amp;dyn Any = &amp;();
</span><span class="boring">let mt: &amp;mut dyn Any = &amp;mut i;
</span>assert_eq!( rf.downcast_ref::&lt;()&gt;(), Some(&amp;()) );
assert_eq!( rf.downcast_ref::&lt;String&gt;(), None );

assert!( mt.downcast_mut::&lt;i32&gt;().is_some() );
assert_eq!( mt.downcast_mut::&lt;String&gt;(), None );
<span class="boring">}</span></code></pre></pre>
<p>For <code>Box</code>es, the return type is a <code>Result</code> so that the you can keep
ownership of the <code>Box&lt;dyn Any&gt;</code> if the downcast is not applicable.
The <code>Ok</code> variant is a <code>Box&lt;T&gt;</code> so that you can choose whether it's
appropriate to unbox the type or not.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::any::Any;
</span><span class="boring">let bx: Box&lt;dyn Any&gt; = Box::new(String::new());
</span>if let Err(bx) = bx.downcast::&lt;i32&gt;() {
    println!("Hmm, not an `i32`.");
    if let Ok(bx) = bx.downcast::&lt;String&gt;() {
        let s: String = *bx;
        println!("Yep, it was a `String`.");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>That's it for the basics!</p>
<h3 id="the-typemap-pattern"><a class="header" href="#the-typemap-pattern">The <code>TypeMap</code> pattern</a></h3>
<p>For an example with a more practical bent, let's say you wanted to store a distinct
value for each distinct type you may encounter, for some reason.  Maybe you're
storing callbacks for types which are likewise type erased, say, and the callback
for a <code>Dog</code> would be different than that for a <code>Cat</code>, and you might not even have
a callback for the <code>Mouse</code>.</p>
<p>One way to do this would be to have a data structure that maps a <code>TypeId</code> to the
values.  A "type map", if you will:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::any::Any;
</span><span class="boring">use std::any::TypeId;
</span><span class="boring">use std::collections::HashMap;
</span>pub struct TypeMap&lt;V&gt; {
    map: HashMap&lt;TypeId, V&gt;,
}

impl&lt;V&gt; TypeMap&lt;V&gt; {
    pub fn insert&lt;T: Any&gt;(&amp;mut self, value: V) -&gt; Option&lt;V&gt; {
        let id = TypeId::of::&lt;T&gt;();
        self.map.insert(id, value)
    }
    pub fn get_mut&lt;T: Any&gt;(&amp;mut self) -&gt; Option&lt;&amp;mut V&gt; {
        self.get_mut_of(&amp;TypeId::of::&lt;T&gt;())
    }
    pub fn get_mut_of(&amp;mut self, id: &amp;TypeId) -&gt; Option&lt;&amp;mut V&gt; {
        self.map.get_mut(id)
    }
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>This could be used for the callback idea:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::any::Any;
</span><span class="boring">use std::any::TypeId;
</span><span class="boring">use std::collections::HashMap;
</span><span class="boring">pub struct TypeMap&lt;V&gt; {
</span><span class="boring">    map: HashMap&lt;TypeId, V&gt;,
</span><span class="boring">}
</span><span class="boring">impl&lt;V&gt; TypeMap&lt;V&gt; {
</span><span class="boring">    pub fn insert&lt;T: Any&gt;(&amp;mut self, value: V) -&gt; Option&lt;V&gt; {
</span><span class="boring">        let id = TypeId::of::&lt;T&gt;();
</span><span class="boring">        self.map.insert(id, value)
</span><span class="boring">    }
</span><span class="boring">    pub fn get_mut&lt;T: Any&gt;(&amp;mut self) -&gt; Option&lt;&amp;mut V&gt; {
</span><span class="boring">        self.get_mut_of(&amp;TypeId::of::&lt;T&gt;())
</span><span class="boring">    }
</span><span class="boring">    pub fn get_mut_of(&amp;mut self, id: &amp;TypeId) -&gt; Option&lt;&amp;mut V&gt; {
</span><span class="boring">        self.map.get_mut(id)
</span><span class="boring">    }
</span><span class="boring">}
</span>pub struct Visitor {
    map: TypeMap&lt;Box&lt;dyn FnMut(&amp;dyn Any)&gt;&gt;,
}

impl Visitor {
    // Because we return closures we have previously created,
    // we should take care to not *assume* that the parameter
    // in the callback is of the correct type.  If we never
    // let our closures escape to the outside world, we could
    // safely assume that the parameter was, in fact, `T`.
    //
    // It would be sound to `panic` if the parameter was not
    // `T` even if we let the closures escape, but it would
    // not be sound to use the unstable `downcast_ref_unchecked`
    // so long as we're letting the closure escape.
    pub fn register&lt;T, F&gt;(&amp;mut self, mut callback: F) -&gt; Option&lt;Box&lt;dyn FnMut(&amp;dyn Any)&gt;&gt;
    where
        T: Any,
        F: 'static + FnMut(&amp;T),
    {
        let callback = Box::new(move |any: &amp;dyn Any| {
            if let Some(t) = any.downcast_ref::&lt;T&gt;() {
                callback(t);
            }
        });

        self.map.insert::&lt;T&gt;(callback)
    }

    pub fn get_callback&lt;T: Any&gt;(&amp;mut self) -&gt; Option&lt;impl FnMut(&amp;T) + '_&gt; {
        self.map
            .get_mut::&lt;T&gt;()
            .map(|f| {
                |t: &amp;T| f(t)
            })
    }

    pub fn visit&lt;T: Any&gt;(&amp;mut self, value: &amp;T) -&gt; bool {
        if let Some(mut callback) = self.get_callback::&lt;T&gt;() {
            callback(value);
            true
        } else {
            false
        }
    }

    pub fn visit_erased(&amp;mut self, value: &amp;dyn Any) -&gt; bool {
        if let Some(callback) = self.map.get_mut_of(&amp;value.type_id()) {
            callback(value);
            true
        } else {
            false
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Above we have also type erased our callback signatures, since we needed
a single type for our values.  This is somewhat the data structure version
of <a href="./dyn-trait-erased.html">erasing a trait.</a></p>
<p>For whatever reason you might want to map by types, this is
<a href="https://lib.rs/keywords/typemap">an existing pattern in the ecosystem.</a></p>
<h3 id="custom-downcasting"><a class="header" href="#custom-downcasting">Custom downcasting</a></h3>
<p>In this example, we explore how you can add (emulated) downcasting to your own
traits, without an <code>Any</code> supertrait bound and without a <code>'static</code> bound on your
entire <em>trait,</em> either.  The implementation does still depend on the <code>TypeId</code>,
so the actual downcasting is still limited to types which satisfy a <code>'static</code> bound.</p>
<p>The approach is to make implementing <a href="#the-general-idea">the general idea</a> possible
by having a method in our trait that returns the <code>TypeId</code> of the implementing type.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::any::TypeId;
</span>pub trait Trait {
    // Heads up: We'll need to revisit this definition in just a bit
    fn type_id(&amp;self) -&gt; TypeId
    where
        Self: 'static
    {
        TypeId::of::&lt;Self&gt;()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Recall that the compiler's implementation of <code>Trait for dyn Trait</code> will implicitly
downcast the receiver and call this method.  Therefore, we now have a way to get
the <code>TypeId</code> of the base type out of <code>dyn Trait</code>.</p>
<p>Then we can implement our own downcast methods:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::any::TypeId;
</span><span class="boring">pub trait Trait { fn type_id(&amp;self) -&gt; TypeId where Self: 'static { TypeId::of::&lt;Self&gt;() } }
</span>// n.b. this is `dyn Trait + 'static` :-)
impl dyn Trait {
    pub fn is&lt;T: 'static&gt;(&amp;self) -&gt; bool {
        TypeId::of::&lt;T&gt;() == self.type_id()
    }

    pub fn downcast&lt;T: 'static&gt;(self: Box&lt;Self&gt;) -&gt; Result&lt;Box&lt;T&gt;, Box&lt;Self&gt;&gt; {
        if (*self).is::&lt;T&gt;() {
            let ptr = Box::into_raw(self) as *mut T;
            // SAFETY: Keep reading :-)
            unsafe { Ok(Box::from_raw(ptr)) }
        } else {
            Err(self)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>...and similarly for <code>downcast_ref</code>, <code>downcast_mut</code>, and more implementations for
<code>dyn Trait + Send</code>, <code>dyn Trait + Send + Sync</code>, and so on.  (Yes, it can be a lot
of boilerplate.)</p>
<p>However, there's a large soundness hole in this example.  Implementors of <code>Trait</code>
can supply their own implementation of the <code>type_id</code> method!  They can override
the default body and return a <code>TypeId</code> that is not the implementing type.  That
makes our <code>unsafe</code> produce UB; since <code>type_id</code> isn't an <code>unsafe</code> method, our
implementation is to blame.</p>
<p>We could make the method <code>unsafe</code>.  In this example, we will instead make it
impossible to override the default body.  To do this, we need that method
to be <code>final</code>.  Well, Rust doesn't have <code>final</code> yet.  However, we can
<a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed"><em>seal</em></a>
the method by giving it a parameter which can only be named within our module.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A private module (no `pub`)
mod private {
    // Containing a `pub` type (to avoid errors on our public trait method)
    pub struct Seal;
}
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-diff"> pub trait Trait {
-    fn type_id(&amp;self) -&gt; TypeId
+    #[doc(hidden)]
+    fn type_id(&amp;self, _: private::Seal) {
     where
         Self: 'static
     {
         TypeId::of::&lt;Self&gt;()
     }
 }

 impl dyn Trait {
     pub fn is&lt;T: 'static&gt;(&amp;self) -&gt; bool {
-        TypeId::of::&lt;T&gt;() == self.type_id()
+        TypeId::of::&lt;T&gt;() == self.type_id(private::Seal)
     }
</code></pre>
<p>Now if an implementor tries to write out the signature of the <code>type_id</code> method,
they'll get a privacy error.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=af12a6896f44c7843dd331904c5b6bce">Here's a playground with a couple more methods.</a>
This example is based on <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a>
and its own custom downcasting implementation.</p>
<h2 id="why-static"><a class="header" href="#why-static">Why <code>'static</code>?</a></h2>
<p>The <code>Any</code> trait is implemented for all types which satisfy a <code>'static</code> bound,
but no other types; in fact, it has a <code>'static</code> bound and thus <em>cannot</em> be implemented
for types that do not meet a <code>'static</code> bound.  This means that emulating dynamic
typing with <code>Any</code> cannot be done for borrowing types (except those that borrow for
<code>'static</code>), for example.</p>
<p>Why such a harsh restriction?  In short, lifetimes are erased before runtime, types
with different lifetimes would have to have the same <code>TypeId</code> identifier, and thus
downcasting based on the <code>TypeId</code> would ignore lifetimes and be <em>wildly unsound</em>.
Lifetimes are a part of types and certain relationships must be preserved for
soundness, but as the lifetimes have been erased before runtime, it's not possible
to preserve the relationships dynamically.</p>
<p>Thus there is just no sound way to use <code>TypeId</code> or any similar lifetime-unaware
identifier to perform non-<code>'static</code> downcasts directly.</p>
<p><a href="https://github.com/rust-lang/rfcs/pull/1849">There is more information in this RFC PR,</a>
for the curious.  Note that the PR was accepted but then later removed, and was never
about non-<code>'static</code> downcasting; it was about a non-<code>'static</code> <code>type_id</code> method.  The
idea was to get a "type" identifier that ignored lifetimes.</p>
<p>It was withdrawn in large part because if such a thing existed, <a href="https://internals.rust-lang.org/t/pre-rfc-non-footgun-non-static-typeid/17079/10">the chances of it
being abused in some wildly unsound way are about 100%.</a></p>
<p>An alternative (as presented in that thread) is to have some way to dynamically check
if two types (which are perhaps generic) are equal without imposing a <code>'static</code> bound.
The check could only be meaningful for types that were "inherently <code>'static</code>", that is,
types that do not involve any lifetime parameters at all.  That would be possible
without actually exposing a non-<code>'static</code> <code>TypeId</code> or otherwise enabling downcasting.</p>
<p>The tradeoff results in pretty unintuitive behavior: <code>&amp;'static str</code> cannot be
compared to <code>&amp;'static str</code> with this approach, because there <em>is</em> a lifetime parameter
involved with <code>&amp;str</code>!</p>
<p>Another alternative is to provide some sort of "type lambda" which is itself <code>'static</code>,
but can soundly map erased lifetimes back to their proper position.  <a href="https://github.com/sagebind/castaway/pull/6#issuecomment-1150952050">A sketch is
provided here,</a>
but an in-depth exploration is out of scope for this guide.</p>
<h2 id="a-potential-footgun-around-subtypes-subtitle-why-not-const"><a class="header" href="#a-potential-footgun-around-subtypes-subtitle-why-not-const">A potential footgun around subtypes (subtitle: why not <code>const</code>?)</a></h2>
<p>Let's take a minute to talk about types that <em>do</em> have a sub and supertype
relationship in Rust!  Types which are <a href="./dyn-hr.html">higher-ranked</a> have this
relationship.  For example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// More explicitly, this is a `for&lt;'any&gt; fn(&amp;'any str)` function pointer.
// The type is higher-ranked over the lifetime.
let fp: fn(&amp;str) = |_| {};

// This type is a supertype of the higher-ranked type.
let fp: fn(&amp;'static str) = fp;

// This errors because you can't soundly downcast the types.
// let fp: fn(&amp;str) = fp;
<span class="boring">}</span></code></pre></pre>
<p>And as it turns out, it is possible for two Rust types which are more than
superficially syntactically different to be <em>subtypes of one another.</em>  Some
parts of the language consider the existence of such a relationship to mean
that the two types are equal.  Let's say they are semantically equal.</p>
<p>Below is an example.  Due to covariance, it's always possible to call
either of the functions from the other, which helps explain why they are
considered subtypes of one another.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let one: for&lt;'a    &gt; fn(&amp;'a str, &amp;'a str) = |_, _| {};
let two: for&lt;'a, 'b&gt; fn(&amp;'a str, &amp;'b str) = |_, _| {};
let mut fp = one;
fp = two;
let mut fp = two;
fp = one;
<span class="boring">}</span></code></pre></pre>
<p><a href="https://github.com/rust-lang/rust/issues/97156">However, these two types have different <code>TypeId</code>s!</a></p>
<p>So different parts of Rust currently disagree about what types are equal or not.</p>
<p>As the issue explains, this is a bit of a footgun if you were expecting consistency.
Additionally, it's a blocker for <a href="https://github.com/rust-lang/rust/issues/77125">a <code>const type_id</code> function</a>
as it is possible to cause UB in safe code with a <code>const type_id</code> function so long
as this inconsistency remains.</p>
<p>How the language will evolve around this is unclear.  People want the <code>const</code> feature
bad enough that <a href="https://github.com/rust-lang/libs-team/issues/231">some version with caveats about false negatives</a>
may be pursued.  Personally I feel making the type system consistent would be the
better solution and worth waiting for.</p>
<h2 id="more-considerations-around-higher-ranked-types"><a class="header" href="#more-considerations-around-higher-ranked-types">More considerations around higher-ranked types</a></h2>
<p>Even if the issue discussed above gets resolved and Rust becomes consistent about
what types are equal, <a href="./dyn-hr.html">higher-ranked types</a> introduce some nuance to
be aware of.  For example, when considering these two types:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Look&lt;'s&gt; {}
type HR = dyn for&lt;'any&gt; Look&lt;'any&gt; + 'static;
type ST = dyn Look&lt;'static&gt; + 'static;
<span class="boring">}</span></code></pre></pre>
<p><code>HR</code> is a <em>subtype</em> of <code>ST</code>, but not <em>the same type</em>.
However, they both satisfy a <code>'static</code> bound:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Look&lt;'s&gt; {}
</span><span class="boring">type HR = dyn for&lt;'any&gt; Look&lt;'any&gt; + 'static;
</span><span class="boring">type ST = dyn Look&lt;'static&gt; + 'static;
</span>fn assert_static&lt;T: ?Sized + 'static&gt;() {}

assert_static::&lt;HR&gt;();
assert_static::&lt;ST&gt;();
<span class="boring">}</span></code></pre></pre>
<p>As <code>'static</code> types, they have <code>TypeId</code>s.  As distinct types, their
<code>TypeId</code>s are different, even though one is a subtype of the other.</p>
<p>And this in turn means that you can't stop thinking about sub-and-super types
by simply applying a <code>'static</code> bound.  If you need to "disable" sub/super type
coercions in a generic context for soundness, you must make that context invariant
or take other steps to avoid a soundness hole, even if you have a <code>'static</code> bound.</p>
<p><a href="https://github.com/rust-lang/rust/issues/85863">See this issue</a> for a real-life
example of such a soundness hole, and
<a href="https://github.com/rust-lang/rust/issues/85863#issuecomment-872536139">this comment in particular</a>
exploring the sub/super type relationships of higher-ranked function pointers.</p>
<h2 id="the-representation-of-typeid"><a class="header" href="#the-representation-of-typeid">The representation of <code>TypeId</code></a></h2>
<p><code>TypeId</code> is intentionally opaque and subject to change.  It was internally represented
by a <code>u64</code> for quite some time; as of Rust 1.72
<a href="https://github.com/rust-lang/rust/pull/109953">the representation is a <code>u128</code>.</a>
At some future time it could be <a href="https://github.com/rust-lang/rust/pull/95845">something more exotic.</a></p>
<p>Long story short, you're not meant to rely on the exact representation of <code>TypeId</code>,
only it's type comparing properties.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="dyn-any-examples.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="dyn-any-examples.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
