<!DOCTYPE HTML>
<html lang="en" class="navy" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Slice layout - Learning Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Advice for learning Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('navy')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Practical suggestions for building intuition around borrow errors</li><li class="chapter-item "><a href="lifetime-intuition.html"><strong aria-hidden="true">1.</strong> Sectional introduction</a></li><li class="chapter-item "><a href="community.html"><strong aria-hidden="true">2.</strong> Keep at it and participate in the community</a></li><li class="chapter-item "><a href="have-no-life.html"><strong aria-hidden="true">3.</strong> Prefer ownership over long-lived references</a></li><li class="chapter-item "><a href="dont-hide.html"><strong aria-hidden="true">4.</strong> Don't hide lifetimes</a></li><li class="chapter-item "><a href="elision.html"><strong aria-hidden="true">5.</strong> Understand elision and get a feel for when to name lifetimes</a></li><li class="chapter-item "><a href="subtypes.html"><strong aria-hidden="true">6.</strong> Get a feel for variance, references, and reborrows</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="st-model.html"><strong aria-hidden="true">6.1.</strong> The seed of a mental model</a></li><li class="chapter-item "><a href="st-types.html"><strong aria-hidden="true">6.2.</strong> Reference types</a></li><li class="chapter-item "><a href="st-bounds.html"><strong aria-hidden="true">6.3.</strong> Lifetime bounds</a></li><li class="chapter-item "><a href="st-references.html"><strong aria-hidden="true">6.4.</strong> Reference lifetimes</a></li><li class="chapter-item "><a href="st-reborrow.html"><strong aria-hidden="true">6.5.</strong> Copy and reborrows</a></li><li class="chapter-item "><a href="st-invariance.html"><strong aria-hidden="true">6.6.</strong> Nested borrows and invariance</a></li><li class="chapter-item "><a href="st-more-invariance.html"><strong aria-hidden="true">6.7.</strong> Invariance elsewhere</a></li><li class="chapter-item "><a href="st-non-references.html"><strong aria-hidden="true">6.8.</strong> Non-references</a></li></ol></li><li class="chapter-item "><a href="methods.html"><strong aria-hidden="true">7.</strong> Get a feel for borrow-returning methods</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="m-naming.html"><strong aria-hidden="true">7.1.</strong> When not to name lifetimes</a></li><li class="chapter-item "><a href="m-infect.html"><strong aria-hidden="true">7.2.</strong> Bound-related lifetimes "infect" each other</a></li><li class="chapter-item "><a href="m-no-downgrades.html"><strong aria-hidden="true">7.3.</strong> &mut inputs don't "downgrade" to &</a></li><li class="chapter-item "><a href="m-rpitit-alikes.html"><strong aria-hidden="true">7.4.</strong> async and returning impl Trait</a></li></ol></li><li class="chapter-item "><a href="fn-parameters.html"><strong aria-hidden="true">8.</strong> Understand function lifetime parameters</a></li><li class="chapter-item "><a href="lifetime-analysis.html"><strong aria-hidden="true">9.</strong> Understand borrows within a function</a></li><li class="chapter-item "><a href="pitfalls.html"><strong aria-hidden="true">10.</strong> Learn some pitfalls and antipatterns</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pf-dyn.html"><strong aria-hidden="true">10.1.</strong> dyn Trait lifetimes and Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="pf-nll3.html"><strong aria-hidden="true">10.2.</strong> Conditional return of a borrow</a></li><li class="chapter-item "><a href="pf-borrow-forever.html"><strong aria-hidden="true">10.3.</strong> Borrowing something forever</a></li><li class="chapter-item "><a href="pf-self.html"><strong aria-hidden="true">10.4.</strong> &'a mut self and Self aliasing more generally</a></li><li class="chapter-item "><a href="pf-meta.html"><strong aria-hidden="true">10.5.</strong> Avoid self-referential structs</a></li><li class="chapter-item "><a href="pf-shared-nested.html"><strong aria-hidden="true">10.6.</strong> &'a Struct&lt;'a&gt; and covariance</a></li></ol></li><li class="chapter-item "><a href="compiler.html"><strong aria-hidden="true">11.</strong> Scrutinize compiler advice</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c-signatures.html"><strong aria-hidden="true">11.1.</strong> Advice to change function signature when aliases are involved</a></li><li class="chapter-item "><a href="c-equality.html"><strong aria-hidden="true">11.2.</strong> Advice to add bound which implies lifetime equality</a></li><li class="chapter-item "><a href="c-static.html"><strong aria-hidden="true">11.3.</strong> Advice to add a static bound</a></li></ol></li><li class="chapter-item "><a href="lt-examples.html"><strong aria-hidden="true">12.</strong> Illustrative examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lt-ex-mut-slice.html"><strong aria-hidden="true">12.1.</strong> Mutable slice iterator</a></li></ol></li><li class="chapter-item "><a href="circle.html"><strong aria-hidden="true">13.</strong> Circle back</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Miscellanea</li><li class="chapter-item "><a href="miscellanea.html"><strong aria-hidden="true">14.</strong> Sectional introduction</a></li><li class="chapter-item expanded "><a href="misc-slice.html" class="active"><strong aria-hidden="true">15.</strong> Slice layout</a></li><li class="chapter-item "><a href="misc-default-param.html"><strong aria-hidden="true">16.</strong> Default parameter mechanics</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">A tour of dyn Trait</li><li class="chapter-item "><a href="dyn-trait.html"><strong aria-hidden="true">17.</strong> Sectional introduction</a></li><li class="chapter-item "><a href="dyn-trait-overview.html"><strong aria-hidden="true">18.</strong> dyn Trait overview</a></li><li class="chapter-item "><a href="dyn-trait-impls.html"><strong aria-hidden="true">19.</strong> dyn Trait implementations</a></li><li class="chapter-item "><a href="dyn-trait-coercions.html"><strong aria-hidden="true">20.</strong> dyn Trait coercions</a></li><li class="chapter-item "><a href="dyn-safety.html"><strong aria-hidden="true">21.</strong> dyn safety (object safety)</a></li><li class="chapter-item "><a href="dyn-trait-lifetime.html"><strong aria-hidden="true">22.</strong> dyn Trait lifetimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dyn-covariance.html"><strong aria-hidden="true">22.1.</strong> Variance</a></li><li class="chapter-item "><a href="dyn-hr.html"><strong aria-hidden="true">22.2.</strong> Higher-ranked types</a></li><li class="chapter-item "><a href="dyn-elision.html"><strong aria-hidden="true">22.3.</strong> Elision rules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dyn-elision-basic.html"><strong aria-hidden="true">22.3.1.</strong> Basic guidelines</a></li><li class="chapter-item "><a href="dyn-elision-advanced.html"><strong aria-hidden="true">22.3.2.</strong> Advanced guidelines</a></li><li class="chapter-item "><a href="dyn-elision-trait-bounds.html"><strong aria-hidden="true">22.3.3.</strong> Trait bound interactions</a></li><li class="chapter-item "><a href="dyn-elision-citations.html"><strong aria-hidden="true">22.3.4.</strong> Citations</a></li></ol></li></ol></li><li class="chapter-item "><a href="dyn-trait-vs.html"><strong aria-hidden="true">23.</strong> dyn Trait vs. alternatives</a></li><li class="chapter-item "><a href="dyn-trait-examples.html"><strong aria-hidden="true">24.</strong> dyn Trait examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dyn-trait-combining.html"><strong aria-hidden="true">24.1.</strong> Combining traits</a></li><li class="chapter-item "><a href="dyn-trait-box-impl.html"><strong aria-hidden="true">24.2.</strong> impl Trait for Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="dyn-trait-clone.html"><strong aria-hidden="true">24.3.</strong> Cloneable Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="dyn-trait-eq.html"><strong aria-hidden="true">24.4.</strong> dyn PartialEq</a></li><li class="chapter-item "><a href="dyn-trait-borrow.html"><strong aria-hidden="true">24.5.</strong> Generalizing borrows</a></li><li class="chapter-item "><a href="dyn-trait-erased.html"><strong aria-hidden="true">24.6.</strong> Erased traits</a></li><li class="chapter-item "><a href="dyn-trait-hash.html"><strong aria-hidden="true">24.7.</strong> Hashable Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="dyn-any-examples.html"><strong aria-hidden="true">24.8.</strong> dyn Any examples</a></li></ol></li><li class="chapter-item "><a href="dyn-any.html"><strong aria-hidden="true">25.</strong> dyn Any</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learning Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/QuineDot/rust-learning" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="slice-layout"><a class="header" href="#slice-layout">Slice layout</a></h1>
<p>It's not uncommon for people on <a href="https://users.rust-lang.org/">the forum</a>
to ask why it's conventional to have <code>&amp;[T]</code> as an argument insteaed of
<code>&amp;Vec&lt;T&gt;</code>, or to ask about the layout of slices more generally.  Or to
ask analogous questions about <code>&amp;str</code> and <code>String</code>, et cetera.</p>
<p>This page exists to be a useful citation for such questions.</p>
<p>If you want, you can skip ahead to the <a href="#graphical-layout">graphical layout.</a></p>
<h2 id="what-is-a-slice-anyway"><a class="header" href="#what-is-a-slice-anyway">What is a slice anyway?</a></h2>
<p>The terminology around slices tends to be pretty loose.  I'll try to keep
it more formal on this page, but when you read something about a "slice"
elsewhere, keep in mind that it may be referring to any of <code>[T]</code>, <code>&amp;[T]</code>,
<code>&amp;mut [T]</code>, or even other types of references to <code>[T]</code> (<code>Box&lt;[T]&gt;</code>, <code>Arc&lt;[T]&gt;</code>, ...).</p>
<p>This is the case not just for casual material, but for
<a href="https://doc.rust-lang.org/std/primitive.slice.html">official documentation</a>
and other technical material.  You just have to figure out which one or
ones they are specifically talking about from context.</p>
<p>With that out of the way, let me intoduce some terminology for this page:</p>
<ul>
<li>
<p>A slice, <code>[T]</code>, is a series of <code>T</code> in contiguous memory (layed out one after
another, with proper alignment). The length is only known at run time; we say
it is a dynamically sized type (DST), or an unsized type, or a type that does
not implement <a href="https://doc.rust-lang.org/std/marker/trait.Sized.html"><code>Sized</code></a>.</p>
</li>
<li>
<p>A shared slice, <code>&amp;[T]</code>, is a shared reference to a slice. It's a wide
reference consisting of a pointer to the memory of the slice, and the number
of elements in the slice.</p>
</li>
<li>
<p>An exclusive slice, <code>&amp;mut [T]</code>, is like a shared slice, but the borrow is
exclusive (so you can e.g. overwrite elements through it).</p>
</li>
<li>
<p>There are other wide pointer variations like boxed slices (<code>Box&lt;[T]&gt;</code>) and
so on; we'll mention a few more momentarily.</p>
</li>
</ul>
<p>Note that while slices are unsized, the wide pointers to slices (like <code>&amp;[T]</code>)
are sized.</p>
<h3 id="where-is-a-slice"><a class="header" href="#where-is-a-slice">Where is a slice?</a></h3>
<p>Slices can be on the heap, but also on the stack, or in static memory, or
anywhere else.  The type doesn't "care" where it is.  Therefore, you can't
be sure where a pointer to a slice points unless the pointer itself has
further guarantees.</p>
<p>For example, if you have a <code>Box&lt;[T]&gt;</code>, then any <code>T</code> within are on the
heap, because that's a guarantee of
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box&lt;_&gt;</code>.</a>
(N.b. if <code>T</code> is zero sized, they are not actually stored anywhere.)
So in that <em>particular</em> case, we could say the slice <code>[T]</code> is on the heap.</p>
<h2 id="what-is-a-vec_-anyway"><a class="header" href="#what-is-a-vec_-anyway">What is a <code>Vec&lt;_&gt;</code> anyway?</a></h2>
<p>A <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> is growable buffer
that owns and stores <code>T</code>s in contiguous memory, on the heap.  You can conceptually
think of this as something that owns a slice <code>[T]</code> (or more accurately,
<code>[MaybeUninit&lt;T&gt;]</code>). You can index into a <code>Vec&lt;T&gt;</code> with a range and get back a
shared or exclusive slice.</p>
<p><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#guarantees">A <code>Vec&lt;_&gt;</code> consists of a pointer, capacity, and length.</a></p>
<h2 id="other-types"><a class="header" href="#other-types">Other types</a></h2>
<p>A <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> is, under the hood,
like a <code>Vec&lt;u8&gt;</code> which has additional guarantees -- namely, that the bytes are valid UTF8.
A <a href="https://doc.rust-lang.org/std/primitive.str.html"><code>&amp;str</code></a> is like a <code>&amp;[u8]</code> that has the
same guarantee.  You can index into a <code>String</code> with a range and get back a <code>&amp;str</code>
(or <code>&amp;mut str</code>). Like <code>[u8]</code>, a <code>str</code> is unsized, which is why you're almost always working
with a <code>&amp;str</code> or other pointer instead.</p>
<p>So the relationship betweeen <code>str</code> and <code>String</code> is the same as between <code>[T]</code> and <code>Vec&lt;T&gt;</code>.
There are other pairs of types with the same relationship:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/path/struct.Path.html"><code>Path</code></a> and <a href="https://doc.rust-lang.org/std/path/struct.PathBuf.html"><code>PathBuf</code></a></li>
<li><a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html"><code>OsStr</code></a> and <a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html"><code>OsString</code></a></li>
<li><a href="https://doc.rust-lang.org/std/ffi/struct.CStr.html"><code>CStr</code></a> and <a href="https://doc.rust-lang.org/std/ffi/struct.CString.html"><code>CString</code></a></li>
</ul>
<p>These <code>std</code> types generally have a <a href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#implementors"><code>ToOwned</code></a>
relationship and a <a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html#implementors"><code>Borrow</code></a> relationship.</p>
<p>Even more data structures that can be considered a form of <em>owned</em> slices include:</p>
<ul>
<li>
<p><a href="https://doc.rust-lang.org/std/primitive.array.html"><code>[T; N]</code></a> is an array with a
compile-time known length (i.e. it's a fixed-size array).  It is like a slice (<code>[T]</code>),
but it is <code>Sized</code>, as the the length is known at compile time.  The length is also part
of the type. It's not growable.</p>
</li>
<li>
<p><code>Box&lt;[T]&gt;</code>, a "boxed slice"; this is similar to a <code>Vec&lt;T&gt;</code> in that it owns the <code>T</code>
and stores them contiguously on the heap.  Unlike a <code>Vec&lt;T&gt;</code>, the buffer is not growable
(or shrinkable) through a <code>&amp;mut Box&lt;[T]&gt;</code>; you would have to allocate new storage and
move the elements over.  The length of a boxed slice is stored at runtime, and isn't
known at compile time.  Therefore, like a shared slice, it consists of a pointer and
a length.</p>
</li>
<li>
<p><code>Arc&lt;[T]&gt;</code> and <code>Rc&lt;[T]&gt;</code> are shared owneship variations on <code>Box&lt;[T]&gt;</code>.</p>
</li>
<li>
<p>There are similar variations for string-like types (<code>Box&lt;str&gt;</code>, <code>Arc&lt;Path&gt;</code>, <code>Rc&lt;OsStr&gt;</code>, ...)</p>
</li>
<li>
<p>And other combinations too (<code>Box&lt;[T; N]&gt;</code>, etc.)</p>
</li>
</ul>
<p>You can create shared slices to these other types of owned slices as well.</p>
<p>Technically, just a single <code>T</code> is like a <code>[T; 1]</code> (it has the same layout in memory).
So if you squint just right, every owned <code>T</code> is also a form of owned slice, but with
a compile-time known length of 1.  And indeed, you can create
<a href="https://doc.rust-lang.org/std/slice/fn.from_ref.html"><code>&amp;[T]</code></a>
and <a href="https://doc.rust-lang.org/std/slice/fn.from_mut.html"><code>&amp;mut [T]</code></a>
(<a href="https://doc.rust-lang.org/std/array/index.html#functions">and array versions too</a>)
from <code>&amp;T</code> and <code>&amp;mut T</code>.</p>
<h2 id="graphical-layout"><a class="header" href="#graphical-layout">Graphical layout</a></h2>
<p>Here's a graphical representation of the layout of slices, shared slices,
<code>Vec&lt;T&gt;</code>, and <code>&amp;Vec&lt;T&gt;</code>.</p>
<pre><code>+---+---+---+---+---+---+---+---+
| Pointer       | Length        | &amp;[T] (or &amp;str, &amp;Path, Box&lt;[T]&gt;, ...)
+---+---+---+---+---+---+---+---+
  |
  V
+---+---+---+---+---+---+---+---+
| D | A | T | A | . | . | . | ......    [T] (or str, Path, ...)
+---+---+---+---+---+---+---+---+
  ^
  |
+---+---+---+---+---+---+---+---+---+---+---+---+
| Pointer       | Length        | Capacity      | Vec&lt;T&gt; (or String, PathBuf, ...)
+---+---+---+---+---+---+---+---+---+---+---+---+
  ^
  |
+---+---+---+---+
| Pointer       | &amp;Vec&lt;T&gt; (or &amp;String, &amp;PathBuf, ...)
+---+---+---+---+
</code></pre>
<p>One advantage of taking <code>&amp;[T]</code> instead of <code>&amp;Vec&lt;T&gt;</code> as an argument should be
immediately apparent from the diagram: a <code>&amp;[T]</code> has less indirection.</p>
<p>However, there are other reasons:</p>
<ul>
<li>Everything useful for <code>&amp;Vec&lt;T&gt;</code> is actually a method on <code>&amp;[T]</code>
<ul>
<li>You can't check the capacity with a <code>&amp;[T]</code>, but you can't change the capacity with a <code>&amp;Vec&lt;T&gt;</code> anyway</li>
</ul>
</li>
<li>If you take <code>&amp;[T]</code> as an argument, you can take shared slices that point to data
which isn't owned by a <code>Vec&lt;T&gt;</code> (such as static data, part of an array, into a <code>Box&lt;[T]&gt;</code>, et cetera)
<ul>
<li>So it is strictly and significantly more general to take <code>&amp;[T]</code></li>
</ul>
</li>
</ul>
<p>Similar advantages apply to taking a <code>&amp;str</code> instead of a <code>&amp;String</code>, et cetera.</p>
<p>In contrast, there are many things you can do with a <code>&amp;mut Vec&lt;T&gt;</code> that you can't
do with a <code>&amp;mut [T]</code>, so which you choose depends much more on what you need to
do with the borrowed data.</p>
<h3 id="graphical-layout-for-arrays"><a class="header" href="#graphical-layout-for-arrays">Graphical layout for arrays</a></h3>
<p>The layout of an array is the same as a slice, except the length is known.</p>
<pre><code>+---+---+---+---+---+---+---+---+
| Pointer       | Length        | &amp;[T] (or &amp;str, &amp;Path, Box&lt;[T]&gt;, ...)
+---+---+---+---+---+---+---+---+
  |
  V
+---+---+---+---+---+---+---+
| D | A | T | A | . | . | . | [T; N] (or str, Path, ...)
+---+---+---+---+---+---+---+
  ^
  |
+---+---+---+---+
| Pointer       | &amp;[T; N] (or `Box&lt;[T; N]&gt;`, ...)
+---+---+---+---+
  ^
  |
+---+---+---+---+
| Pointer       | &amp;Box&lt;[T; N]&gt; (or &amp;&amp;[T; N], ...)
+---+---+---+---+
</code></pre>
<p>Because <code>[T; N]</code> is sized, and because the length is part of the type,
pointers to it (like <code>&amp;[T; N]</code>) are normal "thin" pointers, not "wide"
pointers.  But you can also create a <code>&amp;[T]</code> that points to the array
(or to part of the array), as in the diagram.</p>
<p>Should you take a <code>&amp;[T]</code> or a <code>&amp;[T; N]</code> as a function argument?  If
you don't need a specific length, and aren't trying to generate code
that's optimized based on the specific length of the array, you probably
want <code>&amp;[T]</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="miscellanea.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="misc-default-param.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="miscellanea.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="misc-default-param.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
