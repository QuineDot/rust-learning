<!DOCTYPE HTML>
<html lang="en" class="navy" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Understand borrows within a function - Learning Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Advice for learning Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('navy')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Practical suggestions for building intuition around borrow errors</li><li class="chapter-item "><a href="lifetime-intuition.html"><strong aria-hidden="true">1.</strong> Sectional introduction</a></li><li class="chapter-item "><a href="community.html"><strong aria-hidden="true">2.</strong> Keep at it and participate in the community</a></li><li class="chapter-item "><a href="have-no-life.html"><strong aria-hidden="true">3.</strong> Prefer ownership over long-lived references</a></li><li class="chapter-item "><a href="dont-hide.html"><strong aria-hidden="true">4.</strong> Don't hide lifetimes</a></li><li class="chapter-item "><a href="elision.html"><strong aria-hidden="true">5.</strong> Understand elision and get a feel for when to name lifetimes</a></li><li class="chapter-item "><a href="subtypes.html"><strong aria-hidden="true">6.</strong> Get a feel for variance, references, and reborrows</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="st-model.html"><strong aria-hidden="true">6.1.</strong> The seed of a mental model</a></li><li class="chapter-item "><a href="st-types.html"><strong aria-hidden="true">6.2.</strong> Reference types</a></li><li class="chapter-item "><a href="st-bounds.html"><strong aria-hidden="true">6.3.</strong> Lifetime bounds</a></li><li class="chapter-item "><a href="st-references.html"><strong aria-hidden="true">6.4.</strong> Reference lifetimes</a></li><li class="chapter-item "><a href="st-reborrow.html"><strong aria-hidden="true">6.5.</strong> Copy and reborrows</a></li><li class="chapter-item "><a href="st-invariance.html"><strong aria-hidden="true">6.6.</strong> Nested borrows and invariance</a></li><li class="chapter-item "><a href="st-more-invariance.html"><strong aria-hidden="true">6.7.</strong> Invariance elsewhere</a></li><li class="chapter-item "><a href="st-non-references.html"><strong aria-hidden="true">6.8.</strong> Non-references</a></li></ol></li><li class="chapter-item "><a href="methods.html"><strong aria-hidden="true">7.</strong> Get a feel for borrow-returning methods</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="m-naming.html"><strong aria-hidden="true">7.1.</strong> When not to name lifetimes</a></li><li class="chapter-item "><a href="m-infect.html"><strong aria-hidden="true">7.2.</strong> Bound-related lifetimes "infect" each other</a></li><li class="chapter-item "><a href="m-no-downgrades.html"><strong aria-hidden="true">7.3.</strong> &mut inputs don't "downgrade" to &</a></li><li class="chapter-item "><a href="m-rpitit-alikes.html"><strong aria-hidden="true">7.4.</strong> async and returning impl Trait</a></li></ol></li><li class="chapter-item "><a href="fn-parameters.html"><strong aria-hidden="true">8.</strong> Understand function lifetime parameters</a></li><li class="chapter-item expanded "><a href="lifetime-analysis.html" class="active"><strong aria-hidden="true">9.</strong> Understand borrows within a function</a></li><li class="chapter-item "><a href="pitfalls.html"><strong aria-hidden="true">10.</strong> Learn some pitfalls and antipatterns</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pf-dyn.html"><strong aria-hidden="true">10.1.</strong> dyn Trait lifetimes and Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="pf-nll3.html"><strong aria-hidden="true">10.2.</strong> Conditional return of a borrow</a></li><li class="chapter-item "><a href="pf-borrow-forever.html"><strong aria-hidden="true">10.3.</strong> Borrowing something forever</a></li><li class="chapter-item "><a href="pf-self.html"><strong aria-hidden="true">10.4.</strong> &'a mut self and Self aliasing more generally</a></li><li class="chapter-item "><a href="pf-meta.html"><strong aria-hidden="true">10.5.</strong> Avoid self-referential structs</a></li><li class="chapter-item "><a href="pf-shared-nested.html"><strong aria-hidden="true">10.6.</strong> &'a Struct&lt;'a&gt; and covariance</a></li></ol></li><li class="chapter-item "><a href="compiler.html"><strong aria-hidden="true">11.</strong> Scrutinize compiler advice</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c-signatures.html"><strong aria-hidden="true">11.1.</strong> Advice to change function signature when aliases are involved</a></li><li class="chapter-item "><a href="c-equality.html"><strong aria-hidden="true">11.2.</strong> Advice to add bound which implies lifetime equality</a></li><li class="chapter-item "><a href="c-static.html"><strong aria-hidden="true">11.3.</strong> Advice to add a static bound</a></li></ol></li><li class="chapter-item "><a href="lt-examples.html"><strong aria-hidden="true">12.</strong> Illustrative examples</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lt-ex-mut-slice.html"><strong aria-hidden="true">12.1.</strong> Mutable slice iterator</a></li></ol></li><li class="chapter-item "><a href="circle.html"><strong aria-hidden="true">13.</strong> Circle back</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Miscellanea</li><li class="chapter-item "><a href="miscellanea.html"><strong aria-hidden="true">14.</strong> Sectional introduction</a></li><li class="chapter-item "><a href="misc-slice.html"><strong aria-hidden="true">15.</strong> Slice layout</a></li><li class="chapter-item "><a href="misc-default-param.html"><strong aria-hidden="true">16.</strong> Default parameter mechanics</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">A tour of dyn Trait</li><li class="chapter-item "><a href="dyn-trait.html"><strong aria-hidden="true">17.</strong> Sectional introduction</a></li><li class="chapter-item "><a href="dyn-trait-overview.html"><strong aria-hidden="true">18.</strong> dyn Trait overview</a></li><li class="chapter-item "><a href="dyn-trait-impls.html"><strong aria-hidden="true">19.</strong> dyn Trait implementations</a></li><li class="chapter-item "><a href="dyn-trait-coercions.html"><strong aria-hidden="true">20.</strong> dyn Trait coercions</a></li><li class="chapter-item "><a href="dyn-safety.html"><strong aria-hidden="true">21.</strong> dyn safety (object safety)</a></li><li class="chapter-item "><a href="dyn-trait-lifetime.html"><strong aria-hidden="true">22.</strong> dyn Trait lifetimes</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dyn-covariance.html"><strong aria-hidden="true">22.1.</strong> Variance</a></li><li class="chapter-item "><a href="dyn-hr.html"><strong aria-hidden="true">22.2.</strong> Higher-ranked types</a></li><li class="chapter-item "><a href="dyn-elision.html"><strong aria-hidden="true">22.3.</strong> Elision rules</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dyn-elision-basic.html"><strong aria-hidden="true">22.3.1.</strong> Basic guidelines</a></li><li class="chapter-item "><a href="dyn-elision-advanced.html"><strong aria-hidden="true">22.3.2.</strong> Advanced guidelines</a></li><li class="chapter-item "><a href="dyn-elision-trait-bounds.html"><strong aria-hidden="true">22.3.3.</strong> Trait bound interactions</a></li><li class="chapter-item "><a href="dyn-elision-citations.html"><strong aria-hidden="true">22.3.4.</strong> Citations</a></li></ol></li></ol></li><li class="chapter-item "><a href="dyn-trait-vs.html"><strong aria-hidden="true">23.</strong> dyn Trait vs. alternatives</a></li><li class="chapter-item "><a href="dyn-trait-examples.html"><strong aria-hidden="true">24.</strong> dyn Trait examples</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dyn-trait-combining.html"><strong aria-hidden="true">24.1.</strong> Combining traits</a></li><li class="chapter-item "><a href="dyn-trait-box-impl.html"><strong aria-hidden="true">24.2.</strong> impl Trait for Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="dyn-trait-clone.html"><strong aria-hidden="true">24.3.</strong> Cloneable Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="dyn-trait-eq.html"><strong aria-hidden="true">24.4.</strong> dyn PartialEq</a></li><li class="chapter-item "><a href="dyn-trait-borrow.html"><strong aria-hidden="true">24.5.</strong> Generalizing borrows</a></li><li class="chapter-item "><a href="dyn-trait-erased.html"><strong aria-hidden="true">24.6.</strong> Erased traits</a></li><li class="chapter-item "><a href="dyn-trait-hash.html"><strong aria-hidden="true">24.7.</strong> Hashable Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="dyn-any-examples.html"><strong aria-hidden="true">24.8.</strong> dyn Any examples</a></li></ol></li><li class="chapter-item "><a href="dyn-any.html"><strong aria-hidden="true">25.</strong> dyn Any</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learning Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/QuineDot/rust-learning" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="understand-borrows-within-a-function"><a class="header" href="#understand-borrows-within-a-function">Understand borrows within a function</a></h1>
<p>The analysis that the compiler does to determine lifetimes and borrow check
<em>within</em> a function body is quite complicated.  A full exploration is beyond
the scope of this guide, but we'll give a brief introduction here.</p>
<p>Your best bet if you run into an error you can't understand is to
ask for help on the forum or elsewhere.</p>
<h2 id="borrow-errors-within-a-function"><a class="header" href="#borrow-errors-within-a-function">Borrow errors within a function</a></h2>
<p>Here are some simple causes of borrow check errors within a function.</p>
<h3 id="recalling-the-basics"><a class="header" href="#recalling-the-basics">Recalling the Basics</a></h3>
<p>The most basic mechanism to keep in mind is that <code>&amp;mut</code> references are exclusive,
while <code>&amp;</code> references are shared and implement <code>Copy</code>.  You can't intermix using
a shared reference and an exclusive reference to the same value, or two exclusive
references to the same value.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let mut local = "Hello".to_string();

// Creating and using a shared reference
let x = &amp;local;
println!("{x}");

// Creating and using an exclusive reference
let y = &amp;mut local;
y.push_str(", world!");

// Trying to use the shared reference again
println!("{x}");
<span class="boring">}</span></code></pre></pre>
<p>This doesn't compile because as soon as you created the exclusive reference,
any other existing references must cease to be valid.</p>
<h3 id="borrows-are-often-implicit"><a class="header" href="#borrows-are-often-implicit">Borrows are often implicit</a></h3>
<p>Here's the example again, only slightly rewritten.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let mut local = "Hello".to_string();

// Creating and using a shared reference
let x = &amp;local;
println!("{x}");

// Implicitly creating and using an exclusive reference
local.push_str(", world!");

// Trying to use the shared reference again
println!("{x}");
<span class="boring">}</span></code></pre></pre>
<p>Here, <a href="https://doc.rust-lang.org/std/string/struct.String.html#method.push_str"><code>push_str</code> takes <code>&amp;mut self</code>,</a>
so an implicit <code>&amp;mut local</code> exists as part of the method call,
and thus the example can still not compile.</p>
<h3 id="creating-a-mut-is-not-the-only-exclusive-use"><a class="header" href="#creating-a-mut-is-not-the-only-exclusive-use">Creating a <code>&amp;mut</code> is not the only exclusive use</a></h3>
<p>The borrow checker looks at <em>every</em> use of a value to see if it's
compatible with the lifetimes of borrows to that value, not
just uses that involve references or just uses that involve lifetimes.</p>
<p>For example, moving a value invalidates any references to the
value, as otherwise those references would dangle.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let local = "Hello".to_string();

// Creating and using a shared reference
let x = &amp;local;
println!("{x}");

// Moving the value
let _local = local;

// Trying to use the shared reference again
println!("{x}");
<span class="boring">}</span></code></pre></pre>
<h3 id="referenced-values-must-remain-in-scope"><a class="header" href="#referenced-values-must-remain-in-scope">Referenced values must remain in scope</a></h3>
<p>The effects of a value going out of scope are similar to moving the
value: all references are invalidated.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let x;
{
    let local = "Hello".to_string();
    x = &amp;local;
} // `local` goes out of scope here

// Trying to use the shared reference after `local` goes out of scope
println!("{x}");
<span class="boring">}</span></code></pre></pre>
<h3 id="using-mut-self-or-self-counts-as-a-use-of-all-fields"><a class="header" href="#using-mut-self-or-self-counts-as-a-use-of-all-fields">Using <code>&amp;mut self</code> or <code>&amp;self</code> counts as a use of all fields</a></h3>
<p>In the example below, <code>left</code> becomes invalid when we create <code>&amp;self</code>
to call <code>bar</code>.  Because you can get a <code>&amp;self.left</code> out of a <code>&amp;self</code>,
this is similar to trying to intermix <code>&amp;mut self.left</code> and <code>&amp;self.left</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Pair {
    left: String,
    right: String,
}

impl Pair {
    fn foo(&amp;mut self) {
        let left = &amp;mut self.left;
        left.push_str("hi");
        self.bar();
        println!("{left}");
    }
    fn bar(&amp;self) {
        println!("{self:?}");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>More generally, creating a <code>&amp;mut x</code> or <code>&amp;x</code> counts as a use of
everything reachable from <code>x</code>.</p>
<h2 id="some-things-that-compile-successfully"><a class="header" href="#some-things-that-compile-successfully">Some things that compile successfully</a></h2>
<p>Once you've started to get the hang of borrow errors, you might start to
wonder why certain programs are <em>allowed</em> to compile.  Here we introduce
some of the ways that Rust allows non-trivial borrowing while still being
sound.</p>
<h3 id="independently-borrowing-fields"><a class="header" href="#independently-borrowing-fields">Independently borrowing fields</a></h3>
<p>Rust tracks borrows of struct fields individually, so the borrows of
<code>left</code> and <code>right</code> below do not conflict.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Pair {
</span><span class="boring">    left: String,
</span><span class="boring">    right: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Pair {
    fn foo(&amp;mut self) {
        let left = &amp;mut self.left;
        let right = &amp;mut self.right;
        left.push_str("hi");
        right.push_str("there");
        println!("{left} {right}");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This capability is also called <a href="https://doc.rust-lang.org/nomicon/borrow-splitting.html">splitting borrows.</a></p>
<p>Note that data you access through indexing are not consider fields
per se; instead indexing is <a href="https://doc.rust-lang.org/std/ops/trait.Index.html">an operation that generally borrows
all of <code>&amp;self</code> or <code>&amp;mut self</code>.</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let mut v = vec![0, 1, 2];

// These two do not overlap, but...
let left = &amp;mut v[..1];
let right = &amp;mut v[1..];

// ...the borrow checker cannot recognize that
println!("{left:?} {right:?}");
<span class="boring">}</span></code></pre></pre>
<p>Usually in this case, one uses methods like <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_at_mut"><code>split_at_mut</code></a>
in order to split the borrows instead.</p>
<p>Similarly to indexing, when you access something through "deref coercion", you're
exercising <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">the <code>Deref</code> trait</a>
(or <code>DerefMut</code>), which borrow all of <code>self</code>.</p>
<p>There are also some niche cases where the borrow checker is smarter, however.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>// Pattern matching does understand non-overlapping slices (slices are special)
let mut v = vec![String::new(), String::new()];
let slice = &amp;mut v[..];
if let [_left, right] = slice {
    if let [left, ..] = slice {
        left.push_str("left");
    }
    // Still usable!
    right.push_str("right");
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>// You can split borrows through a `Box` dereference (`Box` is special)
let mut bx = Box::new((0, 1));
let left = &amp;mut bx.0;
let right = &amp;mut bx.1;
*left += 1;
*right += 1;
<span class="boring">}</span></code></pre></pre>
<p>The examples are non-exhaustive üôÇ.</p>
<h3 id="reborrowing"><a class="header" href="#reborrowing">Reborrowing</a></h3>
<p><a href="./st-reborrow.html">As mentioned before,</a> reborrows are what make <code>&amp;mut</code> reasonable to use.
In fact, they have other special properties you can't emulate with a custom struct and
trait implementations.  Consider this example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(s: &amp;mut String) -&gt; &amp;str {
    &amp;**s
}
<span class="boring">}</span></code></pre></pre>
<p>Actually, that's too fast.  Let's change this a little bit and go step by step.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(s: &amp;mut String) -&gt; &amp;str {
    let ms: &amp;mut str = &amp;mut **s;
    let rs: &amp;str = &amp;*s;
    rs
}
<span class="boring">}</span></code></pre></pre>
<p>Here, both <code>s</code> and <code>ms</code> are going out of scope at the end of <code>foo</code>, but this doesn't
invalidate <code>rs</code>.  That is, reborrowing through references can impose lifetime constraints
on the reborrow, but the reborrow is not dependent on references staying in scope!  It is
only dependent on the borrowed data.</p>
<p>This demonstrates that reborrowing is more powerful than nesting references.</p>
<h3 id="shared-reborrowing"><a class="header" href="#shared-reborrowing">Shared reborrowing</a></h3>
<p>When it comes to detecting conflicts, the borrow checker distinguishes between shared
reborrows and exclusive ones.  In particular, creating a shared reborrow will invalidate
any exclusive reborrows of the same value (as they are no longer exclusive).  But it will
not invalidated shared reborrows:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Pair {
    left: String,
    right: String,
}

impl Pair {
    fn foo(&amp;mut self) {
        // a split borrow: exclusive reborrow, shared reborrow
        let left = &amp;mut self.left;
        let right = &amp;self.right;
        left.push('x');

        // Shared reborrow of all of `self`, which "covers" all fields
        let this = &amp;*self;

        // It invalidates any exclusive reborrows, so this will fail...
        // println!("{left}");

        // But it does not invalidate shared reborrows!
        println!("{right}");
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="two-phase-borrows"><a class="header" href="#two-phase-borrows">Two-phase borrows</a></h3>
<p>The following code compiles:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let mut v = vec![0];
let shared = &amp;v;
v.push(shared.len());
<span class="boring">}</span></code></pre></pre>
<p>However, if you're aware of the order of evaluation here, it probably seems like it shouldn't.
The implicit <code>&amp;mut v</code> should have invalidated <code>shared</code> before <code>shared.len()</code> was evaluated.
What gives?</p>
<p>This is the result of a feature called two-phase borrows, which is intended to make
<a href="https://rust-lang.github.io/rfcs/2025-nested-method-calls.html">nested method calls</a>
more ergonomic:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let mut v = vec![0];
v.push(v.len());
<span class="boring">}</span></code></pre></pre>
<p><a href="https://rust.godbolt.org/z/966j4Eh1f">In the olden days,</a> you would have had to write it like so:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let mut v = vec![0];
let len = v.len();
v.push(len);
<span class="boring">}</span></code></pre></pre>
<p>The implementation slipped, which is why the first example compiles too.  How far it slipped
is hard to say, as not only is there <a href="https://github.com/rust-lang/rust/issues/46901">no specification,</a>
the feature doesn't even seem to be documented ü§∑.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="fn-parameters.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="pitfalls.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="fn-parameters.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="pitfalls.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
