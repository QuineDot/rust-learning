<!DOCTYPE HTML>
<html lang="en" class="navy" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Learning Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Advice for learning Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('navy')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Practical suggestions for building intuition around borrow errors</li><li class="chapter-item "><a href="lifetime-intuition.html"><strong aria-hidden="true">1.</strong> Sectional introduction</a></li><li class="chapter-item "><a href="community.html"><strong aria-hidden="true">2.</strong> Keep at it and participate in the community</a></li><li class="chapter-item "><a href="have-no-life.html"><strong aria-hidden="true">3.</strong> Prefer ownership over long-lived references</a></li><li class="chapter-item "><a href="dont-hide.html"><strong aria-hidden="true">4.</strong> Don't hide lifetimes</a></li><li class="chapter-item "><a href="elision.html"><strong aria-hidden="true">5.</strong> Understand elision and get a feel for when to name lifetimes</a></li><li class="chapter-item "><a href="subtypes.html"><strong aria-hidden="true">6.</strong> Get a feel for variance, references, and reborrows</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="st-model.html"><strong aria-hidden="true">6.1.</strong> The seed of a mental model</a></li><li class="chapter-item "><a href="st-types.html"><strong aria-hidden="true">6.2.</strong> Reference types</a></li><li class="chapter-item "><a href="st-bounds.html"><strong aria-hidden="true">6.3.</strong> Lifetime bounds</a></li><li class="chapter-item "><a href="st-references.html"><strong aria-hidden="true">6.4.</strong> Reference lifetimes</a></li><li class="chapter-item "><a href="st-reborrow.html"><strong aria-hidden="true">6.5.</strong> Copy and reborrows</a></li><li class="chapter-item "><a href="st-invariance.html"><strong aria-hidden="true">6.6.</strong> Nested borrows and invariance</a></li><li class="chapter-item "><a href="st-more-invariance.html"><strong aria-hidden="true">6.7.</strong> Invariance elsewhere</a></li><li class="chapter-item "><a href="st-non-references.html"><strong aria-hidden="true">6.8.</strong> Non-references</a></li></ol></li><li class="chapter-item "><a href="methods.html"><strong aria-hidden="true">7.</strong> Get a feel for borrow-returning methods</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="m-naming.html"><strong aria-hidden="true">7.1.</strong> When not to name lifetimes</a></li><li class="chapter-item "><a href="m-infect.html"><strong aria-hidden="true">7.2.</strong> Bound-related lifetimes "infect" each other</a></li><li class="chapter-item "><a href="m-no-downgrades.html"><strong aria-hidden="true">7.3.</strong> &mut inputs don't "downgrade" to &</a></li><li class="chapter-item "><a href="m-rpitit-alikes.html"><strong aria-hidden="true">7.4.</strong> async and returning impl Trait</a></li></ol></li><li class="chapter-item "><a href="fn-parameters.html"><strong aria-hidden="true">8.</strong> Understand function lifetime parameters</a></li><li class="chapter-item "><a href="lifetime-analysis.html"><strong aria-hidden="true">9.</strong> Understand borrows within a function</a></li><li class="chapter-item "><a href="pitfalls.html"><strong aria-hidden="true">10.</strong> Learn some pitfalls and antipatterns</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pf-dyn.html"><strong aria-hidden="true">10.1.</strong> dyn Trait lifetimes and Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="pf-nll3.html"><strong aria-hidden="true">10.2.</strong> Conditional return of a borrow</a></li><li class="chapter-item "><a href="pf-borrow-forever.html"><strong aria-hidden="true">10.3.</strong> Borrowing something forever</a></li><li class="chapter-item "><a href="pf-self.html"><strong aria-hidden="true">10.4.</strong> &'a mut self and Self aliasing more generally</a></li><li class="chapter-item "><a href="pf-meta.html"><strong aria-hidden="true">10.5.</strong> Avoid self-referential structs</a></li><li class="chapter-item "><a href="pf-shared-nested.html"><strong aria-hidden="true">10.6.</strong> &'a Struct&lt;'a&gt; and covariance</a></li></ol></li><li class="chapter-item "><a href="compiler.html"><strong aria-hidden="true">11.</strong> Scrutinize compiler advice</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c-signatures.html"><strong aria-hidden="true">11.1.</strong> Advice to change function signature when aliases are involved</a></li><li class="chapter-item "><a href="c-equality.html"><strong aria-hidden="true">11.2.</strong> Advice to add bound which implies lifetime equality</a></li><li class="chapter-item "><a href="c-static.html"><strong aria-hidden="true">11.3.</strong> Advice to add a static bound</a></li></ol></li><li class="chapter-item "><a href="lt-examples.html"><strong aria-hidden="true">12.</strong> Illustrative examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lt-ex-mut-slice.html"><strong aria-hidden="true">12.1.</strong> Mutable slice iterator</a></li></ol></li><li class="chapter-item "><a href="circle.html"><strong aria-hidden="true">13.</strong> Circle back</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Miscellanea</li><li class="chapter-item "><a href="miscellanea.html"><strong aria-hidden="true">14.</strong> Sectional introduction</a></li><li class="chapter-item "><a href="misc-slice.html"><strong aria-hidden="true">15.</strong> Slice layout</a></li><li class="chapter-item "><a href="misc-default-param.html"><strong aria-hidden="true">16.</strong> Default parameter mechanics</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">A tour of dyn Trait</li><li class="chapter-item "><a href="dyn-trait.html"><strong aria-hidden="true">17.</strong> Sectional introduction</a></li><li class="chapter-item "><a href="dyn-trait-overview.html"><strong aria-hidden="true">18.</strong> dyn Trait overview</a></li><li class="chapter-item "><a href="dyn-trait-impls.html"><strong aria-hidden="true">19.</strong> dyn Trait implementations</a></li><li class="chapter-item "><a href="dyn-trait-coercions.html"><strong aria-hidden="true">20.</strong> dyn Trait coercions</a></li><li class="chapter-item "><a href="dyn-safety.html"><strong aria-hidden="true">21.</strong> dyn safety (object safety)</a></li><li class="chapter-item "><a href="dyn-trait-lifetime.html"><strong aria-hidden="true">22.</strong> dyn Trait lifetimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dyn-covariance.html"><strong aria-hidden="true">22.1.</strong> Variance</a></li><li class="chapter-item "><a href="dyn-hr.html"><strong aria-hidden="true">22.2.</strong> Higher-ranked types</a></li><li class="chapter-item "><a href="dyn-elision.html"><strong aria-hidden="true">22.3.</strong> Elision rules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dyn-elision-basic.html"><strong aria-hidden="true">22.3.1.</strong> Basic guidelines</a></li><li class="chapter-item "><a href="dyn-elision-advanced.html"><strong aria-hidden="true">22.3.2.</strong> Advanced guidelines</a></li><li class="chapter-item "><a href="dyn-elision-trait-bounds.html"><strong aria-hidden="true">22.3.3.</strong> Trait bound interactions</a></li><li class="chapter-item "><a href="dyn-elision-citations.html"><strong aria-hidden="true">22.3.4.</strong> Citations</a></li></ol></li></ol></li><li class="chapter-item "><a href="dyn-trait-vs.html"><strong aria-hidden="true">23.</strong> dyn Trait vs. alternatives</a></li><li class="chapter-item "><a href="dyn-trait-examples.html"><strong aria-hidden="true">24.</strong> dyn Trait examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dyn-trait-combining.html"><strong aria-hidden="true">24.1.</strong> Combining traits</a></li><li class="chapter-item "><a href="dyn-trait-box-impl.html"><strong aria-hidden="true">24.2.</strong> impl Trait for Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="dyn-trait-clone.html"><strong aria-hidden="true">24.3.</strong> Cloneable Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="dyn-trait-eq.html"><strong aria-hidden="true">24.4.</strong> dyn PartialEq</a></li><li class="chapter-item "><a href="dyn-trait-borrow.html"><strong aria-hidden="true">24.5.</strong> Generalizing borrows</a></li><li class="chapter-item "><a href="dyn-trait-erased.html"><strong aria-hidden="true">24.6.</strong> Erased traits</a></li><li class="chapter-item "><a href="dyn-trait-hash.html"><strong aria-hidden="true">24.7.</strong> Hashable Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="dyn-any-examples.html"><strong aria-hidden="true">24.8.</strong> dyn Any examples</a></li></ol></li><li class="chapter-item "><a href="dyn-any.html"><strong aria-hidden="true">25.</strong> dyn Any</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learning Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/QuineDot/rust-learning" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="learning-rust"><a class="header" href="#learning-rust">Learning Rust</a></h1>
<p>Welcome to my collection of resources for those learning the
<a href="https://www.rust-lang.org/">Rust programming language.</a>  The advice in
these pages is typically suitable for those with at least a beginning
familiarity of Rust -- for example, those who have worked through
<a href="https://doc.rust-lang.org/book/">The Book</a> -- but are still experiencing
the growing pains of learning Rust.</p>
<h2 id="practical-suggestions-for-building-intuition-around-borrow-errors"><a class="header" href="#practical-suggestions-for-building-intuition-around-borrow-errors"><a href="lifetime-intuition.html">Practical suggestions for building intuition around borrow errors</a></a></h2>
<p>In this section we outline the basics of understanding lifetimes and borrowing for
those who are struggling with understanding borrow check errors.</p>
<h2 id="miscellanea"><a class="header" href="#miscellanea"><a href="./miscellanea.html">Miscellanea</a></a></h2>
<p>This section collects relatively small and self-contained tutorials and other tidbits.</p>
<h2 id="a-tour-of-dyn-trait"><a class="header" href="#a-tour-of-dyn-trait"><a href="./dyn-trait.html">A tour of <code>dyn Trait</code></a></a></h2>
<p>In this section we explore what <code>dyn Trait</code> is and is not, go over its limitations
and strengths, deep dive on how lifetimes work with <code>dyn Trait</code>, provide some
common <code>dyn Trait</code> recipes, and more.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="practical-suggestions-for-building-intuition-around-borrow-errors-1"><a class="header" href="#practical-suggestions-for-building-intuition-around-borrow-errors-1">Practical suggestions for building intuition around borrow errors</a></h1>
<p>Ownership, borrowing, and lifetimes covers a lot of ground in Rust, and thus this section is somewhat long.
It is also hard to create a succinct overview of the topic, as what aspects of the topic a newcomer
first encounters depends on what projects they take on in the process of learning Rust. The genesis of
this guide was advice for someone who picked a zero-copy regular expression crate as their learning project,
and as such they ran into a lot of lifetime issues off the bat.  Someone who chose a web framework would be
more likely to run into issues around <code>Arc</code> and <code>Mutex</code>, those who start with <code>async</code> projects will likely
run into many <code>async</code>-specific errors, and so on.</p>
<p>Despite the length of this section, there are entire areas it doesn't yet touch on, such as destructor
mechanics, shared ownership and shared mutability, and so on.</p>
<p>Even so, it's not expected that anyone will absorb everything in this guide all at once.  Instead,
it's intended to be a broad introduction to the topic.  Skim it on your first pass and take time on
the parts that seem relevant, or use them as pointers to look up more in-depth documentation on your
own.  Hopefully you will get a feel for what kind errors can arise even if you haven't ran into them
yourself yet, so that you're not completely baffled when they do arise.</p>
<p>In general, your mental model of ownership and borrowing will go through a few stages of evolution.
It will pay off to return to any given area of the topic with fresh eyes every once in awhile.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keep-at-it-and-participate-in-the-community"><a class="header" href="#keep-at-it-and-participate-in-the-community">Keep at it and participate in the community</a></h1>
<p>Experience plays a very big role in understanding borrow errors and being able
to figure out why some code is problematic in a reasonable amount of time.
Running into borrow check errors and solving them, either on your own or by
asking for help, is a part of the process of building up that intuition.</p>
<p>I personally learned a great deal by participating on the
<a href="https://users.rust-lang.org/">Rust user's forum, URLO.</a>  Another way you can
build experience and broaden your intuition is by reading other's lifetime
questions on that forum, reading the replies to those questions, and trying
to solve their problems -- or even just experiment with them! -- yourself.</p>
<p>By being an active participant, you can not only learn more, but will eventually
be able to help out other users.</p>
<ul>
<li>When you read a question and are lost: read the replies and see if you can understand them and learn more</li>
<li>When you have played with a question and got it to compile but aren't sure why: reply with something like
"I don't know if this fixes your use case, but this compiles for me: <a href="https://play.rust-lang.org/">Playground</a>"</li>
<li>After you've got the hang of certain common problems: "It's because of XYZ.  You can do this instead: ..."</li>
</ul>
<p>Even after I got my sea-legs, some of the more advanced lifetime and borrow-checker skills
I've developed came from solving other people's problems on this forum. Once you can answer
their questions, you may still learn things if someone else comes along and provides a
different or better solution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prefer-ownership-over-long-lived-references"><a class="header" href="#prefer-ownership-over-long-lived-references">Prefer ownership over long-lived references</a></h1>
<p>A common newcomer mistake is to overuse references or other lifetime-carrying
data structures by storing them in their own long-lived structures.  This is
often a mistake as the primary use-case of non-<code>'static</code> references is for
short-term borrows.</p>
<p>If you're trying to create a lifetime-carrying struct, stop and consider if
you could use a struct with no lifetime instead, for example by replacing
<code>&amp;str</code> with <code>String</code>, or <code>&amp;[T]</code> with <code>Vec&lt;T&gt;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dont-hide-lifetimes"><a class="header" href="#dont-hide-lifetimes">Don't hide lifetimes</a></h1>
<p>When you use lifetime-carrying structs (whether your own or someone else's),
the Rust compiler currently let's you elide the lifetime parameter when
mentioning the struct:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a&gt;(&amp;'a str);

impl&lt;'a&gt; Foo&lt;'a&gt; {
    // No lifetime syntax needed :-(
    //                 vvv
    fn new(s: &amp;str) -&gt; Foo {
        Foo(s)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This can make it non-obvious that borrowing is going on, and harder to figure
out where errors are coming from.  To save yourself some headaches, I recommend
using the <code>#![deny(elided_lifetimes_in_paths)]</code> lint:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span>#![deny(elided_lifetimes_in_paths)]
<span class="boring">fn main() {
</span>struct Foo&lt;'a&gt;(&amp;'a str);

impl&lt;'a&gt; Foo&lt;'a&gt; {
    // Now this is an error
    //                 vvv
    fn new(s: &amp;str) -&gt; Foo {
        Foo(s)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The first thing I do when taking on a borrow check error in someone else's code
is to turn on this lint.  If you have not enabled the lint and are getting errors
in your own code, try enabling the lint.  For every place that errors, take a moment
to pause and consider what is going on with the lifetimes.  Sometimes there's only
one possibility and you will just need to make a trivial change:</p>
<pre><code class="language-diff">-    fn new(s: &amp;str) -&gt; Foo {
+    fn new(s: &amp;str) -&gt; Foo&lt;'_&gt; {
</code></pre>
<p>But often, in my experience, one of the error sites will be part of the problem
you're dealing with.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understand-elision-and-get-a-feel-for-when-to-name-lifetimes"><a class="header" href="#understand-elision-and-get-a-feel-for-when-to-name-lifetimes">Understand elision and get a feel for when to name lifetimes</a></h1>
<p><a href="https://doc.rust-lang.org/reference/lifetime-elision.html">Read the function lifetime elision rules.</a>
They're intuitive for the most part.  The elision rules are built around being what you need in the common case,
but they're not always the solution.  For example, they assume an input of <code>&amp;'s self</code> means you mean to return a
borrow of <code>self</code> or its contents with lifetime <code>'s</code>, but this is often <em>not</em> correct for lifetime-carrying
data structures.</p>
<p>If you get a lifetime error involving elided lifetimes, try giving all the lifetimes names. This can improve
the compiler errors; if nothing else, you won't have to work so hard to mentally track the numbers used in
errors for illustration, or what "anonymous lifetime" is being talked about.</p>
<p>Take care to refer to the elision rules when naming all the lifetimes, or you may inadvertently change the
meaning of the signature.  If the error changes <em>drastically,</em> you've probably changed the meaning of the
signature.</p>
<p>Once you have a good feel for the function lifetime elision rules, you'll start developing intuition for
when you need to name your lifetimes instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-a-feel-for-variance-references-and-reborrows"><a class="header" href="#get-a-feel-for-variance-references-and-reborrows">Get a feel for variance, references, and reborrows</a></h1>
<p><a href="https://doc.rust-lang.org/reference/subtyping.html">Here's some official docs on the topic of variance,</a>
but reading it may make you go cross-eyed.   As an alternative, in this section I attempt to introduce some basic
rules about how references work with regard to lifetimes over the course of a few layers.</p>
<p>If it still makes you cross-eyed, just skim or skip ahead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-seed-of-a-mental-model"><a class="header" href="#the-seed-of-a-mental-model">The seed of a mental model</a></h1>
<p>Some find it helpful to think of shared (<code>&amp;T</code>) and exclusive (<code>&amp;mut T</code>) references like so:</p>
<ul>
<li><code>&amp;T</code> is a compiler-checked <code>RwLockReadGuard</code>
<ul>
<li>You can have as many of these at one time as you want</li>
</ul>
</li>
<li><code>&amp;mut T</code> is a compiler-checked <code>RwLockWriteGuard</code>
<ul>
<li>You can only have one of these at one time, and when you do, you can have no <code>RwLockReadGuard</code></li>
</ul>
</li>
</ul>
<p>The exclusivity is key.</p>
<p><code>&amp;mut T</code> are often called "mutable references" for obvious reasons.  And following from that, <code>&amp;T</code>
are often called "immutable references".  However, I find it more accurate and consistent to call
<code>&amp;mut T</code> an exclusive reference and to call <code>&amp;T</code> a shared reference.</p>
<p>This guide doesn't yet cover shared mutability, more commonly called interior mutability, but you'll
run into the concept sometime in your Rust journey.  The one thing I will mention here is that it
enables mutation behind a <code>&amp;T</code>, and thus "immutable reference" is a misleading name.</p>
<p>There are other situations where the important quality of a <code>&amp;mut T</code> is the exclusivity that it
guarantees, and not the ability to mutate through it.  If you find yourself annoyed at getting
borrow errors about <code>&amp;mut T</code> when you performed no actual mutation, it may help to instead
consider <code>&amp;mut T</code> as a directive to the compiler to ensure <em>exclusive</em> access instead of
<em>mutable</em> access.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-types"><a class="header" href="#reference-types">Reference types</a></h1>
<p>Let's open with a question: is <code>&amp;str</code> a type?</p>
<p>When not being pedantic or formal, pretty much everyone will say yes, <code>&amp;str</code> is a type.
However, it is technically a <em>type constructor</em> which is parameterized with a generic
lifetime parameter.  So <code>&amp;str</code> isn't technically a type, <code>&amp;'a str</code> for some concrete
lifetime is a type.  <code>&amp;'a str</code> and <code>&amp;'b str</code> are not the same type, unless <code>'a == 'b</code>.</p>
<p>Similarly, <code>Vec&lt;T&gt;</code> for a generic <code>T</code> is a type constructor, but <code>Vec&lt;i32&gt;</code> is a type.
<code>Vec&lt;T&gt;</code> and <code>Vec&lt;U&gt;</code> are not the same type, unless <code>T == U</code>.</p>
<p>By "concrete lifetime", I mean some compile-time determined lifetime.  The exact
definition of "lifetime" is surprisingly complicated and beyond the scope of this
guide, but here are a few examples of <code>&amp;str</code>s and their concrete types.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The exact lifetime of `'a` is determined at each call site.  We'll explore
// what this means in more depth later.
//
// The lifetime of `b` works the same, we just didn't give it a name.
fn example&lt;'a&gt;(a: &amp;'a str, b: &amp;str) {
    // Literal strings are `&amp;'static str`
    let s = "literal";

    // The lifetime of local borrows are determined by compiler analysis
    // and have no names (but it's still a single lifetime).
    let local = String::new();
    let borrow = local.as_str();

    // These are the same and they just tell the compiler to infer the
    // lifetime.  In this small example that means the same thing as not
    // having a type annotation at all.
    let borrow: &amp;str = local.as_str();
    let borrow: &amp;'_ str = local.as_str();
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetime-bounds"><a class="header" href="#lifetime-bounds">Lifetime bounds</a></h1>
<p>Here's a brief introduction to the lifetime bounds you may see on <code>fn</code> declarations and <code>impl</code> blocks.</p>
<h2 id="bounds-between-lifetimes"><a class="header" href="#bounds-between-lifetimes">Bounds between lifetimes</a></h2>
<p>A <code>'a: 'b</code> bound means, roughly speaking, <code>'long: 'short</code>.
It's often read as "<code>'a</code> outlives <code>'b</code>" and it sometimes called an "outlives bound" or "outlives relation".</p>
<p>I personally also like to read it as "<code>'a</code> is valid for (at least) <code>'b</code>".</p>
<p>Note that <code>'a</code> may be the same as <code>'b</code>, it does not have to be strictly longer despite the "outlives"
terminology.  It is analogous to <code>&gt;=</code> in this respect.  Therefore, in this example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example&lt;'a: 'b, 'b: 'a&gt;(a: &amp;'a str, b: &amp;'b str) {}
<span class="boring">}</span></code></pre></pre>
<p><code>'a</code> and <code>'b</code> must actually be the same lifetime.</p>
<p>When you have a function argument with a nested reference such as <code>&amp;'b Foo&lt;'a&gt;</code>, a <code>'a: 'b</code> bound is inferred.</p>
<h2 id="bounds-between-generic-types-and-lifetimes"><a class="header" href="#bounds-between-generic-types-and-lifetimes">Bounds between (generic) types and lifetimes</a></h2>
<p>A <code>T: 'a</code> means that a <code>&amp;'a T</code> would not be instantly undefined behavior.  In other words, it
means that if the type <code>T</code> contains any references or other lifetimes, they must be at least
as long as <code>'a</code>.</p>
<p>You can also read these as "(the type) <code>T</code> is valid for <code>'a</code>".</p>
<p>Note that this has nothing to do with the liveness scope or drop scope of a <em>value</em> of type <code>T</code>!
In particular the most common bound of this form is <code>T: 'static</code>.</p>
<p>This does not mean the value of type <code>T</code> must last for your entire program!  It just means that
the type <code>T</code> has no non-<code>'static</code> lifetimes.  <code>String: 'static</code> for example, but this doesn't
mean that you don't drop <code>String</code>s.</p>
<h2 id="liveness-scopes-of-values"><a class="header" href="#liveness-scopes-of-values">Liveness scopes of values</a></h2>
<p>For the above reasons, I prefer to never refer to the liveness or drop scope of a value as
the value's "lifetime".  Although there is a connection between the liveness scope of values
and lifetimes of references you take to it, conflating the two concepts can lead to confusion.</p>
<p>That said, not everyone follows this convention, so you may see the liveness scope of a value
referred to as the values "lifetime".  So the distinction is something to just generally be
aware of.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-lifetimes"><a class="header" href="#reference-lifetimes">Reference lifetimes</a></h1>
<p>Here's something you'll utilize in Rust all the time without thinking about it:</p>
<ul>
<li>A <code>&amp;'long T</code> coerces to a <code>&amp;'short T</code></li>
<li>A <code>&amp;'long mut T</code> coerces to a <code>&amp;'short mut T</code></li>
</ul>
<p>The technical term is "covariant (in the lifetime)" but a practical mental model is "the (outer) lifetime of references can shrink".</p>
<p>The property holds for values whose type is a reference, but it doesn't always hold for other types.
For example, we'll soon see that this property doesn't always hold for the lifetime of a reference
nested within another reference.  When the property doesn't hold, it's usually due to <em>invariance</em>.</p>
<p>Even if you never really think about covariance, you'll grow an intuition for it -- so much for so
that you'll eventually be surprised when you encounter invariance and the property doesn't hold.
We'll look at some cases soon.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copy-and-reborrows"><a class="header" href="#copy-and-reborrows">Copy and reborrows</a></h1>
<p>Shared references (<code>&amp;T</code>) implement <code>Copy</code>, which makes them very flexible. Once you have one,
you can have as many as you want; once you've exposed one, you can't keep track of how many there are.</p>
<p>Exclusive references (<code>&amp;mut T</code>) do not implement <code>Copy</code>.
Instead, you can use them ergonomically through a mechanism called <em>reborrowing</em>. For example here:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'v&gt;(v: &amp;'v mut Vec&lt;i32&gt;) {
    v.push(0);         // line 1
    println!("{v:?}"); // line 2
}
<span class="boring">}</span></code></pre></pre>
<p>You're not moving <code>v: &amp;mut Vec&lt;i32&gt;</code> when you pass it to <code>push</code> on line 1, or you couldn't print it on line 2.
But you're not copying it either, because <code>&amp;mut _</code> does not implement <code>Copy</code>.
Instead <code>*v</code> is reborrowed for some shorter lifetime than <code>'v</code>, which ends on line 1.</p>
<p>An explicit reborrow would look like this:</p>
<pre><pre class="playground"><code class="language-rust no_compile edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    Vec::push(&amp;mut *v, 0);
<span class="boring">}</span></code></pre></pre>
<p><code>v</code> can't be used while the reborrow <code>&amp;mut *v</code> exists, but after it "expires", you can use <code>v</code> again.
In this way, both <code>&amp;mut</code> are still <em>exclusive</em> borrows.</p>
<p>Though tragically underdocumented, reborrowing is what makes <code>&amp;mut</code> usable; there's a lot of implicit reborrowing in Rust.
Reborrowing makes <code>&amp;mut T</code> act like the <code>Copy</code>-able <code>&amp;T</code> in some ways. But the necessity that <code>&amp;mut T</code> is exclusive while
it exists leads to it being much less flexible.</p>
<p>Reborrowing is a large topic on its own, but you should at least understand that it exists, and is what enables Rust to
be usable and ergonomic while still enforcing memory safety.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nested-borrows-and-invariance"><a class="header" href="#nested-borrows-and-invariance">Nested borrows and invariance</a></h1>
<p>Now let's consider nested references:</p>
<ul>
<li>A <code>&amp;'medium &amp;'long U</code> coerces to a <code>&amp;'short &amp;'short U</code></li>
<li>A <code>&amp;'medium mut &amp;'long mut U</code> coerces to a <code>&amp;'short mut &amp;'long mut U</code>...
<ul>
<li>...but <em>not</em> to a <code>&amp;'short mut &amp;'short mut U</code></li>
</ul>
</li>
</ul>
<p>We say that <code>&amp;mut T</code> is <em>invariant</em> in <code>T</code>, which means any lifetimes in <code>T</code> cannot change
(grow or shrink) at all. In the example, <code>T</code> is <code>&amp;'long mut U</code>, and the <code>'long</code> cannot be changed.</p>
<p>Why not?  Consider this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bar(v: &amp;mut Vec&lt;&amp;'static str&gt;) {
    let w: &amp;mut Vec&lt;&amp;'_ str&gt; = v; // call the lifetime 'w
    let local = "Gottem".to_string();
    w.push(&amp;*local);
} // `local` drops
<span class="boring">}</span></code></pre></pre>
<p>If <code>'w</code> was allowed to be shorter than <code>'static</code>, we'd end up with a dangling reference in <code>*v</code> after <code>bar</code> returns.</p>
<p>You will inevitably end up with a feel for covariance from using references with their flexible outer lifetimes,
but eventually hit a use case where invariance matters and causes some borrow check errors, because it's (necessarily) so much less flexible.
It's just part of the Rust learning experience.</p>
<hr />
<p>Let's look at one more property of nested references you may run into:</p>
<ul>
<li>You can get a <code>&amp;'long U</code> from a <code>&amp;'short &amp;'long U</code>:
<ul>
<li>Just copy it out!</li>
</ul>
</li>
<li>But you cannot get a <code>&amp;'long mut U</code> through dereferencing a <code>&amp;'short mut &amp;'long mut U</code>.
<ul>
<li>You can only reborrow a <code>&amp;'short mut U</code>.</li>
<li>Obtaining a <code>&amp;'long mut U</code> is sometimes possible by swapping or
temporarily moving out of the inner reference, for example with <a href="https://doc.rust-lang.org/stable/std/mem/fn.swap.html"><code>mem::swap</code></a>,
<a href="https://doc.rust-lang.org/stable/std/mem/fn.replace.html"><code>mem::replace</code></a>,
or <a href="https://docs.rs/replace_with/"><code>replace_with</code></a>. See the <a href="./lt-ex-mut-slice.html">mutable slice iterator example</a>.</li>
</ul>
</li>
</ul>
<p>The reason is again to prevent memory unsafety.</p>
<p>Additionally,</p>
<ul>
<li>You cannot get a <code>&amp;'long U</code> or <em>any</em> <code>&amp;mut U</code> from a <code>&amp;'short &amp;'long mut U</code>
<ul>
<li>You can only reborrow a <code>&amp;'short U</code></li>
</ul>
</li>
</ul>
<p>Recall that once a shared reference exist, any number of copies of it could
simultaneously exist.  Therefore, so long as the outer shared reference exists
(and could be used to observe <code>U</code>), the inner <code>&amp;mut</code> must not be usable in a
mutable or otherwise exclusive fashion.</p>
<p>And once the outer reference expires, the inner <code>&amp;mut</code> is active and must
again be exclusive, so it must not be possible to obtain a <code>&amp;'long U</code> either.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="invariance-elsewhere"><a class="header" href="#invariance-elsewhere">Invariance elsewhere</a></h1>
<p>While behind a <code>&amp;mut</code> is the most common place to first encounter invariance,
it's present elsewhere as well.</p>
<p><code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> are also invariant in <code>T</code>.</p>
<p>Trait parameters are invariant too.  As a result, lifetime-parameterized traits can be onerous to work with.</p>
<p>Additionally, if you have a bound like <code>T: Trait&lt;U&gt;</code>, <code>U</code> becomes invariant because it's a type parameter of the trait.
If your <code>U</code> resolves to <code>&amp;'x V</code>, the lifetime <code>'x</code> will be invariant too.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-references"><a class="header" href="#non-references">Non-references</a></h1>
<p>The variance of lifetime and type parameters of your own <code>struct</code>s is automatically
inferred from how you use those parameters in your field.  For example if you have a</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AllMine&lt;'a, T&gt;(&amp;'a mut T);
<span class="boring">}</span></code></pre></pre>
<p>Then <code>AllMine</code> is covariant in <code>'a</code> and invariant in <code>T</code>, just like <code>&amp;'a mut T</code> is.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-a-feel-for-borrow-returning-methods"><a class="header" href="#get-a-feel-for-borrow-returning-methods">Get a feel for borrow-returning methods</a></h1>
<p>Here we look at how borrow-returning methods work.  Our examples will consider a typical
pattern:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn method(&amp;mut self) -&gt; &amp;SomeReturnType {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="when-not-to-name-lifetimes"><a class="header" href="#when-not-to-name-lifetimes">When not to name lifetimes</a></h1>
<p>Sometimes newcomers try to solve borrow check errors by making things more generic,
which often involves adding lifetimes and naming previously-elided lifetimes:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct S; impl S {
</span>fn quz&lt;'a: 'b, 'b&gt;(&amp;'a mut self) -&gt; &amp;'b str { todo!() }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>But this doesn't actually permit more lifetimes than this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct S; impl S {
</span>fn quz&lt;'b&gt;(&amp;'b mut self) -&gt; &amp;'b str { todo!() }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Because in the first example, <code>&amp;'a mut self</code> can coerce to <code>&amp;'b mut self</code>.
And, in fact, you want it to -- because you generally don't want to exclusively borrow <code>self</code> any longer than necessary.</p>
<p>And at this point you can instead utilize lifetime elision and stick with:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct S; impl S {
</span>fn quz(&amp;mut self) -&gt; &amp;str { todo!() }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>As covariance and function lifetime elision become more intuitive, you'll build a feel for when it's
pointless to name lifetimes.  Adding superfluous lifetimes like in the first example tends to make
understanding borrow errors harder, not easier.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bound-related-lifetimes-infect-each-other"><a class="header" href="#bound-related-lifetimes-infect-each-other">Bound-related lifetimes "infect" each other</a></h1>
<p>Separating <code>'a</code> and <code>'b</code> in the last section didn't make things any more flexible in terms of <code>self</code> being borrowed.
Once you declare a bound like <code>'a: 'b</code>, then the two lifetimes "infect" each other.
Even though the return type had a different lifetime than the input, it was still effectively a reborrow of the input.</p>
<p>This can actually happen between two input parameters too: if you've stated a lifetime relationship between two borrows,
the compiler assumes they can observe each other in some sense.  It's probably not anything you'll run into soon,
but if you do, the compiler errors tend to be drop errors ("borrow might be used here, when <code>x</code> is dropped"), or
sometimes read like "data flows from X into Y".</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mut-inputs-dont-downgrade-to"><a class="header" href="#mut-inputs-dont-downgrade-to">&amp;mut inputs don't "downgrade" to &amp;</a></h1>
<p>Still talking about this signature:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn quz(&amp;mut self) -&gt; &amp;str { todo!() }
<span class="boring">}</span></code></pre></pre>
<p>Newcomers often expect <code>self</code> to only be shared-borrowed after <code>quz</code> returns, because the return is a shared reference.
But that's not how things work; <code>self</code> remains <em>exclusively</em> borrowed for as long as the returned <code>&amp;str</code> is valid.</p>
<p>I find looking at the exact return type a trap when trying to build a mental model for this pattern.
The fact that the lifetimes are connected is crucial, but beyond that, instead focus on the input parameter:
You <em>cannot call</em> the method <em>until you have created</em> a <code>&amp;mut self</code> with a lifetime as long as the return type has.
Once that exclusive borrow (or reborrow) is created, the exclusiveness lasts for the entirety of the lifetime.
Moreover, you give the <code>&amp;mut self</code> away by calling the method (it is not <code>Copy</code>), so you can't create any other
reborrows to <code>self</code> other than through whatever the method returns to you (in this case, the <code>&amp;str</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-and-returning-impl-trait"><a class="header" href="#async-and-returning-impl-trait"><code>async</code> and returning <code>impl Trait</code></a></h1>
<p>The return type of an <code>async</code> function captures all of its generic parameters,
including any lifetimes.  So here:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn example(v: &amp;mut Vec&lt;String&gt;) -&gt; String {
    "Hi :-)".to_string()
}
<span class="boring">}</span></code></pre></pre>
<p>The future returned by the <code>async fn</code> implicitly reborrows the <code>v</code> input, and
"carries" the same lifetime, just like the other examples we saw.</p>
<p>The same is true when you use <code>return</code>-position <code>impl Trait</code> (RPIT) in traits (RPITIT):</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyStruct {}
</span>trait StringIter {
    fn iter(&amp;self) -&gt; impl Iterator&lt;Item = String&gt;;
}

impl StringIter for MyStruct {
    fn iter(&amp;self) -&gt; impl Iterator&lt;Item = String&gt; {
        ["Hi :-)"].into_iter().map(ToString::to_string)
    }
}

// Fails to compile as `iter` borrows `my`
fn example(my: MyStruct) {
    let iter = my.iter();
    let _move_my = my;
    for _ in iter {}
}
<span class="boring">}</span></code></pre></pre>
<p><code>self</code> will remained borrowed here for as long as the iterator is alive.  Note that
this is true even if it's not required by the body!  The implicit lifetime capture
is considered part of the API contract.</p>
<p>For both of these cases, all generic <em>types</em> are also captured.</p>
<hr />
<p>Not that RPIT <em>outside</em> of traits does <em>not</em> implicitly capture lifetimes!  At least,
not as of this writing -- the plan is that RPIT outside of traits will act like RPITIT
and implicitly capture all lifetimes in edition 2024 and beyond.  But for now, they
only implicitly capture type parameters.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span>// Required: edition 2021 or before
fn no_capture(s: &amp;str) -&gt; impl Display {
    s.to_string()
}

// This wouldn't compile if `no_capture` reborrowed `*s`
fn check() {
    let mut s = "before".to_string();
    let d = no_capture(&amp;s);
    s ="after".to_string();
    println!("{d}");
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span>// This fails on edition 2021 or before, because it tries to
// return a reborrow of `*s`, but that requires capturing the lifetime
fn no_capture(s: &amp;str) -&gt; impl Display {
    s
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span>// This allows it to work again (but `+ '_` is too restrictive
// for every situation, which is part of why edition 2021 will
// change the behavior of RPIT outside of traits)
//
//                                     vvvv
fn no_capture(s: &amp;str) -&gt; impl Display + '_ {
    s
}
<span class="boring">}</span></code></pre></pre>
<hr />
<p>A lot can be said about <code>async</code> and RPITs; more than can be covered here.  But their
implicit capturing nature is something to be aware of, given how invisible it is.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understand-function-lifetime-parameters"><a class="header" href="#understand-function-lifetime-parameters">Understand function lifetime parameters</a></h1>
<p>First, note that elided lifetimes in function signatures are invisible lifetime parameters on the function.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn zed(s: &amp;str) {}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// same thing
fn zed&lt;'s&gt;(s: &amp;'s str) {}
<span class="boring">}</span></code></pre></pre>
<p>When you have a lifetime parameter like this, the <em>caller</em> chooses the lifetime.
But the body of your function is opaque to the caller: they can only choose lifetimes <em>just longer</em> than your function body.</p>
<p>So when you have a lifetime parameter on your function (without any further bounds), the only things you know are</p>
<ul>
<li>It's longer than your function body</li>
<li>You don't get to pick it, and it could be arbitrarily long (even <code>'static</code>)</li>
<li>But it could be <em>just barely longer</em> than your function body too; you have to support both cases</li>
</ul>
<p>And the main corollaries are</p>
<ul>
<li>You can't borrow locals for a caller-chosen lifetime</li>
<li>You can't extend a caller-chosen lifetime to some other named lifetime in scope
<ul>
<li>Unless there's some other outlives bound that makes it possible</li>
</ul>
</li>
</ul>
<hr />
<p>Here's a couple of error examples related to function lifetime parameters:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn long_borrowing_local&lt;'a&gt;(name: &amp;'a str) {
    let local = String::new();
    let borrow: &amp;'a str = &amp;local;
}

fn borrowing_zed(name: &amp;str) -&gt; &amp;str {
    match name.len() {
        0 =&gt; "Hello, stranger!",
        _ =&gt; &amp;format!("Hello, {name}!"),
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understand-borrows-within-a-function"><a class="header" href="#understand-borrows-within-a-function">Understand borrows within a function</a></h1>
<p>The analysis that the compiler does to determine lifetimes and borrow check
<em>within</em> a function body is quite complicated.  A full exploration is beyond
the scope of this guide, but we'll give a brief introduction here.</p>
<p>Your best bet if you run into an error you can't understand is to
ask for help on the forum or elsewhere.</p>
<h2 id="borrow-errors-within-a-function"><a class="header" href="#borrow-errors-within-a-function">Borrow errors within a function</a></h2>
<p>Here are some simple causes of borrow check errors within a function.</p>
<h3 id="recalling-the-basics"><a class="header" href="#recalling-the-basics">Recalling the Basics</a></h3>
<p>The most basic mechanism to keep in mind is that <code>&amp;mut</code> references are exclusive,
while <code>&amp;</code> references are shared and implement <code>Copy</code>.  You can't intermix using
a shared reference and an exclusive reference to the same value, or two exclusive
references to the same value.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let mut local = "Hello".to_string();

// Creating and using a shared reference
let x = &amp;local;
println!("{x}");

// Creating and using an exclusive reference
let y = &amp;mut local;
y.push_str(", world!");

// Trying to use the shared reference again
println!("{x}");
<span class="boring">}</span></code></pre></pre>
<p>This doesn't compile because as soon as you created the exclusive reference,
any other existing references must cease to be valid.</p>
<h3 id="borrows-are-often-implicit"><a class="header" href="#borrows-are-often-implicit">Borrows are often implicit</a></h3>
<p>Here's the example again, only slightly rewritten.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let mut local = "Hello".to_string();

// Creating and using a shared reference
let x = &amp;local;
println!("{x}");

// Implicitly creating and using an exclusive reference
local.push_str(", world!");

// Trying to use the shared reference again
println!("{x}");
<span class="boring">}</span></code></pre></pre>
<p>Here, <a href="https://doc.rust-lang.org/std/string/struct.String.html#method.push_str"><code>push_str</code> takes <code>&amp;mut self</code>,</a>
so an implicit <code>&amp;mut local</code> exists as part of the method call,
and thus the example can still not compile.</p>
<h3 id="creating-a-mut-is-not-the-only-exclusive-use"><a class="header" href="#creating-a-mut-is-not-the-only-exclusive-use">Creating a <code>&amp;mut</code> is not the only exclusive use</a></h3>
<p>The borrow checker looks at <em>every</em> use of a value to see if it's
compatible with the lifetimes of borrows to that value, not
just uses that involve references or just uses that involve lifetimes.</p>
<p>For example, moving a value invalidates any references to the
value, as otherwise those references would dangle.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let local = "Hello".to_string();

// Creating and using a shared reference
let x = &amp;local;
println!("{x}");

// Moving the value
let _local = local;

// Trying to use the shared reference again
println!("{x}");
<span class="boring">}</span></code></pre></pre>
<h3 id="referenced-values-must-remain-in-scope"><a class="header" href="#referenced-values-must-remain-in-scope">Referenced values must remain in scope</a></h3>
<p>The effects of a value going out of scope are similar to moving the
value: all references are invalidated.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let x;
{
    let local = "Hello".to_string();
    x = &amp;local;
} // `local` goes out of scope here

// Trying to use the shared reference after `local` goes out of scope
println!("{x}");
<span class="boring">}</span></code></pre></pre>
<h3 id="using-mut-self-or-self-counts-as-a-use-of-all-fields"><a class="header" href="#using-mut-self-or-self-counts-as-a-use-of-all-fields">Using <code>&amp;mut self</code> or <code>&amp;self</code> counts as a use of all fields</a></h3>
<p>In the example below, <code>left</code> becomes invalid when we create <code>&amp;self</code>
to call <code>bar</code>.  Because you can get a <code>&amp;self.left</code> out of a <code>&amp;self</code>,
this is similar to trying to intermix <code>&amp;mut self.left</code> and <code>&amp;self.left</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Pair {
    left: String,
    right: String,
}

impl Pair {
    fn foo(&amp;mut self) {
        let left = &amp;mut self.left;
        left.push_str("hi");
        self.bar();
        println!("{left}");
    }
    fn bar(&amp;self) {
        println!("{self:?}");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>More generally, creating a <code>&amp;mut x</code> or <code>&amp;x</code> counts as a use of
everything reachable from <code>x</code>.</p>
<h2 id="some-things-that-compile-successfully"><a class="header" href="#some-things-that-compile-successfully">Some things that compile successfully</a></h2>
<p>Once you've started to get the hang of borrow errors, you might start to
wonder why certain programs are <em>allowed</em> to compile.  Here we introduce
some of the ways that Rust allows non-trivial borrowing while still being
sound.</p>
<h3 id="independently-borrowing-fields"><a class="header" href="#independently-borrowing-fields">Independently borrowing fields</a></h3>
<p>Rust tracks borrows of struct fields individually, so the borrows of
<code>left</code> and <code>right</code> below do not conflict.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Pair {
</span><span class="boring">    left: String,
</span><span class="boring">    right: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Pair {
    fn foo(&amp;mut self) {
        let left = &amp;mut self.left;
        let right = &amp;mut self.right;
        left.push_str("hi");
        right.push_str("there");
        println!("{left} {right}");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This capability is also called <a href="https://doc.rust-lang.org/nomicon/borrow-splitting.html">splitting borrows.</a></p>
<p>Note that data you access through indexing are not consider fields
per se; instead indexing is <a href="https://doc.rust-lang.org/std/ops/trait.Index.html">an operation that generally borrows
all of <code>&amp;self</code> or <code>&amp;mut self</code>.</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let mut v = vec![0, 1, 2];

// These two do not overlap, but...
let left = &amp;mut v[..1];
let right = &amp;mut v[1..];

// ...the borrow checker cannot recognize that
println!("{left:?} {right:?}");
<span class="boring">}</span></code></pre></pre>
<p>Usually in this case, one uses methods like <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_at_mut"><code>split_at_mut</code></a>
in order to split the borrows instead.</p>
<p>Similarly to indexing, when you access something through "deref coercion", you're
exercising <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">the <code>Deref</code> trait</a>
(or <code>DerefMut</code>), which borrow all of <code>self</code>.</p>
<p>There are also some niche cases where the borrow checker is smarter, however.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>// Pattern matching does understand non-overlapping slices (slices are special)
let mut v = vec![String::new(), String::new()];
let slice = &amp;mut v[..];
if let [_left, right] = slice {
    if let [left, ..] = slice {
        left.push_str("left");
    }
    // Still usable!
    right.push_str("right");
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>// You can split borrows through a `Box` dereference (`Box` is special)
let mut bx = Box::new((0, 1));
let left = &amp;mut bx.0;
let right = &amp;mut bx.1;
*left += 1;
*right += 1;
<span class="boring">}</span></code></pre></pre>
<p>The examples are non-exhaustive 🙂.</p>
<h3 id="reborrowing"><a class="header" href="#reborrowing">Reborrowing</a></h3>
<p><a href="./st-reborrow.html">As mentioned before,</a> reborrows are what make <code>&amp;mut</code> reasonable to use.
In fact, they have other special properties you can't emulate with a custom struct and
trait implementations.  Consider this example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(s: &amp;mut String) -&gt; &amp;str {
    &amp;**s
}
<span class="boring">}</span></code></pre></pre>
<p>Actually, that's too fast.  Let's change this a little bit and go step by step.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(s: &amp;mut String) -&gt; &amp;str {
    let ms: &amp;mut str = &amp;mut **s;
    let rs: &amp;str = &amp;*s;
    rs
}
<span class="boring">}</span></code></pre></pre>
<p>Here, both <code>s</code> and <code>ms</code> are going out of scope at the end of <code>foo</code>, but this doesn't
invalidate <code>rs</code>.  That is, reborrowing through references can impose lifetime constraints
on the reborrow, but the reborrow is not dependent on references staying in scope!  It is
only dependent on the borrowed data.</p>
<p>This demonstrates that reborrowing is more powerful than nesting references.</p>
<h3 id="shared-reborrowing"><a class="header" href="#shared-reborrowing">Shared reborrowing</a></h3>
<p>When it comes to detecting conflicts, the borrow checker distinguishes between shared
reborrows and exclusive ones.  In particular, creating a shared reborrow will invalidate
any exclusive reborrows of the same value (as they are no longer exclusive).  But it will
not invalidated shared reborrows:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Pair {
    left: String,
    right: String,
}

impl Pair {
    fn foo(&amp;mut self) {
        // a split borrow: exclusive reborrow, shared reborrow
        let left = &amp;mut self.left;
        let right = &amp;self.right;
        left.push('x');

        // Shared reborrow of all of `self`, which "covers" all fields
        let this = &amp;*self;

        // It invalidates any exclusive reborrows, so this will fail...
        // println!("{left}");

        // But it does not invalidate shared reborrows!
        println!("{right}");
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="two-phase-borrows"><a class="header" href="#two-phase-borrows">Two-phase borrows</a></h3>
<p>The following code compiles:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let mut v = vec![0];
let shared = &amp;v;
v.push(shared.len());
<span class="boring">}</span></code></pre></pre>
<p>However, if you're aware of the order of evaluation here, it probably seems like it shouldn't.
The implicit <code>&amp;mut v</code> should have invalidated <code>shared</code> before <code>shared.len()</code> was evaluated.
What gives?</p>
<p>This is the result of a feature called two-phase borrows, which is intended to make
<a href="https://rust-lang.github.io/rfcs/2025-nested-method-calls.html">nested method calls</a>
more ergonomic:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let mut v = vec![0];
v.push(v.len());
<span class="boring">}</span></code></pre></pre>
<p><a href="https://rust.godbolt.org/z/966j4Eh1f">In the olden days,</a> you would have had to write it like so:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let mut v = vec![0];
let len = v.len();
v.push(len);
<span class="boring">}</span></code></pre></pre>
<p>The implementation slipped, which is why the first example compiles too.  How far it slipped
is hard to say, as not only is there <a href="https://github.com/rust-lang/rust/issues/46901">no specification,</a>
the feature doesn't even seem to be documented 🤷.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learn-some-pitfalls-and-anti-patterns"><a class="header" href="#learn-some-pitfalls-and-anti-patterns">Learn some pitfalls and anti-patterns</a></h1>
<p>Here we cover some pitfalls to recognize and anti-patterns to avoid.</p>
<p>First, <a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md">read this list of common lifetime misconceptions</a> by @pretzelhammer.
Skip or skim the parts that don't make sense to you yet, and return to it for a re-read occasionally.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn-trait-lifetimes-and-boxdyn-trait"><a class="header" href="#dyn-trait-lifetimes-and-boxdyn-trait"><code>dyn Trait</code> lifetimes and <code>Box&lt;dyn Trait&gt;</code></a></h1>
<p>Every trait object (<code>dyn Trait</code>) has an elide-able lifetime with it's own defaults when completely elided.
This default is stronger than the normal function signature elision rules.
The most common way to run into a lifetime error about this is with <code>Box&lt;dyn Trait&gt;</code> in your function signatures, structs, and type aliases, where it means <code>Box&lt;dyn Trait + 'static&gt;</code>.</p>
<p>Often the error indicates that non-<code>'static</code> references/types aren't allowed in that context,
but sometimes it means that you should add an explicit lifetime, like <code>Box&lt;dyn Trait + 'a&gt;</code> or <code>Box&lt;dyn Trait + '_&gt;</code>.</p>
<p>The latter will act like "normal" lifetime elision; for example, it will introduce a new anonymous lifetime
parameter as a function input parameter, or use the <code>&amp;self</code> lifetime in return position.</p>
<p>The reason the lifetime exists is that coercing values to <code>dyn Trait</code> erases their base type, including any
lifetimes that it may contain.  But those lifetimes have to be tracked by the compiler somehow to ensure
memory safety.  The <code>dyn Trait</code> lifetime represents the maximum lifetime the erased type is valid for.</p>
<hr />
<p>Some short examples:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}

// The return is `Box&lt;dyn Trait + 'static&gt;` and this errors as there
// needs to be a bound requiring `T` to be `'static`, or the return
// type needs to be more flexible
fn one&lt;T: Trait&gt;(t: T) -&gt; Box&lt;dyn Trait&gt; {
    Box::new(t)
}

// This works as we've added the bound
fn two&lt;T: Trait + 'static&gt;(t: T) -&gt; Box&lt;dyn Trait&gt; {
    Box::new(t)
}

// This works as we've made the return type more flexible.  We still
// have to add a lifetime bound.
fn three&lt;'a, T: Trait + 'a&gt;(t: T) -&gt; Box&lt;dyn Trait + 'a&gt; {
    Box::new(t)
}
<span class="boring">}</span></code></pre></pre>
<p>For a more in-depth exploration,
<a href="./dyn-elision.html">see this section of the <code>dyn Trait</code> tour.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conditional-return-of-a-borrow"><a class="header" href="#conditional-return-of-a-borrow">Conditional return of a borrow</a></h1>
<p>The compiler isn't perfect, and there are some things it doesn't yet accept which are in fact sound and could be accepted.
Perhaps the most common one to trip on is <a href="https://github.com/rust-lang/rust/issues/51545">conditional return of a borrow,</a> aka NLL Problem Case #3.
There are some examples and workarounds in the issue and related issues.</p>
<p>The plan is still to accept that pattern some day.</p>
<p>More generally, if you run into something and don't understand why it's an error or think it should be allowed, try asking in a forum post.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrowing-something-forever"><a class="header" href="#borrowing-something-forever">Borrowing something forever</a></h1>
<p>An anti-pattern you may run into is to create a <code>&amp;'a mut Thing&lt;'a&gt;</code>.  It's an anti-pattern because it translates
into "take an exclusive reference of <code>Thing&lt;'a&gt;</code> for the entire rest of it's validity (<code>'a</code>)".  Once you create
the exclusive borrow, you cannot use the <code>Thing&lt;'a&gt;</code> ever again, except via that borrow.</p>
<p>You can't call methods on it, you can't take another reference to it, you can't move it, you can't print it, you
can't use it at all.  You can't even call a non-trivial destructor on it; if you have a non-trivial destructor,
your code won't compile in the presence of <code>&amp;'a mut Thing&lt;'a&gt;</code>.</p>
<p>So avoid <code>&amp;'a mut Thing&lt;'a&gt;</code>.</p>
<hr />
<p>Examples:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Node&lt;'a&gt;(&amp;'a str);
fn example_1&lt;'a&gt;(node: &amp;'a mut Node&lt;'a&gt;) {}

struct DroppingNode&lt;'a&gt;(&amp;'a str);
impl Drop for DroppingNode&lt;'_&gt; { fn drop(&amp;mut self) {} }
fn example_2&lt;'a&gt;(node: &amp;'a mut DroppingNode&lt;'a&gt;) {}

fn main() {
    let local = String::new();

    let mut node_a = Node(&amp;local);
    // You can do this once and it's ok...
    example_1(&amp;mut node_a);

    let mut node_b = Node(&amp;local);
    // ...but then you can't use the node directly ever again
    example_1(&amp;mut node_b);
    println!("{node_b:?}");

    let mut node_c = DroppingNode(&amp;local);
    // And this doesn't work at all
    example_2(&amp;mut node_c);
}</code></pre></pre>
<p>We look at the shared version of this pattern (<code>&amp;'a Thing&lt;'a&gt;</code>) <a href="pf-shared-nested.html">a little later.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-mut-self-and-self-aliasing-more-generally"><a class="header" href="#a-mut-self-and-self-aliasing-more-generally"><code>&amp;'a mut self</code> and <code>Self</code> aliasing more generally</a></h1>
<p><code>fn foo(&amp;'a mut self)</code> is a red flag -- because if that <code>'a</code> wasn't declared on the function,
it's probably part of the <code>Self</code> struct.  And if that's the case, this is a <code>&amp;'a mut Thing&lt;'a&gt;</code>
in disguise.  <a href="./pf-borrow-forever.html">As discussed in the previous section,</a> this will make
<code>self</code> unusable afterwards, and thus is an anti-pattern.</p>
<p>More generally, <code>self</code> types and the <code>Self</code> alias include any parameters on the type constructor post-resolution.
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=a46b294ec613acda99767069a744c488">Which means here:</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Node&lt;'a&gt;(&amp;'a str);

impl&lt;'a&gt; Node&lt;'a&gt; {
    fn new(s: &amp;str) -&gt; Self {
        Node(s)
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Self</code> is an alias for <code>Node&lt;'a&gt;</code>.  It is <em>not</em> an alias for <code>Node&lt;'_&gt;</code>.  So it means:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn new&lt;'s&gt;(s: &amp;'s str) -&gt; Node&lt;'a&gt; {
<span class="boring">}</span></code></pre></pre>
<p>And not:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn new&lt;'s&gt;(s: &amp;'s str) -&gt; Node&lt;'s&gt; {
<span class="boring">}</span></code></pre></pre>
<p>And you really meant to code one of these:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn new(s: &amp;'a str) -&gt; Self {
    fn new(s: &amp;str) -&gt; Node&lt;'_&gt; {
<span class="boring">}</span></code></pre></pre>
<p>Similarly, using <code>Self</code> as a constructor will use the resolved type parameters.  So this won't work:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn new(s: &amp;str) -&gt; Node&lt;'_&gt; {
        Self(s)
    }
<span class="boring">}</span></code></pre></pre>
<p>You need</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn new(s: &amp;str) -&gt; Node&lt;'_&gt; {
        Node(s)
    }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="avoid-self-referential-structs"><a class="header" href="#avoid-self-referential-structs">Avoid self-referential structs</a></h1>
<p>By self-referential, I mean you have one field that is a reference, and that reference points to another field (or contents of a field) in the same struct.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Snek&lt;'a&gt; {
    owned: String,
    // Like if you want this to point to the `owned` field
    borrowed: &amp;'a str,
}
<span class="boring">}</span></code></pre></pre>
<p>The only safe way to construct this to be self-referential is to take a <code>&amp;'a mut Snek&lt;'a&gt;</code>, get a <code>&amp;'a str</code> to the <code>owned</code> field, and assign it to the <code>borrowed</code> field.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Snek&lt;'a&gt; {
</span><span class="boring">   owned: String,
</span><span class="boring">   // Like if you want this to point to the `owned` field
</span><span class="boring">   borrowed: &amp;'a str,
</span><span class="boring">}
</span>
impl&lt;'a&gt; Snek&lt;'a&gt; {
    fn bite(&amp;'a mut self) {
        self.borrowed = &amp;self.owned;
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="pf-borrow-forever.html">And as was covered before,</a> that's an anti-pattern because you cannot use the self-referential struct directly ever again.
The only way to use it at all is via a (reborrowed) return value from the method call that required <code>&amp;'a mut self</code>.</p>
<p>So it's technically possible, but so restrictive it's pretty much always useless.</p>
<p>Trying to create self-referential structs is a common newcomer misstep, and you may see the response to questions about them in the approximated form of "you can't do that in safe Rust".</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-structa-and-covariance"><a class="header" href="#a-structa-and-covariance"><code>&amp;'a Struct&lt;'a&gt;</code> and covariance</a></h1>
<p>Here's a situation that looks similar to <a href="./pf-borrow-forever.html">borrowing something forever,</a>
but is actually somewhat different.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person&lt;'a&gt; {
    given: &amp;'a str,
    sur: &amp;'a str,
}

impl&lt;'a&gt; Person&lt;'a&gt; {
    //       vvvvvvvv `&amp;'a Person&lt;'a&gt;`
    fn given(&amp;'a self) -&gt; &amp;'a str {
        self.given
    }
}

fn example(person: Person&lt;'_&gt;) {
    // Unlike when we borrowed something forever, this compiles
    let _one = person.given();
    let _two = person.given();
}
<span class="boring">}</span></code></pre></pre>
<p>The difference is that <code>&amp;U</code> is covariant in <code>U</code>, so
<a href="./st-invariance.html">lifetimes can "shrink" behind the reference</a>
(unlike <code>&amp;mut U</code>, which is invariant in <code>U</code>).  <code>Person&lt;'a&gt;</code> is also
covariant in <code>'a</code>, because all of our uses of <code>'a</code> in the definition
are in covariant position.</p>
<p>What all this means is that <code>&amp;'long Person&lt;'long&gt;</code> can coerce to
a <code>&amp;'short Person&lt;'short&gt;</code>.  As a result, calling <code>Person::given</code>
doesn't have to borrow the <code>person</code> forever -- it only has to borrow
<code>person</code> for as long as the return value is used.</p>
<p>Note that the covariance is required!  A shared nested borrow where
the inner lifetime is invariant is still almost as bad as the
"borrowed forever" <code>&amp;mut</code> case.  Most of this page talks about the
covariant case; we'll consider the invariant case <a href="pf-shared-nested.html#the-invariant-case">at the end.</a></p>
<h2 id="this-is-still-a-yellow-flag"><a class="header" href="#this-is-still-a-yellow-flag">This is still a yellow flag</a></h2>
<p>Even though it's not as problematic as the <code>&amp;mut</code> case, there is
still something non-ideal about that signature: it forces the
borrow of <code>person</code> to be longer than it needs to be.  For example,
this fails:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person&lt;'a&gt; { given: &amp;'a str }
</span><span class="boring">impl&lt;'a&gt; Person&lt;'a&gt; { fn given(&amp;'a self) -&gt; &amp;'a str { self.given } }
</span><span class="boring">struct Stork(String);
</span><span class="boring">impl Stork { fn deliver(&amp;self, _: usize) -&gt; Person&lt;'_&gt; { Person { given: &amp;self.0 } } }
</span>fn example(stork: Stork) {
    let mut last = "";
    for i in 0..10 {
        let person = stork.deliver(i);
        last = person.given();
        // ...
    }
    println!("Last: {last}");
}
<span class="boring">}</span></code></pre></pre>
<p><code>person</code> has to remain borrowed for as long the return value is around,
because we said <code>&amp;self</code> and the returned <code>&amp;str</code> have to have the same
lifetime.</p>
<p>If we instead allow the lifetimes to be different:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person&lt;'a&gt; { given: &amp;'a str }
</span><span class="boring">struct Stork(String);
</span><span class="boring">impl Stork { fn deliver(&amp;self, _: usize) -&gt; Person&lt;'_&gt; { Person { given: &amp;self.0 } } }
</span>impl&lt;'a&gt; Person&lt;'a&gt; {
    //       vvvvv We removed `'a` from `&amp;self`
    fn given(&amp;self) -&gt; &amp;'a str {
        self.given
    }
}

fn example(stork: Stork) {
    let mut last = "";
    for i in 0..10 {
        let person = stork.deliver(i);
        last = person.given();
        // ...
    }
    println!("Last: {last}");
}
<span class="boring">}</span></code></pre></pre>
<p>Then the borrow of <code>person</code> can end immediately after the call, even
while the return value remains usable.  This is possible because we're
just copying the reference out.  Or if you prefer to think of it another
way, we're handing out a reborrow of an existing borrow we were holding
on to, and not borrowing something we owned ourselves.</p>
<p>So now the <code>stork</code> still has to be around for as long as <code>last</code> is used,
but the <code>person</code> can go away at the end of the loop.</p>
<p>Allowing the lifetimes to be different is normally what you want to do
when you have a struct that's just managing a borrowed resource in some
way -- when you hand out pieces of the borrowed resource, you want them
to be tied to the lifetime of the original borrow and not the lifetime of
<code>&amp;self</code> or <code>&amp;mut self</code> on the method call. <a href="https://doc.rust-lang.org/std/slice/struct.Iter.html#impl-Iterator-for-Iter%3C&#x27;a,+T%3E">It's how borrowing iterators
work,</a>
for example.</p>
<h2 id="a-variation-on-the-theme"><a class="header" href="#a-variation-on-the-theme">A variation on the theme</a></h2>
<p>Consider this version of the method:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person&lt;'a&gt; { given: &amp;'a str }
</span>impl&lt;'a&gt; Person&lt;'a&gt; {
    fn given(&amp;self) -&gt; &amp;str {
        self.given
   }
}
<span class="boring">}</span></code></pre></pre>
<p>It has the same downside as <code>given(&amp;'a self) -&gt; &amp;'a str</code>: The return
value is tied to <code>self</code> and not <code>'a</code>.  It's easy to make this mistake
when developing borrowing structs, because the lifetime elision rules
nudge you in this direction.  It's also harder to spot because there's
no <code>&amp;'a self</code> to clue you in.</p>
<h2 id="but-sometimes-its-perfectly-okay"><a class="header" href="#but-sometimes-its-perfectly-okay">But sometimes it's perfectly okay</a></h2>
<p>On the flip side, because of the covariance we discussed at the top of
this page, there's no practical difference between these two methods:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person&lt;'a&gt; { given: &amp;'a str }
</span>impl&lt;'a&gt; Person&lt;'a&gt; {
    fn foo(&amp;self) {}
    fn bar(&amp;'a self) {}
<span class="boring">}</span></code></pre></pre>
<p>There's no return value to force the lifetime to be longer, so these
methods are going to act the same.  There's no reason for the <code>'a</code>
on <code>&amp;'a self</code>, but it's not hurting anything either.</p>
<p>Similarly, within a struct there's rarely a benefit to keeping the
nested lifetimes separated, so you might as well use this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Cradle&lt;'a&gt; {
    person: &amp;'a Person&lt;'a&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>Instead of something with two lifetimes.</p>
<p>(That said, an even better approach is to not have complicated nested-borrow-holding data structures at all.)</p>
<h2 id="the-invariant-case"><a class="header" href="#the-invariant-case">The invariant case</a></h2>
<p>Finally, let's look at a case where it's generally not okay:
A shared nested borrow where the inner borrow is invariant.</p>
<p>Perhaps the most likely reason this comes up is due to <em>shared mutability:</em> the ability
to mutate things that are behind a shared reference (<code>&amp;</code>).  Some examples from the
standard library include <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell&lt;T&gt;</code></a>,
<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell&lt;T&gt;</code></a>, and
<a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex&lt;T&gt;</code></a>.  These
shared mutability types have to be invariant over their generic parameter <code>T</code>,
just like how <code>&amp;mut T</code> is invariant over <code>T</code>.</p>
<p>Let's see an example, <a href="./pf-meta.html">similar to one we've seen before</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::cell::Cell;
</span>#[derive(Debug)]
struct ShareableSnek&lt;'a&gt; {
   owned: String,
   borrowed: Cell&lt;&amp;'a str&gt;,
}

impl&lt;'a&gt; ShareableSnek&lt;'a&gt; {
    fn bite(&amp;'a self) {
        self.borrowed.set(&amp;self.owned);
    }
}

let snek = ShareableSnek {
    owned: "🐍".to_string(),
    borrowed: Cell::new(""),
};

snek.bite();

// Unlike the `&amp;mut` case, we can still use `snek`!  It's borrowed forever,
// but it's "only" *shared*-borrowed forever.
println!("{snek:?}");
<span class="boring">}</span></code></pre></pre>
<p>That doesn't seem so bad though, right?  Well, it's quite as bad as the <code>&amp;mut</code>
case, but it's still usually too restrictive to be useful.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct ShareableSnek&lt;'a&gt; {
</span><span class="boring">   owned: String,
</span><span class="boring">   borrowed: Cell&lt;&amp;'a str&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ShareableSnek&lt;'a&gt; {
</span><span class="boring">    fn bite(&amp;'a self) {
</span><span class="boring">        self.borrowed.set(&amp;self.owned);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">let snek = ShareableSnek {
</span><span class="boring">    owned: "🐍".to_string(),
</span><span class="boring">    borrowed: Cell::new(""),
</span><span class="boring">};
</span><span class="boring">
</span>snek.bite();
let _mutable_stuff = &amp;mut snek;
let _move = snek;

// Having a non-trivial destructor would also cause a failure
<span class="boring">}</span></code></pre></pre>
<p>Once it's borrowed forever, the <code>snek</code> can only be used in a "shared" way.
It can only be mutated using shared mutability, and it can't be moved --
it's pinned in place forever.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scrutinize-compiler-advice"><a class="header" href="#scrutinize-compiler-advice">Scrutinize compiler advice</a></h1>
<p>The compiler gives better errors than pretty much any other language I've used, but it still does give some poor suggestions in some cases.
It's hard to turn a borrow check error into an accurate "what did the programmer mean" suggestion.
So suggested bounds are an area where it can be better to take a moment to try and understand what's going on with the lifetimes,
instead of just blindly applying compiler advice.</p>
<p>I'll cover a few scenarios here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advice-to-change-function-signature-when-aliases-are-involved"><a class="header" href="#advice-to-change-function-signature-when-aliases-are-involved">Advice to change function signature when aliases are involved</a></h1>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=ad6f395f748927ae66d06b2fd42603ea">Here's a scenario from earlier in this guide.</a>  The compiler advice is:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0621]: explicit lifetime required in the type of `s`
 --&gt; src/lib.rs:5:9
  |
4 |     fn new(s: &amp;str) -&gt; Node&lt;'_&gt; {
  |               ---- help: add explicit lifetime `'a` to the type of `s`: `&amp;'a str`
5 |         Self(s)
  |         ^^^^^^^ lifetime `'a` required
<span class="boring">}</span></code></pre></pre>
<p>But <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=9d89786c76424d66e7eb11ca7716645b">this works just as well:</a></p>
<pre><code class="language-diff">-        Self(s)
+        Node(s)
</code></pre>
<p>And you may get this advice when implementing a trait, where you usually <em>can't</em> change the signature.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advice-to-add-bound-which-implies-lifetime-equality"><a class="header" href="#advice-to-add-bound-which-implies-lifetime-equality">Advice to add bound which implies lifetime equality</a></h1>
<p>The example for this one is very contrived, but <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=aad18e17e4308fc4e94c5fd039e64d90">consider the output here:</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;'a, 'b&gt;(s: &amp;'a mut &amp;'b mut str) -&gt; &amp;'b str {
    *s
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  = help: consider adding the following bound: `'a: 'b`
<span class="boring">}</span></code></pre></pre>
<p>With the nested lifetime in the argument, there's already an implied <code>'b: 'a</code> bound.
If you follow the advice and add a <code>'a: 'b</code> bound, then the two bounds together imply that <code>'a</code> and <code>'b</code> are in fact the same lifetime.
More clear advice would be to use a single lifetime.  Even better advice for this particular example would be to return <code>&amp;'a str</code> instead.</p>
<p>Another possible pitfall of blindly following this advice is ending up with something like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Node&lt;'a&gt; {
    fn g&lt;'s: 'a&gt;(&amp;'s mut self) { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>That's <a href="pf-self.html">the <code>&amp;'a mut Node&lt;'a&gt;</code> anti-pattern</a> in disguise!  This will probably be unusable and hints at a deeper problem that needs solved.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advice-to-add-a-static-bound"><a class="header" href="#advice-to-add-a-static-bound">Advice to add a static bound</a></h1>
<p>The compiler is gradually getting better about this, but when it suggests to use a <code>&amp;'static</code> or that a lifetime needs to outlive <code>'static</code>, it usually <em>actually</em> means either</p>
<ul>
<li>You're in a context where non-<code>'static</code> references and other non-<code>static</code> types aren't allowed</li>
<li>You should add a lifetime parameter somewhere</li>
</ul>
<p>Rather than try to cook up my own example, <a href="https://github.com/rust-lang/rust/issues/50212">I'll just link to this issue.</a>
Although it's closed, there's still room for improvement in some of the examples within.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="illustrative-examples"><a class="header" href="#illustrative-examples">Illustrative examples</a></h1>
<p>Here we provide some examples and "recipes" to illustrate how lifetimes
work (or don't work) in more practical settings.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-slice-iterator"><a class="header" href="#mutable-slice-iterator">Mutable slice iterator</a></h1>
<p>The standard library has <a href="https://doc.rust-lang.org/std/slice/struct.IterMut.html">an iterator over <code>&amp;mut [T]</code></a>
which is implemented (as of this writing) in terms of pointer arithmetic, presumably for the sake of optimization.
In this example, we'll show how one can implement their own mutable slice iterator with entirely safe code.</p>
<p>Here's the starting place for our implementation:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyIterMut&lt;'a, T&gt; {
    slice: &amp;'a mut [T],
    // ...maybe other fields for your needs...
}

impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        todo!()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Below are a few starting attempts at it.  Spoilers, they don't compile.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyIterMut&lt;'a, T&gt; { slice: &amp;'a mut [T], }
</span><span class="boring">impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
</span><span class="boring">  type Item = &amp;'a mut T;
</span>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // Eh, we'll worry about iterative logic later!
        self.slice.get_mut(0)
    }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyIterMut&lt;'a, T&gt; { slice: &amp;'a mut [T], }
</span><span class="boring">impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
</span><span class="boring">  type Item = &amp;'a mut T;
</span>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // Actually, this method looks perfect for our iteration logic
        let (first, rest) = self.slice.split_first_mut()?;
        self.slice = rest;
        Some(first)
    }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyIterMut&lt;'a, T&gt; { slice: &amp;'a mut [T], }
</span><span class="boring">impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
</span><span class="boring">   type Item = &amp;'a mut T;
</span>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // 🤔 Pattern matching??
        match &amp;mut self.slice {
            [] =&gt; None,
            [first, rest @ ..] =&gt; Some(first),
        }
    }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Yeah, the compiler really doesn't like any of that.  Let's take a minute to write out all the elided
lifetimes.  Some of them are in aliases, which we're also going to expand:</p>
<ul>
<li><code>Item</code> is <code>&amp;'a mut T</code></li>
<li><code>&amp;mut self</code> is short for <code>self: &amp;mut Self</code>, and
<ul>
<li><code>Self</code> is <code>MyIterMut&lt;'a, T&gt;</code></li>
</ul>
</li>
</ul>
<p>Here's what it looks like with everything being explicit:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyIterMut&lt;'a, T&gt; { slice: &amp;'a mut [T], }
</span><span class="boring">impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
</span><span class="boring">  type Item = &amp;'a mut T;
</span>    fn next&lt;'s&gt;(self: &amp;'s mut MyIterMut&lt;'a, T&gt;) -&gt; Option&lt;&amp;'a mut T&gt; {
        todo!()
    }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>And remember that in <code>MyIterMut&lt;'a, T&gt;</code>, <code>slice</code> is a <code>&amp;'a mut [T]</code>.</p>
<p>Ah, yes.  <a href="./st-invariance.html">We have a nested exclusive borrow</a> here.</p>
<blockquote>
<p>You cannot get a <code>&amp;'long mut U</code> through dereferencing a <code>&amp;'short mut &amp;'long mut U</code>.</p>
<ul>
<li>You can only reborrow a <code>&amp;'short mut U</code>.</li>
</ul>
</blockquote>
<p>There is no safe way to go <em>through</em> the <code>&amp;'s mut self</code> and pull out a <code>&amp;'a mut T</code>.</p>
<p>Are we stuck then?  No, there is actually a way forward! As it turns out,
slices are special.  In particular, the compiler understands that an <em>empty</em> slice
covers <em>no actual data</em>, so there can't be any memory aliasing concerns or data races,
et cetera.  So the compiler understands it's perfectly sound to pull an empty slice
reference out of no where, with any lifetime at all.  Even if it's an exclusive slice reference!</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn magic&lt;T&gt;() -&gt; &amp;'static mut [T] {
    &amp;mut []
}
<span class="boring">}</span></code></pre></pre>
<p>For our purposes, we don't even need the magic: the standard library
<a href="https://doc.rust-lang.org/std/default/trait.Default.html#impl-Default-for-%26mut+%5BT%5D">has a <code>Default</code> implementation</a>
for <code>&amp;mut [T]</code>.</p>
<p>Why does this unstick us?  With that implementation, we can conjure an empty <code>&amp;mut [T]</code>
out of nowhere and <em>move our <code>slice</code> field out from behind <code>&amp;mut self</code>:</em></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyIterMut&lt;'a, T&gt; { slice: &amp;'a mut [T], }
</span><span class="boring">impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
</span><span class="boring">  type Item = &amp;'a mut T;
</span>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let mut slice = std::mem::take(&amp;mut self.slice);
        // Eh, we'll worry about iterative logic later!
        slice.get_mut(0)
    }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p><a href="https://doc.rust-lang.org/std/mem/fn.take.html"><code>std::mem::take</code></a> and <code>swap</code> and <code>replace</code> are
very useful and safe functions; don't be thrown off by them being in <code>std::mem</code> along side the
dangerous <code>transmute</code> and other low-level functions.  Note how we passed <code>&amp;mut self.slice</code> --
that's a <code>&amp;mut &amp;mut [T]</code>.  <code>take</code> replaces everything inside of the outer <code>&amp;mut</code>, which can have
an arbitrarily short lifetime -- just long enough to move the memory around.</p>
<p>So we're done aside from iterative logic, right?  This should just give us the first element forever?</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyIterMut&lt;'a, T&gt; { slice: &amp;'a mut [T], }
</span><span class="boring">impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
</span><span class="boring">  type Item = &amp;'a mut T;
</span><span class="boring">  fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">      let mut slice = std::mem::take(&amp;mut self.slice);
</span><span class="boring">      slice.get_mut(0)
</span><span class="boring">  }
</span><span class="boring">}
</span>let mut arr = [0, 1, 2, 3];
let iter = MyIterMut { slice: &amp;mut arr };
for x in iter.take(10) {
    println!("{x}");
}
<span class="boring">}</span></code></pre></pre>
<p>Uh, it only gave us one item.  Oh right -- when we're done with the slice, we need to move it
back into our <code>slice</code> field.  We only want to <em>temporarily</em> replace that field with an empty slice.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyIterMut&lt;'a, T&gt; { slice: &amp;'a mut [T], }
</span><span class="boring">impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
</span><span class="boring">  type Item = &amp;'a mut T;
</span>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let mut slice = std::mem::take(&amp;mut self.slice);
        // Eh, we'll worry about iterative logic later!
        let first = slice.get_mut(0);
        self.slice = slice;
        first
    }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Uh oh, now what.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>error[E0499]: cannot borrow `*slice` as mutable more than once at a time
9  |         let first = slice.get_mut(0);
   |                     ----- first mutable borrow occurs here
10 |         self.slice = slice;
   |                      ^^^^^ second mutable borrow occurs here
11 |         first
   |         ----- returning this value requires that `*slice` is borrowed for `'a`
<span class="boring">}</span></code></pre></pre>
<p>Oh, right!  These are <em>exclusive</em> references.  We can't return the same item multiple
times -- that would mean someone could get multiple <code>&amp;mut</code> to the same element if they
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect">collect</a>ed the
iterator, for example.  Come to think of it, we can't punt on our iteration logic
either -- if we try to hold on to the entire <code>&amp;mut [T]</code> while handing out <code>&amp;mut T</code>
to the elements, that's <em>also</em> multiple <code>&amp;mut</code> to the same memory!</p>
<p>This is what the error is telling us: We can't hold onto the entire <code>slice</code> and
return <code>first</code>.</p>
<p>(There's a pattern called "leanding iterators" where you can hand out borrows of
data you own in an iterator-like fashion, but it's not possible with the current
<code>Iterator</code> trait; it is also a topic for another day.)</p>
<p>Alright, let's try <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_first_mut"><code>split_first_mut</code></a>
again instead, that really did seem like a perfect fit for our iteration logic.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyIterMut&lt;'a, T&gt; { slice: &amp;'a mut [T], }
</span><span class="boring">impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
</span><span class="boring">  type Item = &amp;'a mut T;
</span>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let mut slice = std::mem::take(&amp;mut self.slice);
        let (first, rest) = slice.split_first_mut()?;
        self.slice = rest;
        Some(first)
    }
<span class="boring">}
</span>
// ...

let mut arr = [0, 1, 2, 3];
let iter = MyIterMut { slice: &amp;mut arr };
for x in iter {
    println!("{x}");
}
<span class="boring">}</span></code></pre></pre>
<p>Finally, a working version!  <code>split_first_mut</code> is a form of <a href="./lifetime-analysis.html#independently-borrowing-fields">borrow splitting,</a>
which we briefly mentioned before.</p>
<p>And for the sake of completion, here's the pattern based approach to borrow splitting:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyIterMut&lt;'a, T&gt; { slice: &amp;'a mut [T], }
</span><span class="boring">impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
</span><span class="boring">  type Item = &amp;'a mut T;
</span>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        //    ....these are all that changed....
        //    vvvvvvvvvvvvvvvvvv               v
        match std::mem::take(&amp;mut self.slice) {
            [] =&gt; None,
            [first, rest @ ..] =&gt; Some(first),
        }
     }
<span class="boring">}
</span>
// ...

let mut arr = [0, 1, 2, 3];
let iter = MyIterMut { slice: &amp;mut arr };
for x in iter {
    println!("{x}");
}
<span class="boring">}</span></code></pre></pre>
<p>Oh whoops, just one element again.  Right.  We need to put the <code>rest</code> back in <code>self.slice</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyIterMut&lt;'a, T&gt; { slice: &amp;'a mut [T], }
</span><span class="boring">impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
</span><span class="boring">  type Item = &amp;'a mut T;
</span>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        match std::mem::take(&amp;mut self.slice) {
            [] =&gt; None,
            [first, rest @ ..] =&gt; {
                self.slice = rest;
                Some(first)
            }
        }
     }
<span class="boring">}
</span>
// ...

let mut arr = [0, 1, 2, 3];
let iter = MyIterMut { slice: &amp;mut arr };
for x in iter {
    println!("{x}");
}
<span class="boring">}</span></code></pre></pre>
<p>👍</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circle-back"><a class="header" href="#circle-back">Circle back</a></h1>
<p>Ownership, borrowing, and lifetimes is a huge topic.  There's way too much in this "intro" guide alone for you to absorb everything in it at once.
So occasionally circle back and revisit the common misconceptions, or the documentation on variance, or take another crack at some complicated problem you saw.
Your mental model will expand over time; it's enough in the beginning to know some things exist and revisit them when you run into a wall.</p>
<p>Moreover, Rust is practicality oriented, and the abilities of the compiler have developed organically to allow common patterns soundly and ergonomically.
Which is to say that the borrow checker has a fractal surface; there's an exception to any mental model of the borrow checker.
So there's always something new to learn, forget, and relearn, if you're into that.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="miscellanea-1"><a class="header" href="#miscellanea-1">Miscellanea</a></h1>
<p>This section collects relatively small and self-contained tutorials
and other tidbits.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slice-layout"><a class="header" href="#slice-layout">Slice layout</a></h1>
<p>It's not uncommon for people on <a href="https://users.rust-lang.org/">the forum</a>
to ask why it's conventional to have <code>&amp;[T]</code> as an argument insteaed of
<code>&amp;Vec&lt;T&gt;</code>, or to ask about the layout of slices more generally.  Or to
ask analogous questions about <code>&amp;str</code> and <code>String</code>, et cetera.</p>
<p>This page exists to be a useful citation for such questions.</p>
<p>If you want, you can skip ahead to the <a href="misc-slice.html#graphical-layout">graphical layout.</a></p>
<h2 id="what-is-a-slice-anyway"><a class="header" href="#what-is-a-slice-anyway">What is a slice anyway?</a></h2>
<p>The terminology around slices tends to be pretty loose.  I'll try to keep
it more formal on this page, but when you read something about a "slice"
elsewhere, keep in mind that it may be referring to any of <code>[T]</code>, <code>&amp;[T]</code>,
<code>&amp;mut [T]</code>, or even other types of references to <code>[T]</code> (<code>Box&lt;[T]&gt;</code>, <code>Arc&lt;[T]&gt;</code>, ...).</p>
<p>This is the case not just for casual material, but for
<a href="https://doc.rust-lang.org/std/primitive.slice.html">official documentation</a>
and other technical material.  You just have to figure out which one or
ones they are specifically talking about from context.</p>
<p>With that out of the way, let me intoduce some terminology for this page:</p>
<ul>
<li>
<p>A slice, <code>[T]</code>, is a series of <code>T</code> in contiguous memory (layed out one after
another, with proper alignment). The length is only known at run time; we say
it is a dynamically sized type (DST), or an unsized type, or a type that does
not implement <a href="https://doc.rust-lang.org/std/marker/trait.Sized.html"><code>Sized</code></a>.</p>
</li>
<li>
<p>A shared slice, <code>&amp;[T]</code>, is a shared reference to a slice. It's a wide
reference consisting of a pointer to the memory of the slice, and the number
of elements in the slice.</p>
</li>
<li>
<p>An exclusive slice, <code>&amp;mut [T]</code>, is like a shared slice, but the borrow is
exclusive (so you can e.g. overwrite elements through it).</p>
</li>
<li>
<p>There are other wide pointer variations like boxed slices (<code>Box&lt;[T]&gt;</code>) and
so on; we'll mention a few more momentarily.</p>
</li>
</ul>
<p>Note that while slices are unsized, the wide pointers to slices (like <code>&amp;[T]</code>)
are sized.</p>
<h3 id="where-is-a-slice"><a class="header" href="#where-is-a-slice">Where is a slice?</a></h3>
<p>Slices can be on the heap, but also on the stack, or in static memory, or
anywhere else.  The type doesn't "care" where it is.  Therefore, you can't
be sure where a pointer to a slice points unless the pointer itself has
further guarantees.</p>
<p>For example, if you have a <code>Box&lt;[T]&gt;</code>, then any <code>T</code> within are on the
heap, because that's a guarantee of
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box&lt;_&gt;</code>.</a>
(N.b. if <code>T</code> is zero sized, they are not actually stored anywhere.)
So in that <em>particular</em> case, we could say the slice <code>[T]</code> is on the heap.</p>
<h2 id="what-is-a-vec_-anyway"><a class="header" href="#what-is-a-vec_-anyway">What is a <code>Vec&lt;_&gt;</code> anyway?</a></h2>
<p>A <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> is growable buffer
that owns and stores <code>T</code>s in contiguous memory, on the heap.  You can conceptually
think of this as something that owns a slice <code>[T]</code> (or more accurately,
<code>[MaybeUninit&lt;T&gt;]</code>). You can index into a <code>Vec&lt;T&gt;</code> with a range and get back a
shared or exclusive slice.</p>
<p><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#guarantees">A <code>Vec&lt;_&gt;</code> consists of a pointer, capacity, and length.</a></p>
<h2 id="other-types"><a class="header" href="#other-types">Other types</a></h2>
<p>A <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> is, under the hood,
like a <code>Vec&lt;u8&gt;</code> which has additional guarantees -- namely, that the bytes are valid UTF8.
A <a href="https://doc.rust-lang.org/std/primitive.str.html"><code>&amp;str</code></a> is like a <code>&amp;[u8]</code> that has the
same guarantee.  You can index into a <code>String</code> with a range and get back a <code>&amp;str</code>
(or <code>&amp;mut str</code>). Like <code>[u8]</code>, a <code>str</code> is unsized, which is why you're almost always working
with a <code>&amp;str</code> or other pointer instead.</p>
<p>So the relationship betweeen <code>str</code> and <code>String</code> is the same as between <code>[T]</code> and <code>Vec&lt;T&gt;</code>.
There are other pairs of types with the same relationship:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/path/struct.Path.html"><code>Path</code></a> and <a href="https://doc.rust-lang.org/std/path/struct.PathBuf.html"><code>PathBuf</code></a></li>
<li><a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html"><code>OsStr</code></a> and <a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html"><code>OsString</code></a></li>
<li><a href="https://doc.rust-lang.org/std/ffi/struct.CStr.html"><code>CStr</code></a> and <a href="https://doc.rust-lang.org/std/ffi/struct.CString.html"><code>CString</code></a></li>
</ul>
<p>These <code>std</code> types generally have a <a href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#implementors"><code>ToOwned</code></a>
relationship and a <a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html#implementors"><code>Borrow</code></a> relationship.</p>
<p>Even more data structures that can be considered a form of <em>owned</em> slices include:</p>
<ul>
<li>
<p><a href="https://doc.rust-lang.org/std/primitive.array.html"><code>[T; N]</code></a> is an array with a
compile-time known length (i.e. it's a fixed-size array).  It is like a slice (<code>[T]</code>),
but it is <code>Sized</code>, as the the length is known at compile time.  The length is also part
of the type. It's not growable.</p>
</li>
<li>
<p><code>Box&lt;[T]&gt;</code>, a "boxed slice"; this is similar to a <code>Vec&lt;T&gt;</code> in that it owns the <code>T</code>
and stores them contiguously on the heap.  Unlike a <code>Vec&lt;T&gt;</code>, the buffer is not growable
(or shrinkable) through a <code>&amp;mut Box&lt;[T]&gt;</code>; you would have to allocate new storage and
move the elements over.  The length of a boxed slice is stored at runtime, and isn't
known at compile time.  Therefore, like a shared slice, it consists of a pointer and
a length.</p>
</li>
<li>
<p><code>Arc&lt;[T]&gt;</code> and <code>Rc&lt;[T]&gt;</code> are shared owneship variations on <code>Box&lt;[T]&gt;</code>.</p>
</li>
<li>
<p>There are similar variations for string-like types (<code>Box&lt;str&gt;</code>, <code>Arc&lt;Path&gt;</code>, <code>Rc&lt;OsStr&gt;</code>, ...)</p>
</li>
<li>
<p>And other combinations too (<code>Box&lt;[T; N]&gt;</code>, etc.)</p>
</li>
</ul>
<p>You can create shared slices to these other types of owned slices as well.</p>
<p>Technically, just a single <code>T</code> is like a <code>[T; 1]</code> (it has the same layout in memory).
So if you squint just right, every owned <code>T</code> is also a form of owned slice, but with
a compile-time known length of 1.  And indeed, you can create
<a href="https://doc.rust-lang.org/std/slice/fn.from_ref.html"><code>&amp;[T]</code></a>
and <a href="https://doc.rust-lang.org/std/slice/fn.from_mut.html"><code>&amp;mut [T]</code></a>
(<a href="https://doc.rust-lang.org/std/array/index.html#functions">and array versions too</a>)
from <code>&amp;T</code> and <code>&amp;mut T</code>.</p>
<h2 id="graphical-layout"><a class="header" href="#graphical-layout">Graphical layout</a></h2>
<p>Here's a graphical representation of the layout of slices, shared slices,
<code>Vec&lt;T&gt;</code>, and <code>&amp;Vec&lt;T&gt;</code>.</p>
<pre><code>+---+---+---+---+---+---+---+---+
| Pointer       | Length        | &amp;[T] (or &amp;str, &amp;Path, Box&lt;[T]&gt;, ...)
+---+---+---+---+---+---+---+---+
  |
  V
+---+---+---+---+---+---+---+---+
| D | A | T | A | . | . | . | ......    [T] (or str, Path, ...)
+---+---+---+---+---+---+---+---+
  ^
  |
+---+---+---+---+---+---+---+---+---+---+---+---+
| Pointer       | Length        | Capacity      | Vec&lt;T&gt; (or String, PathBuf, ...)
+---+---+---+---+---+---+---+---+---+---+---+---+
  ^
  |
+---+---+---+---+
| Pointer       | &amp;Vec&lt;T&gt; (or &amp;String, &amp;PathBuf, ...)
+---+---+---+---+
</code></pre>
<p>One advantage of taking <code>&amp;[T]</code> instead of <code>&amp;Vec&lt;T&gt;</code> as an argument should be
immediately apparent from the diagram: a <code>&amp;[T]</code> has less indirection.</p>
<p>However, there are other reasons:</p>
<ul>
<li>Everything useful for <code>&amp;Vec&lt;T&gt;</code> is actually a method on <code>&amp;[T]</code>
<ul>
<li>You can't check the capacity with a <code>&amp;[T]</code>, but you can't change the capacity with a <code>&amp;Vec&lt;T&gt;</code> anyway</li>
</ul>
</li>
<li>If you take <code>&amp;[T]</code> as an argument, you can take shared slices that point to data
which isn't owned by a <code>Vec&lt;T&gt;</code> (such as static data, part of an array, into a <code>Box&lt;[T]&gt;</code>, et cetera)
<ul>
<li>So it is strictly and significantly more general to take <code>&amp;[T]</code></li>
</ul>
</li>
</ul>
<p>Similar advantages apply to taking a <code>&amp;str</code> instead of a <code>&amp;String</code>, et cetera.</p>
<p>In contrast, there are many things you can do with a <code>&amp;mut Vec&lt;T&gt;</code> that you can't
do with a <code>&amp;mut [T]</code>, so which you choose depends much more on what you need to
do with the borrowed data.</p>
<h3 id="graphical-layout-for-arrays"><a class="header" href="#graphical-layout-for-arrays">Graphical layout for arrays</a></h3>
<p>The layout of an array is the same as a slice, except the length is known.</p>
<pre><code>+---+---+---+---+---+---+---+---+
| Pointer       | Length        | &amp;[T] (or &amp;str, &amp;Path, Box&lt;[T]&gt;, ...)
+---+---+---+---+---+---+---+---+
  |
  V
+---+---+---+---+---+---+---+
| D | A | T | A | . | . | . | [T; N] (or str, Path, ...)
+---+---+---+---+---+---+---+
  ^
  |
+---+---+---+---+
| Pointer       | &amp;[T; N] (or `Box&lt;[T; N]&gt;`, ...)
+---+---+---+---+
  ^
  |
+---+---+---+---+
| Pointer       | &amp;Box&lt;[T; N]&gt; (or &amp;&amp;[T; N], ...)
+---+---+---+---+
</code></pre>
<p>Because <code>[T; N]</code> is sized, and because the length is part of the type,
pointers to it (like <code>&amp;[T; N]</code>) are normal "thin" pointers, not "wide"
pointers.  But you can also create a <code>&amp;[T]</code> that points to the array
(or to part of the array), as in the diagram.</p>
<p>Should you take a <code>&amp;[T]</code> or a <code>&amp;[T; N]</code> as a function argument?  If
you don't need a specific length, and aren't trying to generate code
that's optimized based on the specific length of the array, you probably
want <code>&amp;[T]</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-parameter-mechanics"><a class="header" href="#default-parameter-mechanics">Default parameter mechanics</a></h1>
<p>Default parameters in Rust are not as convenient as one might wish.
<a href="https://rust-lang.github.io/rfcs/0213-defaulted-type-params.html">The RFC for default type parameters</a>
was never fully completed; in particular, the "inference falls back to defaults"
parts have been delayed indefinitely.  As a result, there are times where default
parameters don't kick in, and you have to either be explicit or use other
workarounds.  It can also be unclear why the workarounds act differently.</p>
<p><a href="https://github.com/rust-lang/reference/issues/24">Default parameters are also not in the reference yet.</a></p>
<p>This page exists to explain the mechanics behind default parameters as they
exist today, and to clear up exactly what the workarounds mean.  For an exploration
on how the interaction between inference and default parameters could be defined
in the future, I recommend
<a href="https://faultlore.com/blah/defaults-affect-inference/">this wonderful blog post by Gankra.</a></p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>The most likely reason you'll run into default parameters not "working" is because
some expression desugars to replacing all type (and <code>const</code>) parameters with inference
variables, in combination with the fact that inference variables do not fall back to the
defaults.</p>
<p>What are inference variables?  For types, an inference variable is the same as the
"wildcard type" <code>_</code>, which tells the compiler to infer the type for you.
<a href="https://github.com/rust-lang/rust/issues/85077"><code>_</code> cannot be used for <code>const</code> parameters as of yet,</a>
but they can still be inferred implicitly.</p>
<p>(For most of this guide, we'll be focused on types;
<a href="misc-default-param.html#const-parameters">there's a subsection about <code>const</code> parameters specifically later.</a>)</p>
<p>Let's see some examples of compilation failures involving defaulted parameters:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span>// `HashSet` will be our running example for a type with both required
// (non-defaulted, non-lifetime) and defaulted parameters
// struct HashSet&lt;Key, S = RandomState&gt; { .. }

// The `insert` is enough for the compiler to infer the `Key` parameter, but
// not the `S` parameter
let mut hs = HashSet::default();
hs.insert(String::new());

// This means the same thing: *all* type (and const) parameters became
// inference variables
let mut hs = HashSet::&lt;_, _&gt;::default();
hs.insert(String::new());
<span class="boring">}</span></code></pre></pre>
<p>This can be confusing because similar code just works:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span>// This compiles, but the compiler can figure `Key` out on its own, so why?
let mut hs = HashSet::&lt;String&gt;::default();
hs.insert(String::new());

// And in fact... this compiles too!
let mut hs = HashSet::&lt;_&gt;::default();
hs.insert(String::new());

// `new` doesn't have this problem, which may also be confusing
let mut hs = HashSet::new();
hs.insert(String::new());
<span class="boring">}</span></code></pre></pre>
<p>The errors can also arise when the type has defaults for of all the type (and <code>const</code>) parameters:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This will be our running example for a type where all non-lifetime
// parameters have defaults
pub enum Foo&lt;T = String&gt; {
    Bar(T),
    Baz,
}

// This fails because the elided parameter desugars to an inference variable
let foo = Foo::Baz;

// So this means the exact same thing
let foo = Foo::&lt;_&gt;::Baz;
<span class="boring">}</span></code></pre></pre>
<p>And some of the workarounds may be even more confusing:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub enum Foo&lt;T = String&gt; { Bar(T), Baz }
</span>// This works!
let foo = &lt;Foo&gt;::Baz;
<span class="boring">}</span></code></pre></pre>
<p>We want to explain exactly which expressions end up being problematic, and why
the workarounds solve the problem.</p>
<h2 id="the-explanations-in-brief"><a class="header" href="#the-explanations-in-brief">The explanations in brief</a></h2>
<p>First let's tackle why just wrapping the type in <code>&lt;&gt;</code> worked for that last example.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub enum Foo&lt;T = String&gt; { Bar(T), Baz }
</span>let foo = &lt;Foo&gt;::Baz;
<span class="boring">}</span></code></pre></pre>
<p>The leading <code>&lt;Foo&gt;::</code> notation is called a
"<a href="misc-default-param.html#more-about-qualified-path-expressions">qualified path type</a>".
And the short answer to why it works is that, with respect to elided default
parameters, types in <code>&lt;&gt;</code>s act the same as type ascription:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub enum Foo&lt;T = String&gt; { Bar(T), Baz }
</span>// Also works
let foo: Foo = Foo::Baz;
<span class="boring">}</span></code></pre></pre>
<p>Type ascription uses default parameters in a way that's probably closer to your intuition.
(<a href="misc-default-param.html#type-position-mechanics-in-more-detail">We explore the details below.</a>)
Note that types act like type ascription in <code>&lt;&gt;</code> elsewhere too, such as
within a turbofish, not just as a qualified path type.</p>
<p>As for the difference here:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span>// This fails if we change `HashSet::new()` to `HashSet::default()`
let mut hs = HashSet::new();
hs.insert(String::new());
<span class="boring">}</span></code></pre></pre>
<p>The example only works because <a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html#implementations">HashSet::new</a>
(and a number of other methods) is only defined for <code>HashSet&lt;_, RandomState&gt;</code>.
In contrast, <code>Default</code> is implemented for all possible <code>HashSet&lt;_, _&gt;</code>.  So
in a sense, this is a workaround on the side of the <code>HashSet</code> implementation!
<a href="https://faultlore.com/blah/defaults-affect-inference/">If inference and default parameters worked together,</a>
<code>new</code> would presumably be defined for all possible hashers, too.</p>
<p>Finally, let's look at this workaround:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span>// Remember, `HashSet::default()` fails
let mut hs = HashSet::&lt;_&gt;::default();
hs.insert(String::new());
<span class="boring">}</span></code></pre></pre>
<p>The key difference here is that <em>if no required parameters are specified,</em>
then <em>all</em> the type (and <code>const</code>) parameters -- <em>including defaulted parameters</em>
-- are filled in with inference variables.  But if one or more non-lifetime
parameter is specified, it desugars to a qualified type path -- where default
parameters act the same as they do in type ascription.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span>// These are all the same and fail
// let mut hs = HashSet::default();
// let mut hs = HashSet::&lt;&gt;::default();
// let mut hs = HashSet::&lt;_, _&gt;::default();
let mut hs = &lt;HashSet::&lt;_, _&gt;&gt;::default();
hs.insert(String::new());
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span>// These are the same and succeed.
// let mut hs = HashSet::&lt;_&gt;::default();
let mut hs = &lt;HashSet&lt;_&gt;&gt;::default();
hs.insert(String::new());
<span class="boring">}</span></code></pre></pre>
<p>As is clear from the example, using <code>_</code> explicitly counts as specifying a type
parameter.  Also note that the desugaring to "all parameters are inference
variables" only happens when the type is not inside <code>&lt;&gt;</code>s.</p>
<h2 id="type-position-mechanics-in-more-detail"><a class="header" href="#type-position-mechanics-in-more-detail">Type position mechanics in more detail</a></h2>
<p>By "type position", we mean contexts where the language expects a type specifically.
This includes variable type ascription, implementation headers, type parameter
fields themselves, and qualified path types.</p>
<p>In type position, you can only elide default parameters.  Elided default parameters are
replaced by their default types (or <code>const</code> values) specifically (i.e. not inference variables).</p>
<p>Let's see some examples:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">use std::hash::RandomState;
</span><span class="boring">enum Foo&lt;T = String&gt; { Bar(T), Baz, }
</span>// These ascriptions mean the same thing
//     vvvvvvvvvvv
let e: Foo         = Foo::Baz;
let e: Foo&lt;&gt;       = Foo::Baz;
let e: Foo&lt;String&gt; = Foo::Baz;

// These ascriptions mean the same thing
//      vvvvvvvvvvvvvvvvvvvvvvvvvvvv
let hs: HashSet&lt;String&gt;              = Default::default();
let hs: HashSet&lt;String, RandomState&gt; = Default::default();
<span class="boring">}</span></code></pre></pre>
<p>The following errors demonstrate that elided parameters aren't inference variables,
and that inference variables don't fall back to the defaults.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Foo&lt;T = String&gt; { Bar(T), Baz, }
</span>// Fails due to ambiguity
let e: Foo&lt;_&gt; = Foo::Baz;
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">use std::hash::RandomState;
</span>// Fails due to ambiguity
let hs: HashSet&lt;String, _&gt; = Default::default();
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Foo&lt;T = String&gt; { Bar(T), Baz, }
</span>// Fails because the elided type is exactly the default type (`String`)
let e: Foo = Foo::Bar(0);
<span class="boring">}</span></code></pre></pre>
<p>The final example is the opposite situation from most of the examples we've seen:
it's a case where you want inference to override defaults.  If you made the ascription
<code>Foo&lt;_&gt;</code> it will compile (but a more trivial fix for this particular example is to
just remove the redundant ascription).</p>
<h2 id="more-about-qualified-path-expressions"><a class="header" href="#more-about-qualified-path-expressions">More about qualified path expressions</a></h2>
<p>Types inside of <code>&lt;&gt;</code>s are in type position, and that includes qualified path expressions.</p>
<p>A <a href="https://doc.rust-lang.org/reference/paths.html#qualified-paths">qualified path expressions</a>
is when you have some path expression that starts with a segment contained in
<code>&lt;&gt;</code>.  They were defined in <a href="https://rust-lang.github.io/rfcs/0132-ufcs.html">RFC 0132</a>
and they come in two different forms:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//      vvvvvvvv `&lt;T&gt;` where `T` is a type
let s = &lt;String&gt;::default();

//      vvvvvvvvvvvvvvvvvvv `&lt;T as Tr&gt;` where `T` is a type and `Tr` is a trait
let s = &lt;String as Default&gt;::default();
<span class="boring">}</span></code></pre></pre>
<p>The first form can resolve to inherent functions or trait methods, whereas
the second form can only resolve to the named trait's methods.  Rust doesn't
have "trait inference variables", so the trait must be named; you can't use
<code>_</code> in place of the trait, for example.  (You can still use it in place of
the trait's type parameters.)</p>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p>Default parameters for traits work the same as default parameters for types,
both inside and outside of "type position".  When thinking of traits in paths
as sugar for qualified paths, the desugaring is like so:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait&lt;One, Two = String&gt;: Sized {
    fn foo(self) -&gt; (Self, One, Two) where One: Default, Two: Default {
        (self, One::default(), Two::default())
    }
}

impl&lt;T, U&gt; Trait&lt;T, U&gt; for i32 {}
impl&lt;T, U&gt; Trait&lt;T, U&gt; for f64 {}

// Failing versions
//let _: (i32, (), _) = Trait::foo(0);
//let _: (i32, (), _) = Trait::&lt;_, _&gt;::foo(0);
let _: (i32, (), _) = &lt;_ as Trait&lt;_, _&gt;&gt;::foo(0);
//                    ^^^^^^^^^^^^^^^^^^
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait&lt;One, Two = String&gt;: Sized {
</span><span class="boring">   fn foo(self) -&gt; (Self, One, Two) where One: Default, Two: Default {
</span><span class="boring">       (self, One::default(), Two::default())
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">impl&lt;T, U&gt; Trait&lt;T, U&gt; for i32 {}
</span><span class="boring">impl&lt;T, U&gt; Trait&lt;T, U&gt; for f64 {}
</span>// Working versions
let _: (i32, (), _) = Trait::&lt;_&gt;::foo(0);
let _: (i32, (), _) = &lt;_ as Trait&lt;_&gt;&gt;::foo(0);
//                    ^^^^^^^^^^^^^^^
<span class="boring">}</span></code></pre></pre>
<p>The only new thing of note is that the implementing type is an inference variable
in this case.</p>
<h3 id="mostly-historical-side-note"><a class="header" href="#mostly-historical-side-note">Mostly historical side note</a></h3>
<p>Before edition 2021, it's possible to leave the <code>dyn</code> off of <code>dyn Trait</code> types
(although it does fire a lint).  This means that the same name can refer to either
a trait, or a type (the trait object type).  Which one is used depends on the
context.</p>
<p>For example:</p>
<pre><code class="language-rust ignore">let _: i32 = Trait::name(0.0);

// If `Trait` has a method called `name`, that is is
let _: i32 = &lt;_ as Trait&gt;::name(0.0);

// But if it does not, and `dyn Trait` has a method called `name`, this is
let _: i32 = &lt;dyn Trait&gt;::name(0.0)

// And the following line is always referring to `dyn Trait`
let _: i32 = &lt;Trait&gt;::name(0.0);</code></pre>
<h2 id="more-about-types-in-expressions"><a class="header" href="#more-about-types-in-expressions">More about types in expressions</a></h2>
<p>In this section, "types in expressions" refers to types which are in expressions
but not within <code>&lt;&gt;</code> (e.g. not a qualified path type or a type parameter).  These
are the positions where it is <em>required</em> to use turbofish (e.g. <code>Vec::&lt;String&gt;</code>)
instead of just appending the parameter list (e.g. <code>Vec&lt;String&gt;</code>).</p>
<p>In these positions, it is always allowed to elide all the type and <code>const</code>
parameters, even if there are required (i.e. non-defaulted, non-lifetime)
parameters.  When you do so -- even if all the type and <code>const</code> parameters
have defaults -- the behavior is the same as using type inference variables
(<code>_</code>) for <em>all</em> the parameters.</p>
<p>If you do not elide all non-lifetime parameters -- that is, if you specify one or
more type parameter or <code>const</code> parameter -- then you must specify all required
parameters. Or in other words: if you specify at least one type or <code>const</code>
parameter, you can only elide defaulted parameters (and lifetimes).</p>
<p>The behavior of elided defaulted parameters is as follows:</p>
<ul>
<li>If you specify zero non-lifetime parameters
<ul>
<li>Inference variables are used for <em>all</em> type and <code>const</code> parameters</li>
</ul>
</li>
<li>If you specify one or more non-lifetime parameters
<ul>
<li>Defaults are used for elided type and <code>const</code> parameters</li>
</ul>
</li>
</ul>
<p>Above, we phrased the different default parameter behavior for types in expressions in
terms of desugaring to <a href="misc-default-param.html#more-about-qualified-path-expressions">qualified type paths.</a>
However, the behavior applies in other contexts too, such as <code>struct</code> expression syntax:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Two&lt;T, U = String&gt; { t: T, u: U }

// This is ambiguous
let _ = Two { t: (), u: Default::default() };
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Two&lt;T, U = String&gt; { t: T, u: U }
</span>// But this works
let _ = Two::&lt;_&gt; { t: (), u: Default::default() };
<span class="boring">}</span></code></pre></pre>
<p>Qualified path types are not allowed in this postion, so not all of the
workarounds we discussed for paths are applicable.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct One&lt;T = String&gt; { t: T }

// Ambiguous
let _ = One { t: Default::default() };
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct One&lt;T = String&gt; { t: T }
</span>// Not accepted grammatically
let _ = &lt;One&gt; { t: Default::default() };
<span class="boring">}</span></code></pre></pre>
<p>Finally, there is no way to syntactically represent inferred but
non-defaulted <code>const</code> parameters in qualified path types (or any
other type-annotation-like position).</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Pixel&lt;const N: usize&gt;([u8; N]);
impl&lt;const N: usize&gt; Default for Pixel&lt;N&gt; {
    fn default() -&gt; Self {
        Self([0; N])
    }
}

// Works
let pixel = Pixel::default();

// These fail because `_` cannot be used for const parameters yet
// let pixel = &lt;Pixel&lt;_&gt;&gt;::default();
// let pixel: Pixel&lt;_&gt; = Default::default();

drive_inference(pixel);
fn drive_inference(_: Pixel&lt;3&gt;) {}
<span class="boring">}</span></code></pre></pre>
<h2 id="non-type-generic-parameters"><a class="header" href="#non-type-generic-parameters">Non-type generic parameters</a></h2>
<p>This guide has mostly concentrated on type parameters.  We've tried to
be careful with our wording throughout the guide, but let's take a moment
to talk specifically at how non-type parameters work with regards to
defaults.</p>
<h3 id="lifetime-parameters"><a class="header" href="#lifetime-parameters">Lifetime parameters</a></h3>
<p>Lifetime paramters can not be given defaults, and do not change any of the
default parameter behavior we've discussed.</p>
<p>I've tried to take care to use phrases like "specify one or mmore non-lifetime
parameter" instead of phrase like "empty parameter list".  But just to make
things more explicit: the inclusion or elision of lifetime parameters doesn't
change how parameter defaults work.</p>
<p>For example, the below are still cases of specifying no required parameters,
and thus uses an inference variable (which then fails as ambiguous).</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Foo2&lt;'a, T = String&gt; {
    Bar(&amp;'a T),
    Baz,
}

let foo = Foo2::&lt;'_&gt;::Bar;
let foo = Foo2::&lt;'static&gt;::Bar;
<span class="boring">}</span></code></pre></pre>
<h3 id="const-parameters"><a class="header" href="#const-parameters"><code>const</code> parameters</a></h3>
<p><a href="https://github.com/rust-lang/rust/pull/90207"><code>const</code> parameters defaults were stabilized in 1.59,</a>
along with the ability to intermix <code>const</code> and type parameters
in the parameter list (as otherwise the presence of a defaulted
type parameter would force all <code>const</code> parameters to also have
defaults, for example).</p>
<p>Generally speaking, defaulted <code>const</code> parameters act just like defaulted
type parameters.  However, one important difference is that
<a href="https://github.com/rust-lang/rust/issues/85077"><code>_</code> cannot be used for <code>const</code> parameters as of yet.</a></p>
<p>This does mean that some of the workarounds we've seen cannot be applied:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// We'll use this analogously to our `HashSet` examples
struct MyArray&lt;const N: usize, T = String&gt;([T; N]);

impl&lt;T: Default, const N: usize&gt; Default for MyArray&lt;N, T&gt; {
    fn default() -&gt; Self {
        Self(std::array::from_fn(|_| T::default()))
    }
}

// Ambiguous for the usual reasons
// let arr = MyArray::default();

// Here's what we did when `HashSet` had this problem.
// But it fails because we can't use `_` for the `const` parameter!
let arr = MyArray::&lt;_&gt;::default();

// Explicitness it is then
// let arr = MyArray::&lt;16&gt;::default();

// (These parts are just here to make everything above work like
// our `HashSet` examples worked.)
drive_inference_of_length(&amp;arr);
fn drive_inference_of_length&lt;T&gt;(_: &amp;MyArray&lt;16, T&gt;) {}
<span class="boring">}</span></code></pre></pre>
<h2 id="a-warning-about-implementations-and-function-arguments"><a class="header" href="#a-warning-about-implementations-and-function-arguments">A warning about implementations and function arguments</a></h2>
<p>Default type parameters work the same in implementation headers and
function argument lists as they do in other
"<a href="misc-default-param.html#type-position-mechanics-in-more-detail">type positions</a>".  This
may be surprising with compared to elided lifetime parameters.</p>
<p>In implementations and function argument lists, eliding a lifetime
parameter introduces a new, independent generic lifetime parameter.
But eliding a type parameter <em>never</em> means "introduce a new generic".
Elided type parameters always resolve to a single type (or error),
whether that type comes from inference or a default type.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Foo&lt;T = String&gt; { Bar(T), Baz }

// This is an implementation for `Foo&lt;String&gt;` only
impl Foo {
    fn papers_please(&amp;self) {}
}

// This is an implemenetation for all (`Sized`) `T`
impl&lt;T&gt; Foo&lt;T&gt; {
    fn welcome(&amp;self) {}
}

let foo = Foo::Bar(0);

// Works
foo.welcome();

// Fails
foo.papers_please();
<span class="boring">}</span></code></pre></pre>
<p>(Eliding lifetimes in other positions sometimes means <code>'static</code> and
sometimes means "infer this for me", but that's a topic for another
day.  Lifetime <em>parameters</em> cannot have defaults.)</p>
<h2 id="default-type-parameters-elsewhere"><a class="header" href="#default-type-parameters-elsewhere">Default type parameters elsewhere</a></h2>
<p>Declaring default parameters that are not on types, traits, or trait
aliases either results in an error, or fires a deny-by-default lint stating that
<a href="https://github.com/rust-lang/rust/issues/36887">support will be removed.</a></p>
<p>Despite the lint, default parameters on functions work the same as default
parameters on type declarations.  However, every function has a unique type
(a "function item type") which cannot be named.  Because the function item
type cannot be named, most of the workarounds we've talked about cannot be
applied.</p>
<p>That being said, the case where you use a turbofish with one or more
non-elided type parameter still works:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[allow(invalid_type_param_default)]
fn example&lt;X, Y: Default = String&gt;() -&gt; Y {
    Y::default()
}

let s = example::&lt;()&gt;();
println!("{}", std::any::type_name_of_val(&amp;s));
<span class="boring">}</span></code></pre></pre>
<p>Default parameters on <code>impl</code> headers do not serve any purpose as far as I'm
aware.  Implementations don't have names at all (which is why the parameters
are on the <code>impl</code> keyword).</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyStruct;
</span><span class="boring">trait WhyThough&lt;T, U&gt; { }
</span>#[allow(invalid_type_param_default)]
impl&lt;T = String&gt; WhyThough&lt;i32, T&gt; for MyStruct {}
<span class="boring">}</span></code></pre></pre>
<p>Default parameters on GATs are currently just denied, even if the lint is allowed.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span>#![allow(invalid_type_param_default)]
<span class="boring">fn main() {
</span>trait MyTrait {
    type Gat&lt;T = String&gt;;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-tour-of-dyn-trait-1"><a class="header" href="#a-tour-of-dyn-trait-1">A tour of <code>dyn Trait</code></a></h1>
<p>Rust's type-erasing <code>dyn Trait</code> offers a way to treat different implementors
of a trait in a homogenous fashion while remaining strictly and statically
(i.e. compile-time) typed.  For example: if you want a <code>Vec</code> of values which
implement your trait, but they might not all be the same base type, you need
type erasure so that you can create a <code>Vec&lt;Box&lt;dyn Trait&gt;&gt;</code> or similar.</p>
<p><code>dyn Trait</code> is also useful in some situations where generics are undesirable,
or to type erase unnameable types such as closures into something you need to
name (such as a field type, an associated type, or a trait method return type).</p>
<p>There is a lot to know about when and how <code>dyn Trait</code> works or does not, and
how this ties together with generics, lifetimes, and Rust's type system more
generally.  It is therefore not uncommon to get somewhat confused about
<code>dyn Trait</code> when learning Rust.</p>
<p>In this section we take a look at what <code>dyn Trait</code> is and is not, the limitations
around using it, how it relates to generics and opaque types, and more.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn-trait-overview"><a class="header" href="#dyn-trait-overview"><code>dyn Trait</code> Overview</a></h1>
<h2 id="what-is-dyn-trait"><a class="header" href="#what-is-dyn-trait">What is <code>dyn Trait</code>?</a></h2>
<p><code>dyn Trait</code> is a compiler-provided type which implements <code>Trait</code>.  Any <code>Sized</code> implementor
of <code>Trait</code> can be coerced to be a <code>dyn Trait</code>, erasing the original base type in the process.
Different implementations of <code>Trait</code> may have different sizes, and as a result, <code>dyn Trait</code>
has no statically known size.  That means it does not implement <code>Sized</code>, and we call such
types "unsized", or "dynamically sized types (DSTs)".</p>
<p>Every <code>dyn Trait</code> value is the result of type erasing some other existing value.
You cannot create a <code>dyn Trait</code> from a trait definition alone; there must be an
implementing base type that you can coerce.</p>
<p>Rust currently does not support passing unsized parameters, returning unsized values, or
having unsized locals.  Therefore, when interacting with <code>dyn Trait</code>, you will generally
be working with some sort of indirection: a <code>Box&lt;dyn Trait&gt;</code>, <code>&amp;dyn Trait</code>, <code>Arc&lt;dyn Trait&gt;</code>,
etc.</p>
<p>And in fact, the indirection is necessary for another reason.  These indirections are or
contain <em>wide pointers</em> to the erased type, which consist of a pointer to the value, and
a second pointer to a static <em>vtable</em>.  The vtable in turn contains data such as the size
of the value, a pointer to the value's destructor, pointers to methods of the <code>Trait</code>,
and so on.  The vtable <a href="./dyn-trait-impls.html">enables dynamic dispatch,</a> by which
different <code>dyn Trait</code> values can dispatch method calls to the different erased base type
implementations of <code>Trait</code>.</p>
<p><code>dyn Trait</code> is also called a "trait object".</p>
<p>You can also have objects such as <code>dyn Trait + Send + Sync</code>.  <code>Send</code> and <code>Sync</code> are
<a href="https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits">auto-traits,</a>
and a trait object can include any number of these auto traits as additional bounds.
Every distinct set of <code>Trait + AutoTraits</code> is a distinct type.</p>
<p>However, you can only have one <em>non</em>-auto trait in a trait object, so this will not
work:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait1 {}
trait Trait2 {};
struct S(Box&lt;dyn Trait1 + Trait2&gt;);
<span class="boring">}</span></code></pre></pre>
<p>That being noted, <a href="./dyn-trait-combining.html">one can usually use a subtrait/supertrait pattern</a>
to work around this restriction.</p>
<h3 id="the-trait-object-lifetime"><a class="header" href="#the-trait-object-lifetime">The trait object lifetime</a></h3>
<p>Confession: we were being imprecise when we said <code>dyn Trait</code> is a type.  <code>dyn Trait</code> is a
<em>type constructor</em>: <a href="./dyn-trait-lifetime.html">it is parameterized with a lifetime,</a>
similar to how references are.  So <code>dyn Trait</code> on it's own isn't a type,
<code>dyn Trait + 'a</code> for some concrete lifetime <code>'a</code> is a type.</p>
<p>The lifetime can usually be elided, <a href="./dyn-elision.html">which we will explore later.</a>
But it is always part of the type,
<a href="./st-types.html">just like a lifetime is part of every reference type,</a>
even when elided.</p>
<h3 id="associated-types"><a class="header" href="#associated-types">Associated Types</a></h3>
<p>If a trait has non-generic associated types, those associated types usually become
named parameters of <code>dyn Trait</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _: Box&lt;dyn Iterator&lt;Item = i32&gt;&gt; = Box::new([1, 2, 3].into_iter());
<span class="boring">}</span></code></pre></pre>
<p>We explore associated types in <code>dyn Trait</code> more
<a href="./dyn-trait-coercions.html#associated-types">in a later section.</a></p>
<h2 id="what-dyn-trait-is-not"><a class="header" href="#what-dyn-trait-is-not">What <code>dyn Trait</code> is <em>not</em></a></h2>
<h3 id="dyn-trait-is-not-sized"><a class="header" href="#dyn-trait-is-not-sized"><code>dyn Trait</code> is not <code>Sized</code></a></h3>
<p>We mentioned the fact that <code>dyn Trait</code> is not <code>Sized</code> already.</p>
<p>However, let us take a moment to note that generic parameters
<a href="https://doc.rust-lang.org/reference/special-types-and-traits.html#sized">have an implicit <code>Sized</code> bound.</a>
Therefore you may need to remove the implicit bound by using
<code>: ?Sized</code> in order to use <code>dyn Trait</code> in generic contexts.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span>// This function only takes `T: Sized`.  It cannot accept a
// `&amp;dyn Trait`, for example, as `dyn Trait` is not `Sized`.
fn foo&lt;T: Trait&gt;(_: &amp;T) {}

// This function takes any `T: Trait`, even if `T` is not
// `Sized`.
fn bar&lt;T: Trait + ?Sized&gt;(t: &amp;T) {
    // Demonstration that `foo` cannot accept non-`Sized`
    // types:
    foo(t);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="dyn-trait-is-neither-a-generic-nor-dynamically-typed"><a class="header" href="#dyn-trait-is-neither-a-generic-nor-dynamically-typed"><code>dyn Trait</code> is neither a generic nor dynamically typed</a></h3>
<p>Given a concrete lifetime <code>'a</code>, <code>dyn Trait + 'a</code> is a statically known type.
The <em>erased base type</em> is not statically known, but don't let this confuse
you: the <code>dyn Trait</code> itself is its own distinct type and that type is known
at compile time.</p>
<p>For example, consider these two function signatures:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span>fn generic&lt;T: Trait&gt;(_rt: &amp;T) {}
fn not_generic(_dt: &amp;dyn Trait) {}
<span class="boring">}</span></code></pre></pre>
<p>In the generic case, a distinct version of the function will exist for every
type <code>T</code> which is passed to the function.  This compile-time generation of
new functions for every type is known as monomorphization.  (Side note,
lifetimes are erased during compilation, and not monomorphized.)</p>
<p>You can even create function pointers to the different versions like so:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait Trait {}
</span><span class="boring">impl Trait for String {}
</span><span class="boring">fn generic&lt;T: Trait&gt;(_rt: &amp;T) {}
</span><span class="boring">fn main() {
</span>let fp = generic::&lt;String&gt;;
<span class="boring">}</span></code></pre></pre>
<p>That is, the function item type is parameterized by some <code>T: Trait</code>.</p>
<p>In contrast, there will always only be only one <code>non_generic</code> function in
the resulting library.  The base implementors of <code>Trait</code> must be typed-erased
into <code>dyn Trait + '_</code> before being passed to the function.  The function type
is not parameterized by a generic type.</p>
<p>Similarly, here:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span>fn generic&lt;T: Trait&gt;(bx: Box&lt;T&gt;) {}
<span class="boring">}</span></code></pre></pre>
<p><code>bx: Box&lt;T&gt;</code> is not a <code>Box&lt;dyn Trait&gt;</code>.  It is a thin owning pointer to a
heap allocated <code>T</code> specifically.  Because <code>T</code> has an implicit <code>Sized</code> bound
here, we could <em>coerce</em> <code>bx</code> to a <code>Box&lt;dyn Trait + '_&gt;</code>.  But that would be a
transformation to a different type of <code>Box</code>: a wide owning pointer which has
erased <code>T</code> and included the corresponding vtable pointer.</p>
<p>We'll explore more details on the interaction of generics and <code>dyn Trait</code>
<a href="./dyn-trait-vs.html">in a later section.</a></p>
<p>You may wonder why you can use the methods of <code>Trait</code> on a <code>&amp;dyn Trait</code> or
<code>Box&lt;dyn Trait&gt;</code>, etc., despite not declaring any such bound.  The reason is
analogous to why you can use <code>Display</code> methods on a <code>String</code> without declaring
that bound, say: the type is statically known, and the compiler recognizes that
<code>dyn Trait</code> implements <code>Trait</code>, just like it recognizes that <code>String</code>
implements <code>Display</code>.  Trait bounds are needed for generics, not concrete types.</p>
<p>(In fact, <a href="./dyn-trait-impls.html#boxdyn-trait-and-dyn-trait-do-not-automatically-implement-trait"><code>Box&lt;dyn Trait&gt;</code> doesn't implement <code>Trait</code> automatically,</a>
but deref coercion usually takes care of that case. For many <code>std</code> traits,
the trait is explicitly implemented for <code>Box&lt;dyn Trait&gt;</code> as well;
<a href="./dyn-trait-box-impl.html">we'll also explore what that can look like.</a>)</p>
<p>As a concrete type, you can also implement methods on <code>dyn Trait</code>
(provided <code>Trait</code> is local to your crate), and even implement <em>other</em>
traits for <code>dyn Trait</code>
(as we will see in <a href="./dyn-trait-examples.html">some of the examples</a>).</p>
<h3 id="dyn-trait-is-not-a-supertype"><a class="header" href="#dyn-trait-is-not-a-supertype"><code>dyn Trait</code> is not a supertype</a></h3>
<p>Because you can coerce base types into a <code>dyn Trait</code>, it is not uncommon for
people to think that <code>dyn Trait</code> is some sort of supertype over all the
coercible implementors of <code>Trait</code>.  The confusion is likely exacerbated by
trait bounds and lifetime bounds sharing the same syntax.</p>
<p>But the coercion from a base type to a <code>dyn Trait</code> is an unsizing coercion,
and not a sub-to-supertype conversion; the coercion happens at statically
known locations in your code, and may change the layout of the types
involved (e.g. changing a thin pointer into a wide pointer) as well.</p>
<p>Relatedly, <code>trait Trait</code> is not a class.  You cannot create a <code>dyn Trait</code>
without an implementing type (they do not have built-in constructors),
and a given type can implement a great many traits.  Due to the confusion it
can cause, I recommend not referring to base types as "instances" of the trait.
It is just a type that implements <code>Trait</code>, which exists independently of the
trait.  When I create a <code>String</code>, I'm creating a <code>String</code>, not "an instance
of <code>Display</code> (and <code>Debug</code> and <code>Write</code> and <code>ToString</code> and ...)".</p>
<p>When I read "an instance of <code>Trait</code>", I assume the variable in question is
some form of <code>dyn Trait</code>, and not some unerased base type that implements <code>Trait</code>.</p>
<p>Implementing something for <code>dyn Trait</code> does not implement it for all other
<code>T: Trait</code>.  In fact it implements it for nothing but <code>dyn Trait</code> itself.
Implementing something for <code>dyn Trait + Send</code> doesn't implement anything
for <code>dyn Trait</code> or vice-versa either; those are also separate, distinct types.</p>
<p>There are ways to <em>emulate</em> dynamic typing in Rust, <a href="./dyn-any.html">which we will explore later.</a>
We'll also explore the role of <a href="./dyn-trait-combining.html"><em>supertraits</em></a> (which, despite the
name, still do not define a sub/supertype relationship).</p>
<p>The <em>only</em> subtypes in Rust involve lifetimes and types which are
higher-ranked over lifetimes.</p>
<p><small>(Pedantic self-correction: trait objects have lifetimes and thus <a href="./dyn-covariance.html">are supertypes in that sense.</a> However that's not the same concept that most Rust learners get confused about; there is no supertype relationship with the implementing types.)</small></p>
<h3 id="dyn-trait-is-not-universally-applicable"><a class="header" href="#dyn-trait-is-not-universally-applicable"><code>dyn Trait</code> is not universally applicable</a></h3>
<p>We'll look at the details in their own sections, but in short, you cannot
always coerce an implementor of <code>Trait</code> into <code>dyn Trait</code>.  Both
<a href="./dyn-safety.html">the trait</a> and <a href="dyn-trait-coercions.html">the implementor</a>
must meet certain conditions.</p>
<h2 id="in-summary"><a class="header" href="#in-summary">In summary</a></h2>
<p><code>dyn Trait + 'a</code> is</p>
<ul>
<li>a concrete, statically known type</li>
<li>created by type erasing implementors of <code>Trait</code></li>
<li>used behind wide pointers to the type-erased value and to a static vtable</li>
<li>dynamically sized (unsized, does not implement <code>Sized</code>)</li>
<li>an implementor of <code>Trait</code> via dynamic dispatch</li>
<li><em>not</em> a supertype of all implementors</li>
<li><em>not</em> dynamically typed</li>
<li><em>not</em> a generic</li>
<li><em>not</em> creatable from all values</li>
<li><em>not</em> available for all traits</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn-trait-implementations"><a class="header" href="#dyn-trait-implementations"><code>dyn Trait</code> implementations</a></h1>
<p>In order for <code>dyn Trait</code> to be useful for abstracting over the base
types which implement <code>Trait</code>, <code>dyn Trait</code> itself needs to implement
<code>Trait</code>.  The compiler always supplies that implementation.  Here we
look at how this notionally works, and also touch on how this leads
to some related limitations around <code>dyn Trait</code>.</p>
<p>We also cover a few surprising corner-cases related to how the
implementation of <code>Trait</code> for <code>dyn Trait</code> works... or doesn't.</p>
<h2 id="how-dyn-trait-implements-trait"><a class="header" href="#how-dyn-trait-implements-trait">How <code>dyn Trait</code> implements <code>Trait</code></a></h2>
<p>Let us note upfront: this is a rough sketch, and not normative.  What the
compiler actually does is an implementation detail.  But by providing a
sketch of how it <em>could</em> be implemented, we hope to provide some intuition
for <code>dyn Trait</code> being a concrete type, and some explanation of the
limitations that <code>dyn Trait</code> has.</p>
<p>With that disclaimer out of the way, let's look at what the compiler
implementation might look like for this trait:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn look(&amp;self);
    fn add(&amp;mut self, s: String) -&gt; i32;
}
<span class="boring">}</span></code></pre></pre>
<p>Recall that when dealing with <code>dyn Trait</code>, you'll be dealing with
a pointer to the erased base type, and with a vtable.  For example,
we could imagine a <code>&amp;dyn Trait</code> looks something like this:</p>
<pre><code class="language-rust ignore">#[repr(C)]
struct DynTraitRef&lt;'a&gt; {
    _lifetime: PhantomData&lt;&amp;'a ()&gt;,
    base_type: *const (),
    vtable: &amp;'static DynTraitVtable,
}

// Pseudo-code
type &amp;'a dyn Trait = DynTraitRef&lt;'a&gt;;</code></pre>
<p>Here we're using a thin <code>*const ()</code> to point to the erased base type.
Similarly, you can imagine a <code>DynTraitMut&lt;'a&gt;</code> for <code>&amp;'a mut dyn Trait</code>
that uses <code>*mut ()</code>.</p>
<p>And the vtable might look something like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct DynTraitVtable {
    fn_drop: fn(*mut ()),
    type_size: usize,
    type_alignment: usize,
    fn_look: fn(*const ()),
    fn_add: fn(*mut (), s: String) -&gt; i32,
}
<span class="boring">}</span></code></pre></pre>
<p>And the implementation itself could look something like this:</p>
<pre><code class="language-rust ignore">impl Trait for dyn Trait + '_ {
    fn look(&amp;self) {
        (self.vtable.fn_look)(self.base_type)
    }
    fn add(&amp;mut self, s: String) -&gt; i32 {
        (self.vtable.fn_add)(self.base_type, s)
    }
}</code></pre>
<p>In summary, we've erased the base type by replacing references to the
base type with the appropriate type of pointer to the same data, both
in the wide references (<code>&amp;dyn Trait</code>, <code>&amp;mut dyn Trait</code>), and also in
the vtable function pointers.  The compiler guarantees there's no ABI
mismatch.</p>
<p><em>Reminder:</em> This is just a rough sketch on how <code>dyn Trait</code> can be
implemented to aid the high-level understanding and discussion, and
not necessary exactly how they <em>are</em> implemented.</p>
<p><a href="https://huonw.github.io/blog/2015/01/peeking-inside-trait-objects/">Here's another blog post on the topic.</a>
Note that it was written in 2015, and some things in Rust have changed
since that time.  For example, <a href="https://rust-lang.github.io/rfcs/2113-dyn-trait-syntax.html">trait objects used to be "spelled" just
<code>Trait</code> instead of <code>dyn Trait</code>.</a>
You'll have to figure out if they're talking about the trait or the
<code>dyn Trait</code> type from context.</p>
<h2 id="other-receivers"><a class="header" href="#other-receivers">Other receivers</a></h2>
<p>Let's look at one other function signature:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn eat_box(self: Box&lt;Self&gt;);
}
<span class="boring">}</span></code></pre></pre>
<p>How does this work?  Internally, a <code>Box&lt;BaseType /* : Sized */&gt;</code> is
a thin pointer, while a <code>Box&lt;dyn Trait&gt;</code> is wide pointer, very similar
to <code>&amp;mut dyn Trait</code> for example (although the <code>Box</code> pointer implies ownership and
not just exclusivity).  The implementation for this method would be
similar to that of <code>&amp;mut dyn Trait</code> as well:</p>
<pre><code class="language-rust ignore">// Still just for illustrative purpose
impl Trait for dyn Trait + '_ {
    fn eat_box(self: Box&lt;Self&gt;) {
        let BoxRepresentation { base_type, vtable } = self;
        let boxed_type = Box::from_raw(base_type);
        (vtable.fn_eat_box)(boxed_type);
    }
}</code></pre>
<p>In short, the compiler knows how to go from the type-erased form
(like <code>Box&lt;Self&gt;</code>) into something ABI compatible for the base type
(<code>Box&lt;BaseType&gt;</code>) for every supported receiver type.</p>
<p>It's an implementation detail, but currently the way the compiler
knows how to do the conversion is via the
<a href="https://doc.rust-lang.org/std/ops/trait.DispatchFromDyn.html"><code>DispatchFromDyn</code></a>
trait.  The documentation lists the current limitations of supported
types (some of which are only available under the unstable
<a href="https://github.com/rust-lang/rust/issues/44874"><code>arbitrary_self_types</code> feature</a>).</p>
<h2 id="supertraits-are-also-implemented"><a class="header" href="#supertraits-are-also-implemented">Supertraits are also implemented</a></h2>
<p><a href="./dyn-trait-combining.html">We'll look at supertraits in more detail later,</a> but
here we'll briefly note that when you have a supertrait:</p>
<pre><code>trait SuperTrait { /* ... */ }
trait Trait: SuperTrait { /* ... */ }
</code></pre>
<p>The vtable for <code>dyn Trait</code> includes the methods of <code>SuperTrait</code> and the compiler
supplies an implementation of <code>SuperTrait</code> for <code>dyn Trait</code>, just as it supplies
an implementation of <code>Trait</code>.</p>
<h2 id="boxdyn-trait-and-dyn-trait-do-not-automatically-implement-trait"><a class="header" href="#boxdyn-trait-and-dyn-trait-do-not-automatically-implement-trait"><code>Box&lt;dyn Trait&gt;</code> and <code>&amp;dyn Trait</code> do not automatically implement <code>Trait</code></a></h2>
<p>It may come as a surprise that neither <code>Box&lt;dyn Trait&gt;</code> nor
<code>&amp;dyn Trait</code> automatically implement <code>Trait</code>.  Why not?</p>
<p>In short, because it's not always possible.</p>
<p><a href="dyn-safety.html#the-sized-constraints">As we'll cover later,</a> a trait
may have methods which are not dispatchable by <code>dyn Trait</code>, but must
be implemented for any <code>Sized</code> type. One example is associated
functions that have no receiver:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn no_receiver() -&gt; String where Self: Sized;
}
<span class="boring">}</span></code></pre></pre>
<p>There's no way for the compiler to generate the body of such an associated
function, and it can't provide a complete <code>Trait</code> implementation without
one.</p>
<p>Additionally, the receivers of dispatchable methods don't always make
sense:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn takes_mut(&amp;mut self);
}
<span class="boring">}</span></code></pre></pre>
<p>A <code>&amp;dyn Trait</code> can produce a <code>&amp;BaseType</code>, but not a <code>&amp;mut BaseType</code>, so
there is no way to implement <code>Trait::takes_mut</code> for <code>&amp;dyn Trait</code> when
the only pre-existing implementation is for <code>BaseType</code>.</p>
<p>Similarly, an <code>Arc&lt;dyn Trait&gt;</code> has no way to call a <code>Box&lt;dyn Trait&gt;</code>
or vice-versa, and so on.</p>
<h3 id="implementing-these-yourself"><a class="header" href="#implementing-these-yourself">Implementing these yourself</a></h3>
<p>If <code>Trait</code> is a local trait, you can implement it for <code>Box&lt;dyn Trait + '_&gt;</code>
and so on just like you would for any other type.  Take care though, as it
can be easy to accidentally write a recursive definition!</p>
<p><a href="./dyn-trait-box-impl.html">We walk through an example of this later on.</a></p>
<p>Moreover, <code>&amp;T</code>, <code>&amp;mut T</code>, and <code>Box&lt;T&gt;</code> are
<a href="https://rust-lang.github.io/rfcs/2451-re-rebalancing-coherence.html#definitions"><em>fundamental</em>,</a>
which means that when it comes to the orphan rules (which gate which trait
implementations you can write), they act the same as <code>T</code>.  Additionally,
if <code>Trait</code> is a local trait, then <code>dyn Trait + '_</code> is a local type.</p>
<p>Together that means that <em>you can even implement <strong>other</strong> traits</em> for
<code>Box&lt;dyn Trait + '_&gt;</code> (and other fundamental wrappers)!</p>
<p><a href="dyn-trait-clone.html">We also have an example of this later on.</a></p>
<p>Unfortunately, <code>Rc</code>, <code>Arc</code>, and so on are not fundamental, so this doesn't
cover every possible use case.</p>
<h2 id="the-implementation-cannot-be-directly-overrode"><a class="header" href="#the-implementation-cannot-be-directly-overrode">The implementation cannot be directly overrode</a></h2>
<p>The compiler provided implementation of <code>Trait</code> for <code>dyn Trait</code> cannot be
overrode by an implementation in your code.  If you attempt to define your
own definition directly, you'll get a compiler error:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}
impl Trait for dyn Trait + '_ {}
<span class="boring">}</span></code></pre></pre>
<p>And if you have a blanket implementation to implement <code>Trait</code> and <code>dyn Trait</code>
happens to meet the bounds on the implementation, it will be ignored and the
compiler defined implementation will still be used:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::any::type_name;
</span><span class="boring">
</span>trait Trait {
    fn hi(&amp;self) {
        println!("Hi from {}!", type_name::&lt;Self&gt;());
    }
}

// The simplest example is an implementation for absolutely everything
impl&lt;T: ?Sized&gt; Trait for T {}

let dt: &amp;dyn Trait = &amp;();
// Prints "Hi from ()!" and not "Hi from dyn Trait!"
dt.hi();
// Same thing
&lt;dyn Trait as Trait&gt;::hi(dt);
<span class="boring">}</span></code></pre></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=66a0de00d42d915134f206ee73291136">This even applies with more complicated implementations,</a>
and applies to the supertrait implementations for <code>dyn Trait</code> as well.</p>
<p><a href="./dyn-trait-erased.html">We'll see that this can be useful later.</a>  But
unfortunately, <a href="https://github.com/rust-lang/rust/issues/57893#issuecomment-510690333">there are some compiler bugs around the compiler
implementation taking precedence over your blanket implementations.</a>
How those bugs are dealt with is yet to be determined; it's possible
that certain blanket implementations will be disallowed, or that
some traits will no longer be <code>dyn</code>-safe.  (The <em>general</em> pattern,
such as the simple example above, is almost surely too widespread
to be deprecated.)</p>
<h2 id="the-implementation-cannot-be-indirectly-bypassed"><a class="header" href="#the-implementation-cannot-be-indirectly-bypassed">The implementation cannot be indirectly bypassed</a></h2>
<p>You may be aware that when a concrete type has an inherent method with
the same name and receiver as a trait method, the inherent method takes
precedence when performing method lookup:</p>
<pre><pre class="playground"><code class="language-rust edition2021">trait Trait { fn method(&amp;self) { println!("In trait Trait"); } }

struct S;
impl Trait for S {}
impl S { fn method(&amp;self) { println!("In impl S"); } }

fn main() {
    let s = S;
    s.method();
    // If you wanted to use the trait, you can do this
    &lt;S as Trait&gt;::method(&amp;s);
}</code></pre></pre>
<p>Unfortunately, this functionality is not available for <code>dyn Trait</code>.
You can write the implementation, but unlike the example above, they
will be considered ambiguous with the trait methods:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn method(&amp;self) {}
    fn non_dyn_dispatchable(&amp;self) where Self: Sized {}
}

impl dyn Trait + '_ {
    fn method(&amp;self) {}
    fn non_dyn_dispatchable(&amp;self) {}
}

fn foo(d: &amp;dyn Trait) {
    d.method();
    d.non_dyn_dispatchable();
}
<span class="boring">}</span></code></pre></pre>
<p>Moreover, there is no syntax to call the inherent methods specifically
like there is for normal <code>struct</code>s.
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6f55d2ebb8b44349034fc4df120e152f">Even if you try to hide the trait,</a>
the inherent methods are unreachable, dead code.</p>
<p>Apparently the idea is that the trait methods "are" the inherent methods of
<code>dyn Trait</code>, but this is rather unfortunate as it prevents directly providing
something like the <code>non_dyn_dispatchable</code> override attempted above.
See <a href="https://github.com/rust-lang/rust/issues/51402">issue 51402</a> for more
information.</p>
<p>Implementing methods on <code>dyn Trait</code> that don't attempt to shadow the
methods of <code>Trait</code> does work, however.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span>impl dyn Trait + '_ {
    fn some_other_method(&amp;self) {}
}

fn bar(d: &amp;dyn Trait) {
    d.some_other_method();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="a-niche-exception-to-dyn-trait-trait"><a class="header" href="#a-niche-exception-to-dyn-trait-trait">A niche exception to <code>dyn Trait: Trait</code></a></h2>
<p>Some bounds on traits aren't checked until you try to utilize the trait,
even when the trait is considered object safe.  As a result, <a href="https://github.com/rust-lang/rust/issues/88904">it is
actually sometimes possible to create a <code>dyn Trait</code> that does not implement
<code>Trait</code>!</a></p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterable
where
    for&lt;'a&gt; &amp;'a Self: IntoIterator&lt;
        Item = &amp;'a &lt;Self as Iterable&gt;::Borrow,
    &gt;,
{
    type Borrow;
    fn iter(&amp;self) -&gt; Box&lt;dyn Iterator&lt;Item = &amp;Self::Borrow&gt; + '_&gt; {
        Box::new(self.into_iter())
    }
}

impl&lt;I: ?Sized, Borrow&gt; Iterable for I
where
    for&lt;'a&gt; &amp;'a Self: IntoIterator&lt;Item = &amp;'a Borrow&gt;,
{
    type Borrow = Borrow;
}

fn example(v: Vec&lt;String&gt;) {
    // This compiles, demonstrating that we can create `dyn Iterable`
    // (i.e. the trait is object safe and `v` can be coerced)
    let dt: &amp;dyn Iterable&lt;Borrow = String&gt; = &amp;v;

    // But this gives an error as `&amp;dyn Iterable` doesn't meet the trait
    // bound, and thus `dyn Iterable` does not implement `Iterable`!
    for item in dt.iter() {
        println!("{item}");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>With this particular example, <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=7b897bcb453c6d8b7b8e3461f70db7a6">it's possible to provide an implementation such that
<code>dyn Iterable</code> meets the bounds.</a>
If that's not possible, you probably need to drop the bound or give up
on the trait being <code>dyn</code>-safe.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn-trait-coercions"><a class="header" href="#dyn-trait-coercions"><code>dyn Trait</code> coercions</a></h1>
<p>Some <code>dyn Trait</code> coercions which are typical (in terms of what is being coerced) look like so:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">trait Trait {}
</span>fn coerce_ref&lt;'a, T: Trait + Sized + 'a&gt;(t:    &amp;T ) -&gt; &amp;(  dyn Trait + 'a) { t }
fn coerce_box&lt;'a, T: Trait + Sized + 'a&gt;(t: Box&lt;T&gt;) -&gt; Box&lt;dyn Trait + 'a&gt; { t }
fn coerce_arc&lt;'a, T: Trait + Sized + 'a&gt;(t: Arc&lt;T&gt;) -&gt; Arc&lt;dyn Trait + 'a&gt; { t }
// etc
<span class="boring">}</span></code></pre></pre>
<p>These are more <em>syntactically noisy</em> than you will typically see in practice, as
I have included some explicit lifetimes and bounds which are normally implied
or not used.  For example the <code>Sized</code> bound on generic type parameters
<a href="https://doc.rust-lang.org/reference/special-types-and-traits.html#sized">is usually implied,</a>
but I've made it explicit to emphasize that we're talking about <code>Sized</code> base types.</p>
<p>The key point is that given an <a href="dyn-safety.html">object safe <code>Trait</code>,</a> and when
<code>T: 'a + Trait + Sized</code>, you can coerce a <code>Ptr&lt;T&gt;</code> to a <code>Ptr&lt;dyn Trait + 'a&gt;</code>
for the supported <code>Ptr</code> pointer types such as <code>&amp;_</code> and <code>Box&lt;_&gt;</code>.</p>
<p>If we had wanted a <code>dyn Trait + Send + 'a</code>, naturally we would need <code>T: Send</code>
as well, and similarly for any other auto trait.</p>
<p>In the rest of this section, we look at cases beyond these typical examples,
as well as some limitations of coercions.</p>
<h2 id="associated-types-1"><a class="header" href="#associated-types-1">Associated types</a></h2>
<p>When a trait has one or more non-generic associated type, every concrete implementor of
the trait chooses a single, statically-known type for each associated type.  For base
types, this means the associated types are "outputs" of the implementing type and the
implemented trait: if you know the latter two, you can statically determine the
associated types as well.</p>
<p>So what should the associated types be in the implementation of <code>Trait</code> for
<code>dyn Trait</code>?</p>
<p>There is no single answer; they would need to vary based on the erased base types.</p>
<p>However, <code>dyn Trait</code> for traits with associated types is just too useful to
make traits with associated types ineligible for <code>dyn Trait</code>.  Instead, associated
types in the trait become, in essence, named <em>type parameters</em> of the <code>dyn Trait</code>
type constructor. (Recall it's already a type constructor due to the trait object lifetime.)</p>
<p>So given</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>We have</p>
<pre><code class="language-rust ignore">dyn Iterator&lt;Item = String&gt; + '_
dyn Iterator&lt;Item = i32&gt; + '_
dyn Iterator&lt;Item = f64&gt; + '_</code></pre>
<p>and so on.  The associated types in <code>dyn Trait&lt;...&gt;</code> must be resolved to
concrete types in order for the <code>dyn Trait&lt;...&gt;</code> to be a concrete type.</p>
<p>Naturally, you can only coerce to <code>dyn Iterator&lt;Item = String&gt;</code> if you
both implement <code>Iterator</code>, and in your implementation, <code>type Item = String</code>.
The syntax mirrors that of associated type trait bounds:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_string_iter&lt;Iter&gt;(i: Iter)
where
    Iter: Iterator&lt;Item = String&gt;,
{
   // ...
}
<span class="boring">}</span></code></pre></pre>
<p>The parameters being named has a number of benefits.  For one, it's
usually quite relevant, such as what <code>Item</code> an <code>Iterator</code> returns
(especially if the associated types are well named).  It also removes
the need to order the associated types in a well-defined way, such as
lexicographically or especially declaration order (which would be too fragile).</p>
<p>The named parameters must be specified after all ordered parameters, however.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait AssocAndParams&lt;T, U&gt; { type Assoc1; type Assoc2; }

// The trait's ordered type parameters must be in declaration order
// (here, `String` then `usize`).  After that come the named associated
// type parameters, which can be reordered arbitrary amongst themselves.
fn foo(d: Box&lt;dyn AssocAndParams&lt;String, usize, Assoc1 = i32, Assoc2 = u32&gt;&gt;)
-&gt;
    Box&lt;dyn AssocAndParams&lt;String, usize, Assoc2 = u32, Assoc1 = i32&gt;&gt;
{
   d
}
<span class="boring">}</span></code></pre></pre>
<h3 id="opting-out-of-dyn-usability"><a class="header" href="#opting-out-of-dyn-usability">Opting out of <code>dyn</code>-usability</a></h3>
<p><a href="https://github.com/rust-lang/rust/pull/112319/">As of Rust 1.72,</a> if you add
a <code>where Self: Sized</code> bound to an associated type, it is considered
<a href="dyn-safety.html#the-sized-constraints">non-<code>dyn</code>-usable.</a>  The associated type
becomes unusable by <code>dyn Trait</code>, and you no longer need to constrain the
associated type with the named parameter.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    type Foo where Self: Sized;
    fn foo(&amp;self) -&gt; Self::Foo where Self: Sized;
    fn bar(&amp;self) {}
}

impl Trait for i32 {
    type Foo = ();
    fn foo(&amp;self) -&gt; Self::Foo {}
}

impl Trait for u64 {
    type Foo = f32;
    fn foo(&amp;self) -&gt; Self::Foo { 0.0 }
}

// No need for `dyn Trait&lt;Foo = ()&gt;`!
let mut a: &amp;dyn Trait = &amp;0_i32;

// No need for associated type equality between base types!
a = &amp;0_u64;

// This fails because the type is not defined (`dyn Trait` is not `Sized`)
// let _: &lt;dyn Trait as Trait&gt;::Foo = todo!();
<span class="boring">}</span></code></pre></pre>
<p>Although it produces is awarning, you can still <em>optionally</em> specify the
associated type, even though it's not usable by the <code>dyn Trait</code> itself.
Note also that this does result in incompatible types and limits the
possible coercions:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {
</span><span class="boring">   type Foo where Self: Sized;
</span><span class="boring">   fn foo(&amp;self) -&gt; Self::Foo where Self: Sized;
</span><span class="boring">   fn bar(&amp;self) {}
</span><span class="boring">}
</span><span class="boring">impl Trait for i32 {
</span><span class="boring">   type Foo = ();
</span><span class="boring">   fn foo(&amp;self) -&gt; Self::Foo {}
</span><span class="boring">}
</span><span class="boring">impl Trait for u64 {
</span><span class="boring">   type Foo = f32;
</span><span class="boring">   fn foo(&amp;self) -&gt; Self::Foo { 0.0 }
</span><span class="boring">}
</span>let mut a: &amp;dyn Trait&lt;Foo = ()&gt; = &amp;0_i32;

// Fails!
a = &amp;0_u64;
<span class="boring">}</span></code></pre></pre>
<p>This introduces some interesting possibilities around
<a href="dyn-trait-box-impl.html">implementing <code>trait</code> for <code>Box&lt;dyn Trait&gt;</code>:</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {
</span><span class="boring">   type Foo where Self: Sized;
</span><span class="boring">   fn foo(&amp;self) -&gt; Self::Foo where Self: Sized;
</span><span class="boring">   fn bar(&amp;self) {}
</span><span class="boring">}
</span><span class="boring">impl Trait for i32 {
</span><span class="boring">   type Foo = ();
</span><span class="boring">   fn foo(&amp;self) -&gt; Self::Foo {}
</span><span class="boring">}
</span><span class="boring">impl Trait for u64 {
</span><span class="boring">   type Foo = f32;
</span><span class="boring">   fn foo(&amp;self) -&gt; Self::Foo { 0.0 }
</span><span class="boring">}
</span>impl&lt;T: Default&gt; Trait for Box&lt;dyn Trait&lt;Foo = T&gt;&gt; {
    type Foo = T;
    fn foo(&amp;self) -&gt; Self::Foo {
        T::default()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The warning currently says "while the associated type can be specified, it cannot
be used in any way," but this example shows that is not technically true.  I think
this sort of usage was just not anticipated.</p>
<p>The reason it's not an error to specify non-<code>dyn</code>-usable associated types in this
manner is that there was a period where you could add <code>Self: Sized</code> bounds to
associated types, but were still <em>required</em> to name the associated type in
<code>dyn Trait&lt;..&gt;</code>.  Thus it would be a breaking change to make the warning an error.</p>
<p>Given the potential utility, I would argue that the warning should at a minimum
be reworded, and perhaps renamed.</p>
<h2 id="no-nested-coercions"><a class="header" href="#no-nested-coercions">No nested coercions</a></h2>
<p>An unsizing coercion needs to happen behind a layer of indirection (such as a
reference or in a <code>Box</code>) in order to accomodate the wide pointer to the erased
type's vtable (and because moving unsized types is not supported).</p>
<p>However, the unsizing coercion can only happen behind a <em>single</em> layer of
indirection.  For example, you can't coerce a <code>Vec&lt;Box&lt;T&gt;&gt;</code> to a <code>Vec&lt;Box&lt;dyn Trait&gt;&gt;</code>.
Why not?  <code>Box&lt;T&gt;</code> and <code>Box&lt;dyn Trait&gt;</code> have different layouts!  The former
is the size of one pointer, while the second is the size of two pointers.
The entire <code>Vec</code> would need to be reallocated to accomodate such a change:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span>fn convert_vec&lt;'a, T: Trait + 'a&gt;(v: Vec&lt;Box&lt;T&gt;&gt;) -&gt; Vec&lt;Box&lt;dyn Trait + 'a&gt;&gt; {
    v.into_iter().map(|bx| bx as _).collect()
}
<span class="boring">}</span></code></pre></pre>
<p>In general, unsizing coercions consume the original pointer (reference, <code>Box</code>,
etc) and produce a new one, and this cannot happen in a nested context.</p>
<p>Internally, which coercions are possible are determined by the
<a href="https://doc.rust-lang.org/std/ops/trait.CoerceUnsized.html"><code>CoerceUnsized</code></a>
trait, and the (compiler-implemented) <code>Unsize</code> trait, as discussed in the
documentation.</p>
<h3 id="except-when-you-can"><a class="header" href="#except-when-you-can">Except when you can</a></h3>
<p>There are some material and some apparent exceptions where unsizing coercion
can occur in a nested context.</p>
<p>If you follow the link above, you'll see that <a href="https://doc.rust-lang.org/std/ops/trait.CoerceUnsized.html#impl-CoerceUnsized%3CCell%3CU%3E%3E-for-Cell%3CT%3E">some types such as <code>Cell</code>
implement <code>CoerceUnsized</code> in a recursive manner.</a>
The idea is that <code>Cell</code> and the others have the same layout as their
generic type parameter.  As a result, outer layers of <code>Cell</code> don't count
as "nesting".</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">trait Trait {}
</span>// Fails :-(
//fn coerce_vec&lt;'a, T: Trait + 'a&gt;(v: Vec&lt;Box&lt;T&gt;&gt;) -&gt; Vec&lt;Box&lt;dyn Trait + 'a&gt;&gt; {
//    v
//}

// Works! :-)
fn coerce_cell&lt;'a, T: Trait + 'a&gt;(c: Cell&lt;Box&lt;T&gt;&gt;) -&gt; Cell&lt;Box&lt;dyn Trait + 'a&gt;&gt; {
    c
}
<span class="boring">}</span></code></pre></pre>
<p>We'll cover the apparent exceptions (which are actually just supertype
coercions) <a href="./dyn-covariance.html#variance-in-nested-context">in an upcoming section.</a></p>
<h2 id="the-sized-limitation"><a class="header" href="#the-sized-limitation">The <code>Sized</code> limitation</a></h2>
<p>Base types must meet a <code>Sized</code> bound in order to be able to be coerced to
<code>dyn Trait</code>.  For example, <code>&amp;str</code> cannot be coerced to <code>&amp;dyn Display</code>
even though <code>str</code> implements <code>Display</code>, because <code>str</code> is unsized.</p>
<p>Why is this limitation in place?  <code>&amp;str</code> is also a wide pointer; it consists
of a pointer to the UTF8 bytes, and a <code>usize</code> which is the number of bytes.
Similarly a slice reference <code>&amp;[T]</code> is a pointer to the contiguous data, and
a count of the number of items.</p>
<p>A <code>&amp;dyn Trait</code> created from a <code>&amp;str</code> or <code>&amp;[T]</code> would thus naively need to be
a "super-wide pointer", with a pointer to the data, the element count, <em>and</em>
the vtable pointer.  But <code>&amp;dyn Trait</code> is a concrete type with a static layout
-- two pointers -- so this naive approach can't work.  Moreover, what if I
wanted to coerce a super-wide pointer?  Each recursive coercion requires
another pointer, making the size unbounded.</p>
<p>A non-naive approach would require special-casing how dynamic dispatch
works for erased non-<code>Sized</code> base types.  For example, once you've type
erased <code>str</code>, you've lost the information that <code>&amp;str</code> is also a wide pointer,
and how to create that wide pointer.  However, the code would need to recreate
a wide pointer in order to perform dynamic dispatch.</p>
<p>So for <code>dyn Trait</code> to non-naively support unsized types, it would need
to examine at run-time how to construct a pointer to the erased base type:
one possibility for thin pointers, and an additional possibility for each type
of wide pointer supported.  Not only that, but the metadata required (such as
the length of the <code>str</code>) has to be stored <em>somewhere</em>, and that can't be in
static memory like the vtable is.</p>
<p>Instead, unsized base types are simply not supported.</p>
<p>Sometimes you can work around the limitation by, for example, implementing
the trait for <code>&amp;str</code> instead of <code>str</code>, and then coercing a <code>&amp;'_ str</code> to
<code>dyn Trait + '_</code> (since references are always <code>Sized</code>).</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span>// This fails as we cannot coerce `str` to `dyn Display`, so we cannot coerce
// `&amp;str` to `&amp;dyn Display`.
// let _: &amp;dyn Display = "hi";

// However, `&amp;str` also implements `Display`.  (If `T: Display`, then `&amp;T: Display`.)
// Because `&amp;str` is `Sized`, we can instead coerce `&amp;&amp;str` to `&amp;dyn Display`:
let _: &amp;dyn Display = &amp;"hi";
<span class="boring">}</span></code></pre></pre>
<p><code>Sized</code> is also used as a sort of "not-<code>dyn</code>" marker,
<a href="dyn-safety.html#the-sized-constraints">which we explore later.</a></p>
<p>There is one broad exception to the <code>Sized</code> limitation: coercing between
forms of <code>dyn Trait</code> itself, which we look at immediately below.</p>
<h2 id="discarding-auto-traits"><a class="header" href="#discarding-auto-traits">Discarding auto traits</a></h2>
<p>You can coerce a <code>dyn Trait + Send</code> to a <code>dyn Trait</code>, and similarly discard
any other auto trait.</p>
<p>Although
<a href="./dyn-trait-overview.html#dyn-trait-is-not-a-supertype"><code>dyn Trait</code> isn't a supertype of <code>dyn Trait + Send</code>,</a>
this is nonetheless referred to as <em>upcasting</em> <code>dyn Trait + Send</code> to <code>dyn Trait</code>.</p>
<p>Note that auto traits have no methods, and thus no change to the vtable is
required for these coercions.  They allow one to call a less restricted
function (that takes <code>dyn Trait</code>) from a more restrictive one (e.g. one that
requires <code>dyn Trait + Send</code>).  The coercion is necessary as, again, these are
(distinct) concrete types, and not generics nor subtypes nor dynamic types.</p>
<p>Although no change to the vtable is required, this coercion can still
<a href="dyn-trait-coercions.html#no-nested-coercions">not happen in a nested context.</a></p>
<h2 id="the-reflexive-case"><a class="header" href="#the-reflexive-case">The reflexive case</a></h2>
<p>You can cast <code>dyn Trait</code> to <code>dyn Trait</code>.</p>
<p>Sorry, we're being too imprecise again.  You can cast a <code>dyn Trait + 'a</code> to a <code>dyn Trait + 'b</code>,
where <code>'a: 'b</code>.  This is important for
<a href="./dyn-covariance.html#unsizing-coercions-in-invariant-context">how borrowing works with <code>dyn Trait + '_</code>.</a></p>
<p>As lifetimes are erased during compilation, the vtable is the same regardless of the lifetime.
Despite that, this unsizing coercion can still <a href="dyn-trait-coercions.html#no-nested-coercions">not happen in a nested context.</a></p>
<p>However, <a href="./dyn-covariance.html">in a future section</a> we'll see
how variance can allow shortening the trait object lifetime even in nested context,
provided that context is also covariant.  <a href="./dyn-hr.html">The section after that about higher-ranked
types</a> explores another lifetime-related coercion which could also be
considered reflexive.</p>
<h2 id="supertrait-upcasting"><a class="header" href="#supertrait-upcasting">Supertrait upcasting</a></h2>
<p>Though not supported on stable yet,
<a href="https://github.com/rust-lang/rust/issues/65991">the ability to upcast from <code>dyn SubTrait</code> to <code>dyn SuperTrait</code></a>
is a feature expected to be available some day.</p>
<p>It is, once again, explicitly a coercion and not a sub/super type relationship
(despite the terminology).  Although this is an implementation detail, the
conversion will probably involve replacing the vtable pointer (in contrast
with the last couple of examples).</p>
<p>Until the feature is stable,
<a href="./dyn-trait-combining.html#manual-supertrait-upcasting">you can write your own "manual" supertrait upcasts.</a></p>
<h2 id="object-safe-traits-only"><a class="header" href="#object-safe-traits-only">Object-safe traits only</a></h2>
<p>There are other restrictions on the <em>trait</em> which we have not discussed here,
such as not (yet) supporting traits with generic associated types (GATs).
<a href="dyn-safety.html">We cover those in the next section.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn-safety-object-safety"><a class="header" href="#dyn-safety-object-safety"><code>dyn</code> safety (object safety)</a></h1>
<p>There exists traits for which you cannot create a <code>dyn Trait</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::new();
let d: &amp;dyn Clone = &amp;s;
<span class="boring">}</span></code></pre></pre>
<p>Instead of repeating all the rules here,
<a href="https://doc.rust-lang.org/reference/items/traits.html#object-safety">I'll just link to the reference.</a>
You should go read that first.</p>
<p>Note that as of this writing, the reference hasn't been updated to document that you
can opt to make associated types and <abbr title="generic associated types">GATs</abbr>
unavailable to trait objects by adding a <code>where Self: Sized</code> bound.  For now I'll
refer to this as opting the GAT (or associated type) out of being "<code>dyn</code>-usable".</p>
<p>What may not be immediately apparent is <em>why</em> these limitations exists.
The rest of this page explores some of the reasons.</p>
<h2 id="the-sized-constraints"><a class="header" href="#the-sized-constraints">The <code>Sized</code> constraints</a></h2>
<p>Before we get into the restrictions, let's have an aside about how the
<code>Sized</code> constraints work with <code>dyn Trait</code> and <code>dyn</code> safety.</p>
<p>Rust uses <code>Sized</code> to indicate that</p>
<ul>
<li>A trait is not <code>dyn</code> safe</li>
<li>An associated type or <abbr title="generic associated type">GAT</abbr> is not <code>dyn</code>-usable</li>
<li>A method is not <code>dyn</code>-dispatchable</li>
<li>An associated function is not callable for <code>dyn Trait</code>
<ul>
<li>Even though it never can be (so far), you have to declare this for the sake of being explicit and for potential forwards compatibility</li>
</ul>
</li>
</ul>
<p>This makes some sense, as <code>dyn Trait</code> is not <code>Sized</code>.  So a <code>dyn Trait</code>
cannot implement a trait with <code>Sized</code> as a supertrait, and a <code>dyn Trait</code>
can't call methods (or associated functions) that require <code>Sized</code> either.</p>
<p>However, it's still a hack as there are types which are not <code>Sized</code> but also
not <code>dyn Trait</code>, and we might want to implement our trait for those, <em>including</em>
some methods which are not <code>dyn</code>-dispatchable (such as generic methods).
Currently that's just not possible in Rust (the non-<code>dyn</code>-dispatchable methods
will also not be available for other unsized types).</p>
<p>The next few paragraphs demonstrate (or perhaps rant about) how this can be an annoying limitation.
If you'd rather get on with learning practical Rust, <a href="dyn-safety.html#receiver-limitations">you may want to skip ahead 🙂.</a></p>
<p>Consider this example, where we've added a <code>Sized</code> bound in order to remain a <code>dyn</code>-safe trait:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Bound&lt;T: ?Sized&gt; {}
</span>trait Trait {
    // Opt-out of `dyn`-dispatchability for this method because it's generic
    fn method&lt;T: Bound&lt;Self&gt;&gt;(&amp;self) where Self: Sized;
}
<span class="boring">}</span></code></pre></pre>
<p>If you try to implement this trait for <code>str</code>, you won't have <code>method</code>
available, even if it would logically make sense to have it available.
Moreover, if you write the implementation like so:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Bound&lt;T: ?Sized&gt; {}
</span><span class="boring">trait Trait {
</span><span class="boring">   fn method&lt;T: Bound&lt;Self&gt;&gt;(&amp;self) where Self: Sized;
</span><span class="boring">}
</span>impl Trait for str {
    // `Self: Sized` isn't true, so don't bother with `method`
}
<span class="boring">}</span></code></pre></pre>
<p>You get an error saying you must provide <code>method</code>, even though the
bounds cannot be satisfied.  So then you can provide a perfectly
functional implementation:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Bound&lt;T: ?Sized&gt; {}
</span><span class="boring">trait Trait {
</span><span class="boring">   fn method&lt;T: Bound&lt;Self&gt;&gt;(&amp;self) where Self: Sized;
</span><span class="boring">}
</span>impl Trait for str {
    fn method&lt;T: Bound&lt;Self&gt;&gt;(&amp;self) where Self: Sized {
        // do logical `method` things
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Whoops, it doesn't accept that either! 😠 We have to implement it
without the bound, like so:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Bound&lt;T: ?Sized&gt; {}
</span><span class="boring">trait Trait {
</span><span class="boring">   fn method&lt;T: Bound&lt;Self&gt;&gt;(&amp;self) where Self: Sized;
</span><span class="boring">}
</span>impl Trait for str {
    fn method&lt;T: Bound&lt;Self&gt;&gt;(&amp;self) {
        // do logical `method` things
    }
}
<span class="boring">}</span></code></pre></pre>
<p>And that compiles... but we can never actually call it.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">trait Bound&lt;T: ?Sized&gt; {}
</span><span class="boring">trait Trait {
</span><span class="boring">   fn method&lt;T: Bound&lt;Self&gt;&gt;(&amp;self) where Self: Sized;
</span><span class="boring">}
</span><span class="boring">impl Trait for str {
</span><span class="boring">    fn method&lt;T: Bound&lt;Self&gt;&gt;(&amp;self) {
</span><span class="boring">    }
</span><span class="boring">}
</span>fn main() {
    "".method();
}</code></pre></pre>
<p>Alternatively, we can exploit the fact that higher-ranked bounds
are checked at the call site and not the definition site to sneak
in the unsatisfiable <code>Self: Sized</code> bound in a way that compiles:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Bound&lt;T: ?Sized&gt; {}
</span><span class="boring">trait Trait {
</span><span class="boring">   fn method&lt;T: Bound&lt;Self&gt;&gt;(&amp;self) where Self: Sized;
</span><span class="boring">}
</span>impl Trait for str {
    // Still not callable, but compiles:   vvvvvvv  due to this binder
    fn method&lt;T: Bound&lt;Self&gt;&gt;(&amp;self) where for&lt;'a&gt; Self: Sized {
        unreachable!()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>But naturally the method still cannot be called, as the bound is not satisfiable.</p>
<p>This is a pretty sad state of affairs.  Ideally, there would be a
distinct trait for opting out of <code>dyn</code> safety and dispatchability
instead of using <code>Sized</code> for this purpose; let's call it <code>NotDyn</code>.
Then we could have <code>Sized: NotDyn</code> for backwards compatibility,
change the bound above to be <code>NotDyn</code>, and have our implementation
for <code>str</code> be functional.</p>
<p>There also some other future possibilities that may improve the situation:</p>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/issues/2829">Some resolution of RFC issue 2829</a>
or the duplicates linked within would allow omitting the method altogether
(but it would still not be callable)</li>
<li><a href="https://rust-lang.github.io/rfcs/2056-allow-trivial-where-clause-constraints.html">RFC 2056</a>
will allow defining the method with the trivially unsatifiable bound without
exploiting the higher-ranked trick (but it will still not be callable)</li>
<li><a href="https://rust-lang.github.io/rfcs/3245-refined-impls.html">RFC 3245</a> will allow
calling <code>&lt;str as Trait&gt;::method</code> and refined implementations more generally</li>
</ul>
<p>But I feel removing the conflation between <code>dyn</code> safety and <code>Sized</code> would
be more clear and correct regardless of any future workarounds that may exist.</p>
<h2 id="receiver-limitations"><a class="header" href="#receiver-limitations">Receiver limitations</a></h2>
<p>The requirement for some sort of <code>Self</code>-based receiver on <code>dyn</code>-dispatchable
methods is to ensure the vtable is available.  Some wide pointer to <code>Self</code>
needs to be present in order to
<a href="dyn-trait-impls.html#how-dyn-trait-implements-trait">find the vtable and perform dynamic dispatch.</a></p>
<p>Arguably this could be expanded to methods that take a single,
non-receiver <code>&amp;Self</code> and so on.</p>
<p>As for the other limitation on receiver types, <a href="./dyn-trait-impls.html#other-receivers">the compiler has to know
how to go backwards from type erased version to original
version</a> in order to
implement <code>Trait</code>.  This may be generalized some day, but for
now it's a restricted set.</p>
<h2 id="generic-method-limitations"><a class="header" href="#generic-method-limitations">Generic method limitations</a></h2>
<p>In order to support type-generic methods, there would need to be
a function pointer in the vtable for every possible type that the
generic could take on.  Not only would this create vtables of
unwieldly size, it would also require some sort of global analysis.
After all, every crate which uses your trait might define new types
that meet the trait bounds in question, and they (or you) might also
want to call the method using those types.</p>
<p>You can sometimes work around this limitation by type erasing the
generic type parameter in question (in the main method, as an
alternative method, or in a different "erased" trait).
<a href="./dyn-trait-erased.html">We'll see an example of this later.</a></p>
<h2 id="use-of-self-limitations"><a class="header" href="#use-of-self-limitations">Use of <code>Self</code> limitations</a></h2>
<p>Methods which take some form of <code>Self</code> other than as a receiver
can depend on the parameter being exactly the same as the
implementing type.  But this can't be relied upon once the base
types have been erased.</p>
<p>For example, consider <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq&lt;Self&gt;</code>:</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simplified
pub trait PartialEq {
    fn partial_eq(&amp;self, rhs: &amp;Self);
}
<span class="boring">}</span></code></pre></pre>
<p>If this were implemented for <code>dyn PartialEq</code>, the <code>rhs</code> parameter
would be a <code>&amp;dyn PartialEq</code> like <code>self</code> is.  But there is no
guarantee that the base types are the same!  Both <code>u8</code> and <code>String</code>
implement <code>PartialEq</code> for example, but there's no facility to
compare them for equality (and Rust has no interest in handling
this in an arbitrary way).</p>
<p>You can sometimes work around this by supplying your own implementations
for some <em>other</em> <code>dyn Trait</code>, perhaps utilizing the <code>Any</code> trait
to emulate dynamic typing and reflection.
<a href="./dyn-trait-eq.html">We give an example of this approach later.</a></p>
<p><a href="./dyn-trait-clone.html">The <code>impl Clone for Box&lt;dyn Trait&gt;</code> example</a>
demonstrates handling a case where <code>Self</code> is the return value.</p>
<h2 id="gat-limitations"><a class="header" href="#gat-limitations">GAT limitations</a></h2>
<p>GATs are too new to support type erasing as-of-yet.  We'll need
some way to embed the GAT into the <code>dyn Trait</code> as a parameter,
<a href="./dyn-trait-coercions.html#associated-types">similar to how is done for non-generic associated types.</a></p>
<p><a href="https://github.com/rust-lang/rust/pull/112319/">As of Rust 1.72,</a>
you can opt out of GATs being <code>dyn</code>-usable, and thus out of the
necessity of naming the GAT as a parameter, by adding a
<code>Self: Sized</code> bound.</p>
<p>This is similar to <a href="dyn-trait-coercions.html#opting-out-of-dyn-usability">the same ability on non-generic associated types.</a>
Interestingly, it allows specifying not only <em>specific</em> GAT equalities...</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    type Gat&lt;'a&gt; where Self: Sized;
}

impl Trait for () {
    type Gat&lt;'a&gt; = &amp;'a str;
}

let _: &amp;dyn Trait&lt;Gat&lt;'static&gt; = &amp;'static str&gt; = &amp;();
<span class="boring">}</span></code></pre></pre>
<p>...but also higher-ranked GAT equality:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {
</span><span class="boring">   type Gat&lt;'a&gt; where Self: Sized;
</span><span class="boring">}
</span><span class="boring">impl Trait for () {
</span><span class="boring">   type Gat&lt;'a&gt; = &amp;'a str;
</span><span class="boring">}
</span>// This syntax is still not supported
// let _: &amp;dyn Trait&lt;for&lt;'a&gt; Gat&lt;'a&gt; = &amp;'a str&gt; = &amp;();

// However, with `dyn Trait`, you can move the binder to outside the `Trait`:
let _: &amp;dyn for&lt;'a&gt; Trait&lt;Gat&lt;'a&gt; = &amp;'a str&gt; = &amp;();
<span class="boring">}</span></code></pre></pre>
<p>However, as with the non-generic associated type case, making any use of the
equality would have to be done indirectly, as the <code>dyn Trait</code> itself cannot
define a GAT in its own implementation.</p>
<h2 id="associated-constant-limitations"><a class="header" href="#associated-constant-limitations">Associated constant limitations</a></h2>
<p>Similarly, supporting associated constants will require at least
<a href="https://github.com/rust-lang/rust/issues/92827">support for associated constant equality.</a></p>
<h2 id="return-position-impl-trait-limitations"><a class="header" href="#return-position-impl-trait-limitations">Return position <code>impl Trait</code> limitations</a></h2>
<p>Trait methods utilizing
<a href="dyn-trait-vs.html#return-position-impl-trait-and-tait"><abbr title="return position impl traits">RPITs</abbr></a>
are, notionally at least, sugar for declaring an opaque associated
type or generic associated type.  Additionally, even if the RPIT
captures no generic parameters and thus corresponds to returning
an associated type, there is currently no way to name that associated
type.</p>
<p>Similar to <a href="dyn-safety.html#generic-method-limitations">generic methods,</a> you can
sometimes work around this limitation by type erasing the return
type.  (Note that there are some trade-offs, but a discussion of
such is more suited to a dedicated guide about RPITs.)</p>
<h2 id="history"><a class="header" href="#history">History</a></h2>
<p><a href="https://rust-lang.github.io/rfcs/0255-object-safety.html">Object safety was introduced in RFC 0255,</a>
and <a href="https://rust-lang.github.io/rfcs/0546-Self-not-sized-by-default.html">RFC 0546</a> removed the
implied <code>Sized</code> bound on traits and added the rule that traits with (explicit) <code>Sized</code> bounds
are not object safe.</p>
<p>Both RFCs were implemented before Rust 1.0.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn-trait-lifetimes"><a class="header" href="#dyn-trait-lifetimes"><code>dyn Trait</code> lifetimes</a></h1>
<p>As mentioned before, every <code>dyn Trait</code> has a "trait object lifetime".  Even though
it is often elided, the lifetime is always present.</p>
<p>The lifetime is necessary as types which implement <code>Trait</code> may not be valid everywhere.
For example, <code>&amp;'s String</code> implements <code>Display</code> for any lifetime <code>'s</code>.  If you type
erase a <code>&amp;'s String</code> into a <code>dyn Display</code>, Rust needs to keep track of that lifetime
so you don't try to print the value after the reference becomes invalid.</p>
<p>So you can coerce <code>&amp;'s String</code> to <code>dyn Display + 's</code>, but not <code>dyn Display + 'static</code>.</p>
<p>Let's look at a couple examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::fmt::Display;
</span>fn fails() -&gt; Box&lt;dyn Display + 'static&gt; {
    let local = String::new();
    // This reference cannot be longer than the function body
    let borrow = &amp;local;
    // We can coerce it to `dyn Display`...
    let bx: Box&lt;dyn Display + '_&gt; = Box::new(borrow);
    // But the lifetime cannot be `'static`, so this is an error
    bx
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::fmt::Display;
</span>// This is fine as per the function lifetime elision rules, the lifetime of the
// `dyn Display + '_` is the same as the lifetime of the `&amp;String`, and we know
// the reference is valid for that long or it wouldn't be possible to call the
// function.
fn works(s: &amp;String) -&gt; Box&lt;dyn Display + '_&gt; {
    Box::new(s)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="when-multiple-lifetimes-are-involved"><a class="header" href="#when-multiple-lifetimes-are-involved">When multiple lifetimes are involved</a></h2>
<p>Let's try another example, with a <code>struct</code> that has more complicated lifetimes.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}

// We're using `*mut` to make the lifetimes invariant
struct MultiRef&lt;'a, 'b&gt;(*mut &amp;'a str, *mut &amp;'b str);

impl Trait for MultiRef&lt;'_, '_&gt; {}

fn foo&lt;'a, 'b&gt;(mr: MultiRef&lt;'a, 'b&gt;) {
    let _: Box&lt;dyn Trait + '_&gt; = Box::new(mr);
}
<span class="boring">}</span></code></pre></pre>
<p>This compiles, but there's nothing preventing either <code>'a</code> from being longer than <code>'b</code>,
or <code>'b</code> from being longer than <code>'a</code>.  So what's the lifetime of the <code>dyn Trait</code>?  It
can't be either <code>'a</code> or <code>'b</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span><span class="boring">#[derive(Copy, Clone)] struct MultiRef&lt;'a, 'b&gt;(*mut &amp;'a str, *mut &amp;'b str);
</span><span class="boring">impl Trait for MultiRef&lt;'_, '_&gt; {}
</span>// These both fail
fn foo&lt;'a, 'b&gt;(mr: MultiRef&lt;'a, 'b&gt;) {
    let _: Box&lt;dyn Trait + 'a&gt; = Box::new(mr);
    let _: Box&lt;dyn Trait + 'b&gt; = Box::new(mr);
}
<span class="boring">}</span></code></pre></pre>
<p>In this case, the compiler computes some lifetime, let's call it <code>'c</code>,
such that <code>'a</code> and <code>'b</code> are both valid for the entirety of <code>'c</code>.</p>
<p>That is, <code>'c</code> is contained in an intersection of <code>'a</code> and <code>'b</code>.</p>
<p>Any lifetime for which both <code>'a</code> and <code>'b</code> are valid over will do:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span><span class="boring">struct MultiRef&lt;'a, 'b&gt;(*mut &amp;'a str, *mut &amp;'b str);
</span><span class="boring">impl Trait for MultiRef&lt;'_, '_&gt; {}
</span>// `'c` must be within the intersection of `'a` and `'b`
fn foo&lt;'a: 'c, 'b: 'c, 'c&gt;(mr: MultiRef&lt;'a, 'b&gt;) {
    let _: Box&lt;dyn Trait + 'c&gt; = Box::new(mr);
}
<span class="boring">}</span></code></pre></pre>
<p>Note that this is not the same as <code>'a + 'b</code> -- that is the <em>union</em>
of <code>'a</code> and <code>'b</code>.  Unfortunately, there is no compact syntax
for the intersection of <code>'a</code> and <code>'b</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variance"><a class="header" href="#variance">Variance</a></h1>
<p>The <code>dyn Trait</code> lifetime is covariant, like the outer lifetime of a
reference.  This means that whenever it is in a covariant type position,
longer lifetimes can be coerced into shorter lifetimes.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span>fn why_be_static&lt;'a&gt;(bx: Box&lt;dyn Trait + 'static&gt;) -&gt; Box&lt;dyn Trait + 'a&gt; {
    bx
}
<span class="boring">}</span></code></pre></pre>
<p>The trait object with the longer lifetime is a subtype of the trait object with
the shorter lifetime, so this is a form of supertype coercion.  <a href="./dyn-hr.html">In the next
section,</a> we'll look at another form of trait object subtyping.</p>
<p>The idea behind <em>why</em> trait object lifetimes are covariant is that the lifetime
represents the region where it is still valid to call methods on the trait object.
Since it's valid to call methods anywhere in that region, it's also valid to restrict
the region to some subset of itself -- i.e. to coerce the lifetime to be shorter.</p>
<p>However, it turns out that the <code>dyn Trait</code> lifetime is even more flexible than
your typical covariant lifetime.</p>
<h2 id="unsizing-coercions-in-invariant-context"><a class="header" href="#unsizing-coercions-in-invariant-context">Unsizing coercions in invariant context</a></h2>
<p><a href="./dyn-trait-coercions.html#the-reflexive-case">Earlier we noted that</a>
you can cast a <code>dyn Trait + 'a</code> to a <code>dyn Trait + 'b</code>, where <code>'a: 'b</code>.
Well, isn't that just covariance?  Not quite -- when we noted this before,
we were talking about an <em>unsizing coercion</em> between two <code>dyn Trait + '_</code>.</p>
<p>And <em>that coercion can take place even in invariant position.</em>  That means
that the <code>dyn Trait</code> lifetime can act in a covariant-like fashion <em>even in
invariant contexts!</em></p>
<p>For example, this compiles, even though the <code>dyn Trait</code> is behind a <code>&amp;mut</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span>fn invariant_coercion&lt;'m, 'long: 'short, 'short&gt;(
    arg: &amp;'m mut (dyn Trait + 'long)
) -&gt;
    &amp;'m mut (dyn Trait + 'short)
{
    arg
}
<span class="boring">}</span></code></pre></pre>
<p>But as there are <a href="./dyn-trait-coercions.html#no-nested-coercions">no nested unsizing coercions,</a>
this version does not compile:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">trait Trait {}
</span>// Fails: `Cell&lt;T&gt;` is invariant in `T` and the `dyn Trait` is nested
fn foo&lt;'l: 's, 's&gt;(v: Cell&lt;Box&lt;Box&lt;dyn Trait + 'l&gt;&gt;&gt;) -&gt; Cell&lt;Box&lt;Box&lt;dyn Trait + 's&gt;&gt;&gt; {
    v
}
<span class="boring">}</span></code></pre></pre>
<p>Because this is an unsizing coercion and not a subtyping coercion, there
may be situations where you must make the coercion explicitly, for example
with a cast.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span>// This fails without the `as _` cast.
fn foo&lt;'a&gt;(arg: &amp;'a mut Box&lt;dyn Trait + 'static&gt;) -&gt; Option&lt;&amp;'a mut (dyn Trait + 'a)&gt; {
    true.then(move || arg.as_mut() as _)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="why-this-is-actually-a-critical-feature"><a class="header" href="#why-this-is-actually-a-critical-feature">Why this is actually a critical feature</a></h3>
<p>We'll examine elided lifetime in depth <a href="./dyn-elision.html">soon,</a> but let us
note here how this "ultra-covariance" is very important for making common patterns
usably ergonomic.</p>
<p>The signatures of <code>foo</code> and <code>bar</code> are effectively the same in the following example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span>fn foo(d: &amp;mut dyn Trait) {}

fn bar&lt;'a&gt;(d: &amp;'a mut (dyn Trait + 'a)) {
    foo(d);
    foo(d);
}
<span class="boring">}</span></code></pre></pre>
<p>We can call <code>foo</code> multiple times from <code>bar</code> by <a href="./st-reborrow.html">reborrowing</a>
the <code>&amp;'a mut dyn Trait</code> for shorter than <code>'a</code>.  But because the trait object
lifetime must match the outer <code>&amp;mut</code> lifetime in this case, <em>we also have
to coerce <code>dyn Trait + 'a</code> to that shorter lifetime.</em></p>
<p>Similar considerations come into play when going between a <code>&amp;mut Box&lt;dyn Trait&gt;</code>
and a <code>&amp;mut dyn Trait</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span><span class="boring">fn foo(d: &amp;mut dyn Trait) {}
</span><span class="boring">fn bar&lt;'a&gt;(d: &amp;'a mut (dyn Trait + 'a)) {
</span><span class="boring">   foo(d);
</span><span class="boring">   foo(d);
</span><span class="boring">}
</span>fn baz(bx: &amp;mut Box&lt;dyn Trait /* + 'static */&gt;) {
    // If the trait object lifetime could not "shrink" inside the `&amp;mut`,
    // we could not make these calls at all
    foo(&amp;mut **bx);
    bar(&amp;mut **bx);
}
<span class="boring">}</span></code></pre></pre>
<p>Here we reborrow <code>**bx</code> as <code>&amp;'a mut (dyn Trait + 'static)</code> for some
short-lived <code>'a</code>, and then coerce that to a <code>&amp;'a mut (dyn Trait + 'a)</code>.</p>
<h2 id="variance-in-nested-context"><a class="header" href="#variance-in-nested-context">Variance in nested context</a></h2>
<p>The supertype coercion of going from <code>dyn Trait + 'a</code> to <code>dyn Trait + 'b</code>
when <code>'a: 'b</code> <em>can</em> happen in deeply nested contexts, provided the trait
object is still in a covariant context.  So unlike the <code>Cell</code> version
above, this version compiles:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span>fn foo&lt;'l: 's, 's&gt;(v: Vec&lt;Box&lt;Box&lt;dyn Trait + 'l&gt;&gt;&gt;) -&gt; Vec&lt;Box&lt;Box&lt;dyn Trait + 's&gt;&gt;&gt; {
    v
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="higher-ranked-types"><a class="header" href="#higher-ranked-types">Higher-ranked types</a></h1>
<p>Another feature of trait objects is that they can be <em>higher-ranked</em> over
lifetime parameters of the trait:</p>
<pre><pre class="playground"><code class="language-rust edition2021">// A trait with a lifetime parameter
trait Look&lt;'s&gt; {
    fn method(&amp;self, s: &amp;'s str);
}

// An implementation that works for any lifetime
impl&lt;'s&gt; Look&lt;'s&gt; for () {
    fn method(&amp;self, s: &amp;'s str) {
        println!("Hi there, {s}!");
    }
}

fn main() {
    // A higher-ranked trait object
    //           vvvvvvvvvvvvvvvvvvvvvvvv
    let _bx: Box&lt;dyn for&lt;'any&gt; Look&lt;'any&gt;&gt; = Box::new(());
}</code></pre></pre>
<p>The <code>for&lt;'x&gt;</code> part is a <em>lifetime binder</em> that introduces higher-ranked
lifetimes.  There can be more than one lifetime, and you can give them
arbitrary names just like lifetime parameters on functions, structs,
and so on.</p>
<p>You can only coerce to a higher-ranked trait object if you implement
the trait in question for <em>all</em> lifetimes.  For example, this doesn't
work:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">trait Look&lt;'s&gt; { fn method(&amp;self, s: &amp;'s str); }
</span>impl&lt;'s&gt; Look&lt;'s&gt; for &amp;'s i32 {
    fn method(&amp;self, s: &amp;'s str) {
        println!("Hi there, {s}!");
    }
}

fn main() {
    let _bx: Box&lt;dyn for&lt;'any&gt; Look&lt;'any&gt;&gt; = Box::new(&amp;0);
}</code></pre></pre>
<p><code>&amp;'s i32</code> only implements <code>Look&lt;'s&gt;</code>, not <code>Look&lt;'a&gt;</code> for all lifetimes <code>'a</code>.</p>
<p>Similarly, this won't work either:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">trait Look&lt;'s&gt; { fn method(&amp;self, s: &amp;'s str); }
</span>impl Look&lt;'static&gt; for i32 {
    fn method(&amp;self, s: &amp;'static str) {
        println!("Hi there, {s}!");
    }
}

fn main() {
    let _bx: Box&lt;dyn for&lt;'any&gt; Look&lt;'any&gt;&gt; = Box::new(0);
}</code></pre></pre>
<p>Implementing the trait with <code>'static</code> as the lifetime parameter is not the
same thing as implementing the trait for any lifetime as the parameter.
Traits and trait implementations don't have something like variance; the
parameters of traits are always invariant and thus implementations are
always for the explicit lifetime(s) only.</p>
<h2 id="subtyping"><a class="header" href="#subtyping">Subtyping</a></h2>
<p>There's a relationship between higher-ranked types like <code>dyn for&lt;'any&gt; Look&lt;'any&gt;</code>
and non-higher-ranked types like <code>dyn Look&lt;'x&gt;</code> (for a single lifetime <code>'x</code>): the
higher-ranked type is a subtype of the non-higher-ranked types.  Thus you can
coerce a higher-ranked type to a non-higher-ranked type with any concrete lifetime:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Look&lt;'s&gt; { fn method(&amp;self, s: &amp;'s str); }
</span>fn as_static(bx: Box&lt;dyn for&lt;'any&gt; Look&lt;'any&gt;&gt;) -&gt; Box&lt;dyn Look&lt;'static&gt;&gt; {
    bx
}

fn as_whatever&lt;'w&gt;(bx: Box&lt;dyn for&lt;'any&gt; Look&lt;'any&gt;&gt;) -&gt; Box&lt;dyn Look&lt;'w&gt;&gt; {
    bx
}
<span class="boring">}</span></code></pre></pre>
<p>Note that this still isn't a form of variance for the <em>lifetime parameter</em> of the
trait.  This fails for example, because you can't coerce from <code>dyn Look&lt;'static&gt;</code>
to <code>dyn Look&lt;'w&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Look&lt;'s&gt; { fn method(&amp;self, s: &amp;'s str); }
</span><span class="boring">fn as_static(bx: Box&lt;dyn for&lt;'any&gt; Look&lt;'any&gt;&gt;) -&gt; Box&lt;dyn Look&lt;'static&gt;&gt; { bx }
</span>fn as_whatever&lt;'w&gt;(bx: Box&lt;dyn for&lt;'any&gt; Look&lt;'any&gt;&gt;) -&gt; Box&lt;dyn Look&lt;'w&gt;&gt; {
    as_static(bx)
}
<span class="boring">}</span></code></pre></pre>
<p>As a supertype coercion, going from higher-ranked to non-higher-ranked can
apply even in a covariant nested context,
<a href="./dyn-covariance.html#variance-in-nested-context">just like non-higher-ranked supertype coercions:</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Look&lt;'s&gt; {}
</span>fn foo&lt;'l: 's, 's, 'p&gt;(
    v: Vec&lt;Box&lt;dyn for&lt;'any&gt; Look&lt;'any&gt; + 'l&gt;&gt;
) -&gt; Vec&lt;Box&lt;dyn Look&lt;'p&gt; + 's&gt;&gt;
{
    v
}
<span class="boring">}</span></code></pre></pre>
<h2 id="fn-traits-and-fn-pointers"><a class="header" href="#fn-traits-and-fn-pointers"><code>Fn</code> traits and <code>fn</code> pointers</a></h2>
<p>The <code>Fn</code> traits (<a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a>,
<a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>,
and <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>)
have special-cased syntax.  For one, you write them out to look more like
a function, using <code>(TypeOne, TypeTwo)</code> to list the input parameters and
<code>-&gt; ResultType</code> to list the associated type.  But for another, elided
input lifetimes are sugar that introduces higher-ranked bindings.</p>
<p>For example, these two trait object types are the same:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn identity(bx: Box&lt;dyn Fn(&amp;str)&gt;) -&gt; Box&lt;dyn for&lt;'any&gt; Fn(&amp;'any str)&gt; {
    bx
}
<span class="boring">}</span></code></pre></pre>
<p>This is similar to how elided lifetimes work for function declarations
as well, and indeed, the same output lifetime elision rules also apply:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The elided input lifetime becomes a higher-ranked lifetime
// The elided output lifetime is the same as the single input lifetime
//     (underneath the binder)
fn identity(bx: Box&lt;dyn Fn(&amp;str) -&gt; &amp;str&gt;) -&gt; Box&lt;dyn for&lt;'any&gt; Fn(&amp;'any str) -&gt; &amp;'any str&gt; {
    bx
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Doesn't compile as what the output lifetime should be is
// considered ambiguous
fn ambiguous(bx: Box&lt;dyn Fn(&amp;str, &amp;str) -&gt; &amp;str&gt;) {}

// Here's a possible fix, which is also an example of
// multiple lifetimes in the binder
fn first(bx: Box&lt;dyn for&lt;'a, 'b&gt; Fn(&amp;'a str, &amp;'b str) -&gt; &amp;'a str&gt;) {}
<span class="boring">}</span></code></pre></pre>
<p>Function pointers are another example of types which can be higher-ranked
in Rust.  They have analogous syntax and sugar to function declarations
and the <code>Fn</code> traits.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn identity(fp: fn(&amp;str) -&gt; &amp;str) -&gt; for&lt;'any&gt; fn(&amp;'any str) -&gt; &amp;'any str {
    fp
}
<span class="boring">}</span></code></pre></pre>
<h3 id="syntactic-inconsistencies"><a class="header" href="#syntactic-inconsistencies">Syntactic inconsistencies</a></h3>
<p>There are some inconsistencies around the syntax for function declarations,
function pointer types, and the <code>Fn</code> traits involving the "names" of the
input arguments.</p>
<p>First of all, only function (method) declarations can make use of the
shorthand <code>self</code> syntaxes for receivers, like <code>&amp;self</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct S;
</span>impl S {
    fn foo(&amp;self) {}
    //     ^^^^^
}
<span class="boring">}</span></code></pre></pre>
<p>This exception is pretty unsurprising as the <code>Self</code> alias only exists
within those implementation blocks.</p>
<p>Each non-<code>self</code> argument in a function declaration is an
<a href="https://doc.rust-lang.org/reference/items/functions.html#function-parameters">irrefutable pattern</a>
followed by a type annotation.  It is an error to leave out the pattern;
if you don't use the argument (and thus don't need to name it), you
still need to use at least the wildcard pattern.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn this_works(_: i32) {}
fn this_fails(i32) {}
<span class="boring">}</span></code></pre></pre>
<p>There is
<a href="https://rust-lang.github.io/rfcs/1685-deprecate-anonymous-parameters.html">an accidental exception</a>
to this rule, but it was removed in Edition 2018 and thus is only
available on Edition 2015.</p>
<p>In contrast, each argument in a function pointer can be</p>
<ul>
<li>An <em>identifier</em> followed by a type annotation (<code>i: i32</code>)</li>
<li><code>_</code> followed by a type annotation (<code>_: i32</code>)</li>
<li>Just a type name (<code>i32</code>)</li>
</ul>
<p>So these all work:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _: fn(i32) = |_| {};
let _: fn(i: i32) = |_| {};
let _: fn(_: i32) = |_| {};
<span class="boring">}</span></code></pre></pre>
<p>But <em>actual</em> patterns <a href="https://doc.rust-lang.org/stable/error_codes/E0561.html">are not allowed:</a></p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _: fn(&amp;i: &amp;i32) = |_| {};
<span class="boring">}</span></code></pre></pre>
<p>The idiomatic form is to just use the type name.</p>
<p>It's also allowed <a href="https://github.com/rust-lang/rust/issues/33995">to have colliding names in function pointer
arguments,</a> but this
is a property of having no function body -- so it's also possible in
a trait method declaration, for example.  It is also related to the
Edition 2015 exception for anonymous function arguments mentioned
above, and may be deprecated eventually.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn silly(a: u32, a: i32);
}

let _: fn(a: u32, a: i32) = |_, _| {};
<span class="boring">}</span></code></pre></pre>
<p>Finally, each argument in the <code>Fn</code> traits can <em>only</em> be a type name:
no identifiers, <code>_</code>, or patterns allowed.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// None of these compile
let _: Box&lt;dyn Fn(i: i32)&gt; = Box::new(|_| {});
let _: Box&lt;dyn Fn(_: i32)&gt; = Box::new(|_| {});
let _: Box&lt;dyn Fn(&amp;_: &amp;i32)&gt; = Box::new(|_| {});
<span class="boring">}</span></code></pre></pre>
<p>Why the differences? One reason is that
<a href="https://github.com/rust-lang/rust/issues/41686#issuecomment-366611096">patterns are grammatically incompatible with anonymous arguments,
apparently.</a>
I'm uncertain as to why identifiers are accepted on function pointers,
however, or more generally why the <code>Fn</code> sugar is inconsistent with
function pointer types.  But the simplest explanation is that function
pointers existed first with nameable parameters for whatever reason,
whereas the <code>Fn</code> sugar is for trait input type parameters which also
do not have names.</p>
<h2 id="higher-ranked-trait-bounds"><a class="header" href="#higher-ranked-trait-bounds">Higher-ranked trait bounds</a></h2>
<p>You can also apply higher-ranked trait bounds (HRTBs) to generic
type parameters, using the same syntax:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Look&lt;'s&gt; { fn method(&amp;self, s: &amp;'s str); }
</span>fn box_it_up&lt;'t, T&gt;(t: T) -&gt; Box&lt;dyn for&lt;'any&gt; Look&lt;'any&gt; + 't&gt;
where
    T: for&lt;'any&gt; Look&lt;'any&gt; + 't,
{
    Box::new(t)
}
<span class="boring">}</span></code></pre></pre>
<p>The sugar for <code>Fn</code> like traits applies here as well.  You've probably
already seen bounds like this on methods that take closures:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct S;
</span><span class="boring">impl S {
</span>fn map&lt;'s, F, R&gt;(&amp;'s self, mut f: F) -&gt; impl Iterator&lt;Item = R&gt; + 's
where
    F: FnMut(&amp;[i32]) -&gt; R + 's
{
    // This part isn't the point ;-)
    [].into_iter().map(f)
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>That bound is actually <code>F: for&lt;'x&gt; FnMut(&amp;'x [i32]) -&gt; R + 's</code>.</p>
<h2 id="thats-all-about-higher-ranked-types-for-now"><a class="header" href="#thats-all-about-higher-ranked-types-for-now">That's all about higher-ranked types for now</a></h2>
<p>Hopefully this has given you a decent overview of higher-ranked
types, HRTBs, and how they relate to the <code>Fn</code> traits.  There
are a lot more details and nuances to those topics and related
concepts such as closures, as you might imagine.  However, an
exploration of those topics deserves its own dedicated guide, so
we won't see too much more about higher-ranked types in this
tour of <code>dyn Trait</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elision-rules"><a class="header" href="#elision-rules">Elision rules</a></h1>
<p>The <code>dyn Trait</code> lifetime elision rules are an instance of fractal complexity
in Rust.  Some general guidelines will get you 95% of the way there, some
advanced guidelines will get you another 4% of the way there, but the deeper
you go the more niche circumstances you may run into.  And unfortunately,
there is no proper specification to refer to.</p>
<p>The good news is that you can override the lifetime elision behavior by
being explicit about the lifetime, which provides an escape hatch from
most of the complexity.  So when in doubt, be explicit!</p>
<p>In the following subsections, we present the current behavior of the compiler
in layers, to the extent we have explored them.</p>
<p>We occasionally refer to <a href="https://doc.rust-lang.org/reference/lifetime-elision.html#default-trait-object-lifetimes">the reference's documentation on trait object lifetime elision</a>.
However, our layered approach differs somewhat from the reference's approach,
as the reference is not completely accurate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-guidelines-and-subtleties"><a class="header" href="#basic-guidelines-and-subtleties">Basic guidelines and subtleties</a></h1>
<p>As a reminder, <code>dyn Trait</code> is a type constructor which is parameterized with a
lifetime; a fully resolved type includes the lifetime, such as <code>dyn Trait + 'static</code>.
The lifetime can be elided in many situations, in which case the actual lifetime
used may take on some default lifetime, or may be inferred.</p>
<p>When talking about default trait object (<code>dyn Trait</code>) lifetimes, we're talking about
situations where the lifetime has been completely elided.  If the wildcard lifetime
is used (<code>dyn Trait + '_</code>), then <a href="https://doc.rust-lang.org/reference/lifetime-elision.html#lifetime-elision-in-functions">the normal lifetime elision rules</a>
usually apply instead.  (The exceptions are rare, and you can usually be explicit
instead if you need to.)</p>
<p>For a completely elided <code>dyn Trait</code> lifetime, you can start with these
general guidelines for traits with no lifetime bounds (which are the vast majority):</p>
<ul>
<li>In function bodies, the trait object lifetime is inferred (i.e. ignore the following bullets)</li>
<li>For references like <code>&amp;'a dyn Trait</code>, the default is the same as the reference lifetime (<code>'a</code>)</li>
<li>For <code>dyn</code>-supporting <code>std</code> types with lifetime parameters such as
<a href="https://doc.rust-lang.org/std/cell/struct.Ref.html"><code>Ref&lt;'a, T&gt;</code></a>, it is also <code>'a</code></li>
<li>For non-lifetime-parameter types like <code>Box&lt;dyn Trait&gt;</code>, and for bare <code>dyn Trait</code>, it's <code>'static</code></li>
</ul>
<p>And for the (rare) trait with lifetime bounds:</p>
<ul>
<li>If the trait has a <code>'static</code> bound, the trait object lifetime is always <code>'static</code></li>
<li>If the trait has only non-<code>'static</code> lifetime bounds, <a href="./dyn-elision-trait-bounds.html">you're better off being explicit</a></li>
</ul>
<p>This is a close enough approximation to let you understand <code>dyn Trait</code>
lifetime elision most of the time, but there are exceptions to these
guidelines (which are explored on the next couple of pages).</p>
<p>There are also a few subtleties worth pointing out <em>within</em> these guidelines,
which are covered immediately below.</p>
<h2 id="default-static-bound-gotchas"><a class="header" href="#default-static-bound-gotchas">Default <code>'static</code> bound gotchas</a></h2>
<p>The most likely scenario to run into an error about <code>dyn Trait</code> lifetime is
when <code>Box</code> or similar is involved, resulting an implicit <code>'static</code> constraint.</p>
<p>Those errors can often be addressed by either adding an explicit <code>'static</code>
bound, or by overriding the implicit <code>'static</code> lifetime.  In particular, using
<code>'_</code> will usually result in the "normal" (non-<code>dyn Trait</code>) lifetime elision for
the given context.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}
impl&lt;T: Trait&gt; Trait for &amp;T {}

// Remove `+ 'static` to see an error
fn with_explicit_bound&lt;'a, T: Trait + 'static&gt; (t: T) -&gt; Box&lt;dyn Trait&gt; {
    Box::new(t)
}

// Remove `+ 'a` (in either position) to see an error
fn with_nonstatic_box&lt;'a, T: Trait + 'a&gt;(t: T) -&gt; Box&lt;dyn Trait + 'a&gt; {
    Box::new(t)
}

// Remove `+ '_` to see an error
fn with_fn_lifetime_elision(t: &amp;impl Trait) -&gt; Box&lt;dyn Trait + '_&gt; {
    Box::new(t)
}
<span class="boring">}</span></code></pre></pre>
<p>This can be particularly confusing within a function body, where a
<code>Box&lt;dyn Trait&gt;</code> variable annotation acts differently from a <code>Box&lt;dyn Trait&gt;</code>
function input parameter annotation:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span><span class="boring">impl Trait for &amp;i32 {}
</span>// In this context, the elided lifetime is `'static`
fn requires_static(_: Box&lt;dyn Trait&gt;) {}

fn example() {
    let local = 0;

    // In this context, the annotation means `Box&lt;dyn Trait + '_&gt;`!
    // That is why it can compile on it's own, with the local reference.
    let bx: Box&lt;dyn Trait&gt; = Box::new(&amp;local);

    // So despite using the same syntax, this call cannot compile.
    // Uncomment it to see the compilation error.
    // requires_static(bx);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="impl-headers"><a class="header" href="#impl-headers"><code>impl</code> headers</a></h2>
<p>The <code>dyn Trait</code> lifetime elision applies in <code>impl</code> headers, which can lead to
implementations being less general than possible or desired:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}
trait Two {}

impl Two for Box&lt;dyn Trait&gt; {}
impl Two for &amp;dyn Trait {}
<span class="boring">}</span></code></pre></pre>
<p><code>Two</code> is implemented for</p>
<ul>
<li><code>Box&lt;dyn Trait + 'static&gt;</code></li>
<li><code>&amp;'a (dyn Trait + 'a)</code> for any <code>'a</code> (the lifetimes must match)</li>
</ul>
<p>Consider using implementations like the following if possible, as they are
more general:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span><span class="boring">trait Two {}
</span>// Implemented for all lifetimes
impl Two for Box&lt;dyn Trait + '_&gt; {}

// Implemented for all lifetimes such that the inner lifetime is
// at least as long as the outer lifetime
impl Two for &amp;(dyn Trait + '_) {}
<span class="boring">}</span></code></pre></pre>
<h2 id="alias-gotchas"><a class="header" href="#alias-gotchas">Alias gotchas</a></h2>
<p>Similar to <code>impl</code> headers, elision will apply when defining a type alias:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTraitICouldNotThinkOfAShortNameFor {}

// This is an alias to `dyn ... + 'static`!
type MyDyn = dyn MyTraitICouldNotThinkOfAShortNameFor;

// The default does not "override" the type alias and thus
// requires the trait object lifetime to be `'static`
fn foo(_: &amp;MyDyn) {}

// As per the `dyn` elision rules, this requires the trait
// object lifetime to be the same as the reference...
fn bar(d: &amp;dyn MyTraitICouldNotThinkOfAShortNameFor) {
    // ...and thus this fails as the lifetime cannot be extended
    foo(d);
}
<span class="boring">}</span></code></pre></pre>
<p>More generally, elision does not "penetrate" or alter type aliases.
This includes the <code>Self</code> alias within implementation blocks.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}

impl dyn Trait {
    // Error: requires `T: 'static`
    fn f&lt;T: Trait&gt;(t: &amp;T) -&gt; &amp;Self { t }
}

impl&lt;'a&gt; dyn Trait + 'a {
    // Error: requires `T: 'a`
    fn g&lt;T: Trait&gt;(t: &amp;T) -&gt; &amp;Self { t }
}
<span class="boring">}</span></code></pre></pre>
<p>See also <a href="./dyn-elision-advanced.html#iteraction-with-type-aliases">how type aliases with parameters behave.</a></p>
<h2 id="static-traits"><a class="header" href="#static-traits"><code>'static</code> traits</a></h2>
<p>When the trait itself is <code>'static</code>, the trait object lifetime has an implied
<code>'static</code> bound.  Therefore if you name the trait object lifetime explicitly,
the name you give it will also have an implied <code>'static</code> bound.  So here:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">use core::any::Any;
</span>// n.b. trait `Any` has a `'static` bound
fn example&lt;'a&gt;(_: &amp;'a (dyn Any + 'a)) {}

fn main() {
    let local = ();
    example(&amp;local);
}</code></pre></pre>
<p>We get an error that the borrow of <code>local</code> must be <code>'static</code>.  The problem is
that <code>'a</code> in <code>example</code> has inherited the <code>'static</code> bound (<code>'a: 'static</code>), and
we also gave the outer reference the lifetime of <code>'a</code>.  This is a case where
we don't actually want them to be the same.</p>
<p>The most ergonomic solution is to always completely elide the trait object
lifetime when the trait itself has a <code>'static</code> bound.  Unlike other cases,
the trait object lifetime is independent of the outer reference lifetime when
the trait itself has a <code>'static</code> bound, so this compiles:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use core::any::Any;
</span>// This is `&amp;'a (dyn Any + 'static)` and `'a` doesn't have to be `'static`
fn example(_: &amp;dyn Any) {}

fn main() {
    let local = ();
    example(&amp;local);
}</code></pre></pre>
<p><code>Any</code> is the most common trait with a <code>'static</code> bound, i.e. the most likely
reason for you to encounter this scenario.</p>
<h2 id="static-contexts"><a class="header" href="#static-contexts"><code>static</code> contexts</a></h2>
<p>In some contexts like when declaring a <code>static</code>, it's possible to elide the
lifetime of types like references; doing so will result in <code>'static</code> being
used for the elided lifetime:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The elided lifetime is `'static`
static S: &amp;str = "";
const C: &amp;str = "";
<span class="boring">}</span></code></pre></pre>
<p>As a result, elided <code>dyn Trait</code> lifetimes will by default also be <code>'static</code>,
matching the inferred lifetime of the reference.  In contrast, this fails
due to the outer lifetime being <code>'static</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span><span class="boring">impl Trait for () {}
</span>struct S&lt;'a: 'b, 'b&gt;(&amp;'b &amp;'a str);
impl&lt;'a: 'b, 'b&gt; S&lt;'a, 'b&gt; {
    const T: &amp;(dyn Trait + 'a) = &amp;();
}
<span class="boring">}</span></code></pre></pre>
<p>In this context, eliding all the lifetimes is again <em>usually</em> what you want.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-guidelines"><a class="header" href="#advanced-guidelines">Advanced guidelines</a></h1>
<p>In this section, we cover how to guide elision behavior for your own
generic data types, and point out some exceptions to the basic guidelines
presented in the previous section.</p>
<h2 id="guiding-behavior-of-your-own-types"><a class="header" href="#guiding-behavior-of-your-own-types">Guiding behavior of your own types</a></h2>
<p>When you declare a custom type with a lifetime parameter <code>'a</code> and a trait parameter <code>T: ?Sized</code>,
including an <em>explicit</em> <code>T: 'a</code> bound will result in elision behaving the same as
it does for references <code>&amp;'a T</code> and for <code>std</code> types like <code>Ref&lt;'a, T&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// When `T` is replaced by `dyn Trait` with an elided lifetime, the elided lifetime
// will default to `'a` outside of function bodies
struct ExplicitOutlives&lt;'a, T: 'a + ?Sized&gt;(&amp;'a T);
<span class="boring">}</span></code></pre></pre>
<p>If your type has no lifetime parameter, or if there is no bound between the type
parameter and the lifetime parameter, the default for elided <code>dyn Trait</code> lifetimes
will be <code>'static</code>, like it is for <code>Box&lt;T&gt;</code>.  <em>This is true even if there is an
<strong>implied</strong> <code>T: 'a</code> bound.</em>  For example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}
impl Trait for () {}

// There's an *implied* `T: 'a` bound due to the `&amp;'a T` field (RFC 2093)
struct InferredOutlivesOnly&lt;'a, T: ?Sized&gt;(&amp;'a T);

// Yet this function expects an `InferredOutlivesOnly&lt;'a, dyn Trait + 'static&gt;`
fn example&lt;'a&gt;(ioo: InferredOutlivesOnly&lt;'a, dyn Trait&gt;) {}

// Thus this fails to compile
fn attempt&lt;'a&gt;(ioo: InferredOutlivesOnly&lt;'a, dyn Trait + 'a&gt;) {
    example(ioo);
}
<span class="boring">}</span></code></pre></pre>
<p>If you make <code>T: 'a</code> explicit in the definition of the <code>struct</code>, the
example will compile.</p>
<p>If <code>T: 'a</code> is an inferred bound of your type, and <code>T: ?Sized</code>, I recommend
including the explicit <code>T: 'a</code> bound.</p>
<h2 id="ambiguous-bounds"><a class="header" href="#ambiguous-bounds">Ambiguous bounds</a></h2>
<p>If you have more than one lifetime bound in your type definition, the
bound is considered ambiguous, even if one of the lifetimes is <code>'static</code>
(or more generally, even if one lifetime is known to outlive the other).
Such structs are rare, but if you have one, you usually must be explicit
about the <code>dyn Trait</code> lifetime:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span><span class="boring">impl Trait for () {}
</span>struct S&lt;'a, 'b: 'a, T: 'a + 'b + ?Sized&gt;(&amp;'a &amp;'b T);

// error[E0228]: the lifetime bound for this object type cannot be deduced
// from context; please supply an explicit bound
const C: S&lt;dyn Trait&gt; = S(&amp;&amp;());
<span class="boring">}</span></code></pre></pre>
<p>However, in function bodies, the lifetime is still inferred; moreover it
is inferred independent of any annotation of the lifetime types:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span><span class="boring">impl Trait for () {}
</span>struct Weird&lt;'a, 'b, T: 'a + 'b + ?Sized&gt;(&amp;'a T, &amp;'b T);

fn example&lt;'a, 'b&gt;() {
    // Either of `dyn Trait + 'a` or `dyn Trait + 'b` is an error,
    // so the `dyn Trait` lifetime must be inferred independently
    // from `'a` and `'b`
    let _: Weird&lt;'a, 'b, dyn Trait&gt; = Weird(&amp;(), &amp;());
}
<span class="boring">}</span></code></pre></pre>
<p>(This is contrary to the documentation in the reference, and
<a href="dyn-elision-advanced.html#an-exception-to-inference-in-function-bodies">ironically more flexible than non-ambiguous types.</a>
In this particular example, the lifetime will be inferred
<a href="dyn-trait-lifetime.html#when-multiple-lifetimes-are-involved">analogously to the lifetime intersection mentioned previously.</a>)</p>
<h2 id="interaction-with-type-aliases"><a class="header" href="#interaction-with-type-aliases">Interaction with type aliases</a></h2>
<p>When you use a type alias, the bounds between lifetime parameters and type
parameters <em>on the <code>type</code> alias</em> determine how <code>dyn Trait</code> lifetime elision
behaves, overriding the bounds on the aliased type (be they stronger or weaker).</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span>// Without the `T: 'a` bound, the default trait object lifetime
// for this alias is `'static`
type MyRef&lt;'a, T&gt; = &amp;'a T;

// So this compiles
fn foo(mr: MyRef&lt;'_, dyn Trait&gt;) -&gt; &amp;(dyn Trait + 'static) {
   mr
}

// With the `T: 'a` bound, the default trait object lifetime for
// this alias is the lifetime parameter
type MyOtherRef&lt;'a, T: 'a&gt; = MyRef&lt;'a, T&gt;;

// So this does not compile
fn bar(mr: MyOtherRef&lt;'_, dyn Trait&gt;) -&gt; &amp;(dyn Trait + 'static) {
   mr
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://github.com/rust-lang/rust/issues/100270">See issue 100270.</a>
This is undocumented.</p>
<h2 id="associated-types-and-gats"><a class="header" href="#associated-types-and-gats">Associated types and GATs</a></h2>
<p><code>dyn Trait</code> lifetime elision applies in this context.  There are some
things of note, however:</p>
<ul>
<li>Bounds on associated types and GATs don't seem to have any effect</li>
<li>Eliding non-<code>dyn Trait</code> lifetimes is not allowed</li>
</ul>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span>trait Assoc {
    type T: ?Sized;
}

impl Assoc for () {
    // dyn Trait + 'static
    type T = dyn Trait;
}

impl&lt;'a&gt; Assoc for &amp;'a str {
    // &amp;'a (dyn Trait + 'a)
    type T = &amp;'a dyn Trait;
    // This is a compilation error as the reference lifetime is elided
    // type T = &amp;dyn Trait;
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span><span class="boring">impl Trait for () {}
</span>trait BoundedAssoc&lt;'x&gt; {
    type BA: 'x + ?Sized;
}

// Still `dyn Trait + 'static`
impl&lt;'x&gt; BoundedAssoc&lt;'x&gt; for () {
    type BA = dyn Trait;
}

// Fails as `'a` might not be `'static`
fn bib&lt;'a&gt;(obj: Box&lt;dyn Trait + 'a&gt;) {
    let obj: Box&lt; &lt;() as BoundedAssoc&lt;'a&gt;&gt;::BA &gt; = obj;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="an-exception-to-inference-in-function-bodies"><a class="header" href="#an-exception-to-inference-in-function-bodies">An exception to inference in function bodies</a></h2>
<p>There is also an exception to the elided <code>dyn Trait</code> lifetime being inferred
in function bodies.  If you have a reference-like type, and you annotate the
lifetime of the non-<code>dyn Trait</code> lifetime with a named lifetime, then the
elided <code>dyn Trait</code> lifetime will be the same as the annotated lifetime
(similar to how things behave outside of a function body):</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}
impl Trait for () {}

fn example&lt;'a&gt;(arg: &amp;'a ()) {
    let dt: &amp;'a dyn Trait = arg;
    // fails
    let _: &amp;(dyn Trait + 'static) = dt;
}
<span class="boring">}</span></code></pre></pre>
<p>According to the reference, <code>&amp;dyn Trait</code> should always behave like this.
However, if the outer lifetime is elided or if <code>'_</code> is used for the outer lifetime,
<em>the <code>dyn Trait</code> lifetime is inferred <strong>independently</strong> of the reference lifetime:</em></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span><span class="boring">impl Trait for () {}
</span>fn example() {
    let local = ();

    // The outer reference lifetime cannot be `'static`...
    let obj: &amp;dyn Trait = &amp;local;

    // Yet the `dyn Trait` lifetime is!
    let _: &amp;(dyn Trait + 'static) = obj;
}
<span class="boring">}</span></code></pre></pre>
<p>This is not documented anywhere and is in conflict with the reference.
<a href="https://github.com/rust-lang/rust/pull/39305">It was implemented here,</a>
with no team input or FCP.  🤷</p>
<p>However, the chances that you will run into a problem due to this behavior
is low, as it's rare to annotate lifetimes within a function body.</p>
<h2 id="what-we-are-not-yet-covering"><a class="header" href="#what-we-are-not-yet-covering">What we are not yet covering</a></h2>
<p>To the best of our knowledge, this covers the behavior of <code>dyn Trait</code> lifetime elision
<em>when there are no lifetime bounds on the trait itself.</em>  Non-<code>'static</code> lifetime bounds
on the trait itself lead to some more nuanced behavior; we'll cover some of them in the
<a href="./dyn-elision-trait-bounds.html">next section.</a></p>
<h2 id="advanced-guidelines-summary"><a class="header" href="#advanced-guidelines-summary">Advanced guidelines summary</a></h2>
<p>So all in all, we have three common categories of <code>dyn Trait</code> lifetime elision
when ignoring lifetime bounds on traits:</p>
<ul>
<li><code>'static</code> for type parameters with no (explicit) lifetime bound
<ul>
<li>E.g. <code>Box&lt;dyn Trait&gt;</code> (<code>Box&lt;dyn Trait + 'static&gt;</code>)</li>
<li>E.g. <code>struct Unbounded&lt;'a, T: ?Sized&gt;(&amp;'a T)</code></li>
</ul>
</li>
<li>Another lifetime parameter for type parameters with a single (explicit) lifetime bound
<ul>
<li>E.g. <code>&amp;'a dyn Trait</code> (<code>&amp;'a dyn Trait + 'a</code>)</li>
<li>E.g. <code>Ref&lt;'a, dyn Trait&gt;</code> (<code>Ref&lt;'a, dyn Trait + 'a&gt;</code>)</li>
<li>E.g. <code>struct Bounded&lt;'a, T: 'a + ?Sized&gt;(&amp;'a T)</code></li>
</ul>
</li>
<li>Ambiguous due to multiple bounds (rare)
<ul>
<li>E.g. <code>struct Weird&lt;'a, T: 'a + 'static&gt;(&amp;'a T);</code></li>
</ul>
</li>
</ul>
<p>And the behavior in various contexts is:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th><code>static</code></th><th><code>impl</code></th><th>[G]AT</th><th><code>fn</code> in</th><th><code>fn</code> out</th><th><code>fn</code> body</th></tr></thead><tbody>
<tr><td><code>Box&lt;dyn Trait&gt;</code></td><td><code>'static</code></td><td><code>'static</code></td><td><code>'static</code></td><td><code>'static</code></td><td><code>'static</code></td><td>Inferred</td></tr>
<tr><td><code>&amp;dyn Trait</code></td><td>Ref</td><td>Ref</td><td>E0637</td><td>Ref</td><td>Ref</td><td>Inferred</td></tr>
<tr><td><code>&amp;'a dyn Trait</code></td><td>Ref</td><td>Ref</td><td>Ref</td><td>Ref</td><td>Ref</td><td>Ref</td></tr>
<tr><td>Ambig.</td><td>E0228</td><td>E0228</td><td>E0228</td><td>E0228</td><td>E0228</td><td>Inferred</td></tr>
</tbody></table>
</div>
<p>With the following notes:</p>
<ul>
<li><code>type</code> alias bounds take precedence over the aliased type bounds</li>
<li>Associated type and GAT bounds do not effect the default</li>
</ul>
<p>For contrast, the "normal" elision rules work like so:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th><code>static</code></th><th><code>impl</code></th><th>[G]AT</th><th><code>fn</code> in</th><th><code>fn</code> out</th><th><code>fn</code> body</th></tr></thead><tbody>
<tr><td><code>Box&lt;dyn Tr + '_&gt;</code></td><td><code>'static</code></td><td>Fresh</td><td>E0637</td><td>Fresh</td><td>Elision</td><td>Inferred</td></tr>
<tr><td><code>&amp;(dyn Trait + '_</code>)</td><td><code>'static</code></td><td>Fresh</td><td>E0637</td><td>Fresh</td><td>Elision</td><td>Inferred</td></tr>
<tr><td><code>&amp;'a (dyn Trait + '_</code>)</td><td><code>'static</code></td><td>Fresh</td><td>E0637</td><td>Fresh</td><td>Elision</td><td>Inferred</td></tr>
<tr><td>Ambig. with <code>'_</code></td><td><code>'static</code></td><td>Fresh</td><td>E0637</td><td>Fresh</td><td>Elision</td><td>Inferred</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="influences-from-trait-lifetime-bounds"><a class="header" href="#influences-from-trait-lifetime-bounds">Influences from trait lifetime bounds</a></h1>
<p>When the trait itself has lifetime bounds, those bounds may influence the
behavior of <code>dyn Trait</code> lifetime elision.  Where and how the influence does
or does not take place is not properly documented, but we'll cover some
cases here.</p>
<p>The way trait object lifetime defaults behave in these scenarios is not
intuitive, and perhaps even arbitrary.  But to be clear, you will probably
never need to actually know the exact rules.  Traits with exotic lifetime
bounds are rare, and should you actually encounter one, you can usually
choose to be explicit instead of trying to figure out what lifetime is
the default when elided.</p>
<p>Which is to say, this subsection is more of an exploration of the
compiler's current behavior than something useful to learn.  If you're
trying to learn practical Rust, you should probably just skip it.</p>
<p>A very high level summary is:</p>
<ul>
<li>Trait bounds introduce implied bounds on the trait object lifetimes</li>
<li>Elision in the presence of non-<code>'static</code> trait lifetime bounds is arbitrary, so prefer to be explicit</li>
<li>Prefer not to add non-<code>'static</code> lifetime bounds to your own object safe traits
<ul>
<li>Avoid multiple lifetime bounds in particular</li>
</ul>
</li>
</ul>
<p>This section is also non-exhaustive.  Given how many exceptions I have ran across,
take my assertive statements in this section with a grain of salt.</p>
<h2 id="trait-lifetime-bounds-create-an-implied-bound"><a class="header" href="#trait-lifetime-bounds-create-an-implied-bound">Trait lifetime bounds create an implied bound</a></h2>
<p>The trait bound creates an implied bound on the <code>dyn Trait</code> lifetime:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait LifetimeTrait&lt;'a, 'b&gt;: 'a {}

pub fn f&lt;'b&gt;(_: Box&lt;dyn LifetimeTrait&lt;'_, 'b&gt; + 'b&gt;) {}

fn fp&lt;'a, 'b, 'c&gt;(t: Box&lt;dyn LifetimeTrait&lt;'a, 'b&gt; + 'c&gt;) {
    // This compiles which indicates an implied `'c: 'a` bound
    let c: &amp;'c [()] = &amp;[];
    let _: &amp;'a [()] = c;

    // This does not, demonstrating that `'c: 'b` is not implied
    // (i.e. the implied bound is on the trait object lifetime only, and
    // not on the other parameters.)
    //let _: &amp;'b [()] = c;

    // This does not as it requires `'c: 'b` and `'b: 'a`
    //f(t);
}
<span class="boring">}</span></code></pre></pre>
<p>This is similar to how <code>&amp;'b &amp;'a _</code> creates an implied <code>'a: 'b</code> bound.
It only applies to the trait object lifetime, and not the entirety
of the <code>dyn Trait</code> (e.g. it does not apply to trait parameters).</p>
<h2 id="the-static-case"><a class="header" href="#the-static-case">The <code>'static</code> case</a></h2>
<p>We've already summarized the behavior of trait object lifetime elision when
the trait itself has a <code>'static</code> bound as part of our basic guidelines: the
lifetime in this case is always <code>'static</code>.</p>
<p>This applies even to</p>
<ul>
<li>types with ambiguous (more than one) lifetime bounds</li>
<li>types with a single lifetime bound like <code>&amp;_</code>
<ul>
<li>i.e. the trait object lifetime (which is <code>'static</code>) becomes independent of the outer lifetime</li>
</ul>
</li>
<li>situations where a non-<code>'static</code> bound does <em>not</em> override the <code>&amp;_</code> trait object lifetime default, as in some of the examples further below</li>
</ul>
<p>This case applies even if there are multiple bounds and only one of them is
<code>'static</code>, in contrast with
<a href="./dyn-elision-advanced.html#ambiguous-bounds">bounds considered ambiguous from the struct definition.</a></p>
<h2 id="a-single-trait-lifetime-bound-does-not-always-apply"><a class="header" href="#a-single-trait-lifetime-bound-does-not-always-apply">A single trait lifetime bound does not always apply</a></h2>
<p>According to the reference, the default trait object lifetime for a trait
with a single lifetime bound in the context of a generic struct with no
lifetime bounds is always the lifetime in the trait's bound.</p>
<p>That's a mouthful, but the implication is that here:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Single&lt;'a&gt;: 'a {}
<span class="boring">}</span></code></pre></pre>
<p>The elided lifetime of <code>Box&lt;dyn Single&lt;'a&gt;&gt;</code> is always <code>'a</code>.</p>
<p>However, this is not actually the case:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Single&lt;'a&gt;: 'a {}
</span>// The elided lifetime was `'static`, not `'a`, so this compiles
fn foo&lt;'a&gt;(s: Box&lt;dyn Single&lt;'a&gt;&gt;) {
    let s: Box&lt;dyn Single&lt;'a&gt; + 'static&gt; = s;
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Single&lt;'a&gt;: 'a {}
</span>// In this case it *is* `'a`, so compilation fails
fn bar&lt;'a: 'a&gt;(s: Box&lt;dyn Single&lt;'a&gt;&gt;) {
    let s: Box&lt;dyn Single&lt;'a&gt; + 'static&gt; = s;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="when-they-apply-trait-lifetime-bounds-override-struct-bounds"><a class="header" href="#when-they-apply-trait-lifetime-bounds-override-struct-bounds">When they apply, trait lifetime bounds override struct bounds</a></h2>
<p>According to the reference, bounds on the trait never override bounds on
the struct.  But based on my testing, the opposite is true: <em>when</em> bounds
on the trait apply, they <em>always</em> override the bounds on the struct.</p>
<p>The complicated part is figuring out when they apply.</p>
<p>For example, the following compiles, but according to the reference it
should be ambiguous due to the multiple lifetime bounds on the struct.
It does not compile without the lifetime bound on the trait; the bound
on the trait is overriding the ambiguous bounds on the struct.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::marker::PhantomData;

// Remove `: 'a` to see the compile error
pub trait LifetimeTrait&lt;'a&gt;: 'a {}

pub struct Over&lt;'a, T: 'a + 'static + ?Sized&gt;(&amp;'a T);

pub struct Invariant&lt;T: ?Sized&gt;(*mut PhantomData&lt;T&gt;);
unsafe impl&lt;T: ?Sized&gt; Sync for Invariant&lt;T&gt; {}

pub static OS: Invariant&lt;Over&lt;'_, dyn LifetimeTrait&gt;&gt; = Invariant(std::ptr::null_mut());
<span class="boring">}</span></code></pre></pre>
<p>Further below are some examples where the trait bound overrides the
<code>&amp;_</code> bounds as well, so it is not just ambiguous struct bounds which can
be overridden by trait bounds.</p>
<h2 id="multiple-trait-bounds-can-be-ambiguous-or-can-apply"><a class="header" href="#multiple-trait-bounds-can-be-ambiguous-or-can-apply">Multiple trait bounds can be ambiguous or can apply</a></h2>
<p>The following is considered ambiguous due to the multiple lifetime bounds
on the trait.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Double&lt;'a, 'b&gt;: 'a + 'b {}
fn f&lt;'a, 'b, T: Double&lt;'a, 'b&gt; + 'static&gt;(t: T) {
    let bx: Box&lt;dyn Double&lt;'a, 'b&gt;&gt; = Box::new(t);

    // This version works:
    let bx: Box&lt;dyn Double&lt;'a, 'b&gt; + 'static&gt; = Box::new(t);
}
<span class="boring">}</span></code></pre></pre>
<p>The current documentation is silent on this point, but a multiple-bound
trait can still apply in such a way that it provides the default trait
object lifetime.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Double&lt;'a, 'b&gt;: 'a + 'b {}

fn x1&lt;'a: 'a, 'b&gt;(bx: Box&lt;dyn Double&lt;'a, 'b&gt;&gt;) {
    // This fails (the lifetime is not `'static`)
    //let bx: Box&lt;dyn Double&lt;'a, 'b&gt; + 'static&gt; = bx;

    // This also fails (the lifetime is not `'b` nor `'a + 'b`)
    //let bx: Box&lt;dyn Double&lt;'a, 'b&gt; + 'b&gt; = bx;

    // But this succeeds and we can conclude the lifetime is `'a`
    let bx: Box&lt;dyn Double&lt;'a, 'b&gt; + 'a&gt; = bx;
}
<span class="boring">}</span></code></pre></pre>
<p>There's a subtle point here: the elided trait object lifetime is <code>'a</code>,
but there's an implied <code>: 'a + 'b</code> bound on the trait object lifetime
due to the trait bounds.  Therefore the function signature has an
implied <code>'a: 'b</code> bound, similar to when you have a <code>&amp;'b &amp;'a _</code>
argument.</p>
<h2 id="trait-bounds-always-apply-in-function-bodies"><a class="header" href="#trait-bounds-always-apply-in-function-bodies">Trait bounds <em>always</em> apply in function bodies</a></h2>
<p>Based on my testing, the default trait object lifetime for annotations
of <code>dyn Trait</code> in function bodies is <em>always</em> the trait bound.  And in
fact, this bound <em>even overrides the wildcard <code>'_</code> lifetime annotation</em>.</p>
<p>This is a surprising exception to the <code>'_</code> annotation restoring "normal"
lifetime elision behavior.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Single&lt;'a&gt;: 'a {}

fn baz&lt;'long: 'a, 'a, T: 'long + Single&lt;'a&gt;&gt;(s: T) {
    // This compiles with the assignment at the end:
    //let s: Box&lt;dyn Single&lt;'a&gt; + 'long&gt; = Box::new(s);

    // But none of these compile because `'a: 'long` does not hold:
    //let s: Box&lt;dyn Single&lt;'a&gt;&gt; = Box::new(s);
    //let s: Box&lt;dyn Single&lt;'_&gt;&gt; = Box::new(s);
    //let s: Box&lt;dyn Single&lt;'a&gt; + '_&gt; = Box::new(s);
    //let s: Box&lt;dyn Single&lt;'_&gt; + '_&gt; = Box::new(s);
    //let s: Box&lt;dyn Single + '_&gt; = Box::new(s);
    let s: Box&lt;dyn Single&gt; = Box::new(s);

    let s: Box&lt;dyn Single&lt;'_&gt; + 'long&gt; = s;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="when-and-how-to-trait-lifetime-bounds-apply"><a class="header" href="#when-and-how-to-trait-lifetime-bounds-apply">When and how to trait lifetime bounds apply?</a></h2>
<p>Now that we've seen a number of examples, we can theorize when and how
trait lifetime bounds apply.  As the examples have already illustrated,
there are very different rules for different contexts.</p>
<h3 id="in-function-signatures"><a class="header" href="#in-function-signatures">In function signatures</a></h3>
<p>This appears to be the most complex and arbitrary context for trait object lifetime elision.</p>
<p>If you were paying close attention, you may have noticed that we occasionally had
trivial bounds like <code>'a: 'a</code> in the examples above, and that affected whether the
trait bounds applied or not.  A lifetime parameter of a function with no
<em>explicit</em> bounds is known as a late-bound parameter, and
<a href="https://github.com/rust-lang/rust/issues/47078">whether or not a lifetime is late-bound influences when the trait bounds apply
in function signatures.</a>
Parameters which are not late-bound are early-bound.</p>
<p>Let us call a lifetime parameter of a trait which is also a bound of the trait
a "bounding parameter".  My hypothesis on the behavior is as follows:</p>
<ul>
<li>if any trait bound is <code>'static</code>, the default lifetime is <code>'static</code></li>
<li>if any bounding parameter is explicitly <code>'static</code>, the default lifetime is <code>'static</code></li>
<li>if exactly one bounding parameter is early-bound, the default lifetime is that lifetime
<ul>
<li>including if it is in multiple positions, such as <code>dyn Double&lt;'a, 'a&gt;</code></li>
</ul>
</li>
<li>if more than one bounding parameter is early-bound, the default lifetime is ambiguous</li>
<li>if no bounding parameters are early-bound, the default lifetime depends on the <code>struct</code>
bounds (the same as they do for a trait without bounds)</li>
</ul>
<p>Note that in any case, the implied bounds on the trait object lifetime
that exist due to the trait bounds are still in effect.</p>
<p>The requirement that exactly one of the bounding parameters is early-bound
or that any of them are <code>'static</code> are syntactical requirements, rather than
semantic ones.  For example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Double&lt;'a, 'b&gt;: 'a + 'b {}

// Semantically, `'a` and `'b` must be `'static`.  However the
// parameters were not explicitly `'static` and thus this
// trait object lifetime is considered ambiguous (even though,
// due to the implied bounds, it must be `'static` too).
fn foo&lt;'a: 'static, 'b: 'static&gt;(d: Box&lt;dyn Double&lt;'a, 'b&gt;&gt;) {}

// Semantically, `'a` and `'b` must be the same.  They are also
// early-bound parameters due to the bounds.  However the parameters
// are not syntatically the same lifetime and thus this trait
// object lifetime is considered ambiguous.
fn bar&lt;'a: 'b, 'b: 'a&gt;(d: &amp;dyn Double&lt;'a, 'b&gt;) {}
<span class="boring">}</span></code></pre></pre>
<p>But if you change either example to <code>Double&lt;'a, 'a&gt;</code>, then
exactly one of the bounding parameters is early-bound, and they
will compile:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Double&lt;'a, 'b&gt;: 'a + 'b {}
</span>fn foo&lt;'a: 'static, 'b: 'static&gt;(d: Box&lt;dyn Double&lt;'a, 'a&gt;&gt;) {}
fn bar&lt;'a: 'b, 'b: 'a&gt;(d: &amp;dyn Double&lt;'a, 'a&gt;) {}
<span class="boring">}</span></code></pre></pre>
<h4 id="implicit-bounds-do-not-negate-being-late-bound"><a class="header" href="#implicit-bounds-do-not-negate-being-late-bound">Implicit bounds do not negate being late-bound</a></h4>
<p>Note that when considering <code>&amp;dyn Trait</code> there is always an <em>implied</em> bound between the
outer reference's lifetime and the <code>dyn Trait</code> (in addition to the implied bound from
the trait itself).  However, these implied bounds are not enough to make the trait
bound apply on their own.  A lifetime can be late-bound even when there are implied bounds.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait LifetimeTrait&lt;'a&gt;: 'a {}
impl LifetimeTrait&lt;'_&gt; for () {}

// All of these compile with the `fp` function below, indicating that
// the trait bound does in fact apply and results in a trait object
// lifetime independent of the reference lifetime
pub fn f&lt;'a: 'a&gt;(_: &amp;dyn LifetimeTrait&lt;'a&gt;) {}
//pub fn f&lt;'a: 'a&gt;(_: &amp;'_ dyn LifetimeTrait&lt;'a&gt;) {}
//pub fn f&lt;'r, 'a: 'a&gt;(_: &amp;'r dyn LifetimeTrait&lt;'a&gt;) {}
//pub fn f&lt;'r: 'r, 'a: 'a&gt;(_: &amp;'r dyn LifetimeTrait&lt;'a&gt;) {}
//pub fn f&lt;'r, 'a: 'r + 'a&gt;(_: &amp;'r dyn LifetimeTrait&lt;'a&gt;) {}
//pub fn f&lt;'r: 'r, 'a: 'r&gt;(_: &amp;'r dyn LifetimeTrait&lt;'a&gt;) {}

// However none of these compile with `fp`, indicating that the elided trait
// object lifetime is defaulting to the reference lifetime "per normal".
//pub fn f(_: &amp;dyn LifetimeTrait) {}
//pub fn f(_: &amp;'_ dyn LifetimeTrait) {}
//pub fn f&lt;'r&gt;(_: &amp;'r dyn LifetimeTrait) {}
//pub fn f&lt;'r: 'r&gt;(_: &amp;'r dyn LifetimeTrait) {}

//pub fn f(_: &amp;dyn LifetimeTrait&lt;'_&gt;) {}
//pub fn f(_: &amp;'_ dyn LifetimeTrait&lt;'_&gt;) {}
//pub fn f&lt;'r&gt;(_: &amp;'r dyn LifetimeTrait&lt;'_&gt;) {}
//pub fn f&lt;'r: 'r&gt;(_: &amp;'r dyn LifetimeTrait&lt;'_&gt;) {}

//pub fn f&lt;'a&gt;(_: &amp;dyn LifetimeTrait&lt;'a&gt;) {}
//pub fn f&lt;'a&gt;(_: &amp;'_ dyn LifetimeTrait&lt;'a&gt;) {}
//pub fn f&lt;'r, 'a&gt;(_: &amp;'r dyn LifetimeTrait&lt;'a&gt;) {}
//pub fn f&lt;'r: 'r, 'a&gt;(_: &amp;'r dyn LifetimeTrait&lt;'a&gt;) {}

// n.b. `'a` is invariant due to being a trait parameter
fn fp&lt;'a&gt;(t: &amp;(dyn LifetimeTrait&lt;'a&gt; + 'a)) {
    f(t);
}
<span class="boring">}</span></code></pre></pre>
<p>The above examples also demonstrate that when trait bounds apply,
they do override non-ambiguous struct bounds (such as those of <code>&amp;_</code>).</p>
<h4 id="implied-bounds-and-default-object-bounds-interact"><a class="header" href="#implied-bounds-and-default-object-bounds-interact">Implied bounds and default object bounds interact</a></h4>
<p>The interaction between what the default object lifetime is for a given
signature can interact in potentially surprising ways.  Consider this example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait LifetimeTrait&lt;'a&gt;: 'a {}
</span>// The implied bounds in `&amp;'outer (dyn Lifetime&lt;'param&gt; + 'trait)` are:
// - `'param: 'outer` (validity of the reference)
// - `'trait: 'outer` (validity of the reference)
// - `'trait: 'param` (from the trait bound)
//
// And as the trait bound does not apply to the elided parameter in this
// case, we also have `'outer = 'trait` due to the "normal" default
// lifetime behavior of `&amp;_`.  Adding that equality to the above bounds
// results in a requirement that *all three lifetimes are the same*.
//
// And thus this compiles:
pub fn g&lt;'r, 'a&gt;(d: &amp;'r dyn LifetimeTrait&lt;'a&gt;) {
    let r: [&amp;'r (); 1] = [&amp;()];
    let a: [&amp;'a (); 1] = [&amp;()];
    let _: [&amp;'a (); 1] = r;
    let _: [&amp;'r (); 1] = a;
    let _: &amp;'r (dyn LifetimeTrait&lt;'r&gt; + 'r) = d;
    let _: &amp;'a (dyn LifetimeTrait&lt;'a&gt; + 'a) = d;
}
<span class="boring">}</span></code></pre></pre>
<p>The results can be even more surprising with more complex bounds:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Double&lt;'a, 'b&gt;: 'a + 'b {}

fn h&lt;'a, 'b, T&gt;(bx: Box&lt;dyn Double&lt;'a, 'b&gt;&gt;, t: &amp;'a T)
where
    &amp;'a T: Send, // this makes `'a` early-bound
{
    // `bx` is `Box&lt;dyn Double&lt;'a, 'b&gt; + 'a&gt;` as per the rules above,
    // so this does not compile:
    //let _: Box&lt;dyn Double&lt;'a, 'b&gt; + 'static&gt; = bx;

    // However, the implied bounds still apply, which means:
    // - `'a: 'a + 'b`
    // - So `'a: 'b`
    //
    // Which is why this can compile even though that bound
    // is not declared anywhere!
    let t: &amp;'b T = t;

    // The lifetimes are still not the same, so this fails
    let _: &amp;'a T = t;
}
<span class="boring">}</span></code></pre></pre>
<p>The only reason that <code>'a: 'b</code> is an implied bound in the above example
is the interaction between</p>
<ul>
<li>the implied <code>: 'a + 'b</code> bound on the trait object lifetime</li>
<li>the default trait object lifetime being <code>'a</code>
<ul>
<li>due to <code>'a</code> being early-bound and <code>'b</code> being late-bound</li>
</ul>
</li>
</ul>
<p>If <code>'b</code> was also early-bound, the default trait object lifetime would
be ambiguous.  If <code>'a</code> wasn't early-bound, the default trait object
lifetime would be <code>'static</code> and there would be no implied <code>'a: 'b</code>
bound.</p>
<h4 id="the-wildcard-lifetime-still-introduces-a-fresh-inference-lifetime"><a class="header" href="#the-wildcard-lifetime-still-introduces-a-fresh-inference-lifetime">The wildcard lifetime still introduces a fresh inference lifetime</a></h4>
<p>Based on my testing, using <code>'_</code> will behave like typical lifetime elision,
introducing a fresh inference lifetime in input position, and following
the function signature elision rules in output position.</p>
<h4 id="higher-ranked-lifetimes-are-late-bound"><a class="header" href="#higher-ranked-lifetimes-are-late-bound">Higher-ranked lifetimes are late-bound</a></h4>
<p>Based on my testing, <code>for&lt;'a&gt; dyn Trait...</code> lifetimes act the same as
late-bound lifetimes.</p>
<h3 id="function-bodies"><a class="header" href="#function-bodies">Function bodies</a></h3>
<p>As mentioned above, trait object bounds always apply in function bodies,
similar to function signatures where every lifetime is early-bound.  This
is true regardless of whether the lifetimes are early or late bound in
the function signature.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Single&lt;'a&gt;: 'a {}

fn foo&lt;'r, 'a&gt;(bx: Box&lt;dyn Single&lt;'a&gt; + 'static&gt;, rf: &amp;'r (dyn Single&lt;'a&gt; + 'static)) {
    // Here it is `'a`, and not `'static` nor inferred
    let bx: Box&lt;dyn Single&lt;'a&gt;&gt; = bx;
    // So this fails
    //let _: Box&lt;dyn Single&lt;'a&gt; + 'static&gt; = bx;

    // Here it is `'a`, and not the same as the reference lifetime nor inferred
    let a: &amp;dyn Single&lt;'a&gt; = rf;
    // So this succeeds
    let _: &amp;(dyn Single&lt;'a&gt; + 'a) = a;
    // And this fails
    //let _: &amp;(dyn Single&lt;'a&gt; + 'static) = a;

    // Same behavior when the reference lifetime is explicit
    let a: &amp;'r dyn Single&lt;'a&gt; = rf;
    let _: &amp;'r (dyn Single&lt;'a&gt; + 'a) = a;
    //let _: &amp;'r (dyn Single&lt;'a&gt; + 'static) = a;

    // This also fails, demonstrating that `'r` is not `'a`
    //let _: &amp;'a &amp;'r () = &amp;&amp;();
}
<span class="boring">}</span></code></pre></pre>
<p>And unlike elsewhere, using <code>'_</code> in place of complete trait object
lifetime elision in the function body does not restore the normal
lifetime elision behavior (which would be inferring the lifetime).
All three of the examples above behave identically if <code>'_</code> is used.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Single&lt;'a&gt;: 'a {}
</span>fn foo&lt;'r, 'a&gt;(bx: Box&lt;dyn Single&lt;'a&gt; + 'static&gt;, rf: &amp;'r (dyn Single&lt;'a&gt; + 'static)) {
    let bx: Box&lt;dyn Single&lt;'a&gt; + '_&gt; = bx;
    // Fails
    //let _: Box&lt;dyn Single&lt;'a&gt; + 'static&gt; = bx;

    let a: &amp;(dyn Single&lt;'a&gt; + '_) = rf;
    let _: &amp;(dyn Single&lt;'a&gt; + 'a) = a;
    // Fails
    //let _: &amp;(dyn Single&lt;'a&gt; + 'static) = a;

    let a: &amp;'r (dyn Single&lt;'a&gt; + '_) = rf;
    let _: &amp;'r (dyn Single&lt;'a&gt; + 'a) = a;
    // Fails
    //let _: &amp;'r (dyn Single&lt;'a&gt; + 'static) = a;
}
<span class="boring">}</span></code></pre></pre>
<p>In combination with the behavior of function signatures, this can
lead to some awkward situations.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Double&lt;'a, 'b&gt;: 'a + 'b {}

// Here in the signature, `'_` acts like "normal" and creates an
// independent lifetime for the trait object lifetime; let us call
// it `'c`.  Though independent, it is related due to the implied
// bounds: `'c: 'a + 'b`
fn foo&lt;'a, 'b&gt;(bx: Box&lt;dyn Double&lt;'a, 'b&gt; + '_&gt;) {
    // Here in the body, the default trait object lifetime is
    // considered ambiguous, and `'_` does not override this.
    //
    // Moreover, there is no way to name `'c` since it was
    // elided in the signature.  We could annotate this as
    // either `'a` or `'b`, but cannot "preserve" the full
    // lifetime unless we change the function signature to
    // give the lifetime a name.
    let bx: Box&lt;dyn Double&lt;'a, 'b&gt; + '_&gt; = bx;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="static-contexts-1"><a class="header" href="#static-contexts-1">Static contexts</a></h3>
<p>In most static contexts, any elided lifetimes (not just trait object
lifetimes) default to the <code>'static</code> lifetime.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::marker::PhantomData;
</span>trait Single&lt;'a&gt;: 'a + Send + Sync {}
trait Halfie&lt;'a, 'b&gt;: 'a + Send + Sync {}
trait Double&lt;'a, 'b&gt;: 'a + 'b + Send + Sync {}

static BS: PhantomData&lt;Box&lt;dyn Single&lt;'_&gt;&gt;&gt; = PhantomData;
static BH: PhantomData&lt;Box&lt;dyn Halfie&lt;'_, '_&gt;&gt;&gt; = PhantomData;
static BD: PhantomData&lt;Box&lt;dyn Double&lt;'_, '_&gt;&gt;&gt; = PhantomData;

static S_BS: PhantomData&lt;Box&lt;dyn Single&lt;'static&gt; + 'static&gt;&gt; = BS;
static S_BH: PhantomData&lt;Box&lt;dyn Halfie&lt;'static, 'static&gt; + 'static&gt;&gt; = BH;
static S_BD: PhantomData&lt;Box&lt;dyn Double&lt;'static, 'static&gt; + 'static&gt;&gt; = BD;

const CS: PhantomData&lt;Box&lt;dyn Single&lt;'_&gt;&gt;&gt; = PhantomData;
const CH: PhantomData&lt;Box&lt;dyn Halfie&lt;'_, '_&gt;&gt;&gt; = PhantomData;
const CD: PhantomData&lt;Box&lt;dyn Double&lt;'_, '_&gt;&gt;&gt; = PhantomData;

const S_CS: PhantomData&lt;Box&lt;dyn Single&lt;'static&gt; + 'static&gt;&gt; = CS;
const S_CH: PhantomData&lt;Box&lt;dyn Halfie&lt;'static, 'static&gt; + 'static&gt;&gt; = CH;
const S_CD: PhantomData&lt;Box&lt;dyn Double&lt;'static, 'static&gt; + 'static&gt;&gt; = CD;
<span class="boring">}</span></code></pre></pre>
<p>However, from Rust 1.64 forward, associated <code>const</code>s were allowed to use general
elided lifetimes and the wildcard lifetime (as opposed to only elided
trait object lifetimes).  <a href="https://github.com/rust-lang/rust/issues/115010">This was an accidental stabilization which
will probably be removed or modified.</a></p>
<p>In the meanwhile, elided lifetimes act like independent lifetime
variables on the <code>impl</code> block.  Those in turn act like early-bound
lifetimes in function signatures.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::marker::PhantomData;
</span><span class="boring">trait Single&lt;'a&gt;: 'a + Send + Sync {}
</span>struct L&lt;'l, 'm&gt;(&amp;'l str, &amp;'m str);
impl&lt;'a, 'b&gt; L&lt;'a, 'b&gt; {
    const CS: PhantomData&lt;Box&lt;dyn Single&lt;'a&gt;&gt;&gt; = PhantomData;

    // Fails
    //const S_CS: PhantomData&lt;Box&lt;dyn Single&lt;'a&gt; + 'static&gt;&gt; = Self::CS;
    const S_CS: PhantomData&lt;Box&lt;dyn Single&lt;'a&gt; + 'a&gt;&gt; = Self::CS;
}
<span class="boring">}</span></code></pre></pre>
<p>Elided lifetimes can be inferred to be <code>'static</code> elsewhere...</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::marker::PhantomData;
</span><span class="boring">trait Single&lt;'a&gt;: 'a + Send + Sync {}
</span><span class="boring">struct L&lt;'l, 'm&gt;(&amp;'l str, &amp;'m str);
</span>impl&lt;'a, 'b&gt; L&lt;'a, 'b&gt; {
    const ECS: PhantomData&lt;Box&lt;dyn Single&lt;'_&gt;&gt;&gt; = PhantomData;
    const SCS: PhantomData&lt;Box&lt;dyn Single&lt;'static&gt;&gt;&gt; = PhantomData;

    const S_ECS: PhantomData&lt;Box&lt;dyn Single&lt;'static&gt; + 'static&gt;&gt; = Self::ECS;
    const S_SCS: PhantomData&lt;Box&lt;dyn Single&lt;'static&gt; + 'static&gt;&gt; = Self::SCS;
}
<span class="boring">}</span></code></pre></pre>
<p><em>...however,</em> it's really a free variable.  Therefore, cases such
as this are considered ambiguous:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::marker::PhantomData;
</span><span class="boring">trait Double&lt;'a, 'b&gt;: 'a + 'b + Send + Sync {}
</span><span class="boring">struct L&lt;'l, 'm&gt;(&amp;'l str, &amp;'m str);
</span>impl&lt;'a, 'b&gt; L&lt;'a, 'b&gt; {
    const EBCD: PhantomData&lt;Box&lt;dyn Double&lt;'a, '_&gt;&gt;&gt; = PhantomData;
}
<span class="boring">}</span></code></pre></pre>
<p>...and cases such this are considered to be a borrow check violation,
as there are no outlives relationships between the anonymously
introduced lifetime parameters:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::marker::PhantomData;
</span><span class="boring">trait Single&lt;'a&gt;: 'a + Send + Sync {}
</span>struct R&lt;'l, 'm, 'r&gt;(&amp;'l str, &amp;'m str, &amp;'r ());
impl&lt;'a, 'b, 'r&gt; R&lt;'a, 'b, 'r&gt; where 'a: 'r, 'b: 'r {
    const ECS: PhantomData&lt;&amp;dyn Single&lt;'_&gt;&gt; = PhantomData;
    const RECS: PhantomData&lt;&amp;'r dyn Single&lt;'_&gt;&gt; = PhantomData;
}
<span class="boring">}</span></code></pre></pre>
<p>(There is no implicit bound due to nesting the lifetimes because
the nesting occurs in the body of the <code>impl</code> block and not the header.)</p>
<h3 id="impl-headers-1"><a class="header" href="#impl-headers-1"><code>impl</code> headers</a></h3>
<p>Trait bounds always apply in <code>impl</code> headers.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Single&lt;'a&gt;: 'a {}
trait Halfie&lt;'a, 'b&gt;: 'a {}
trait Double&lt;'a, 'b&gt;: 'a + 'b {}

struct S&lt;T&gt;(T);

// The trait bounds apply
impl&lt;'a&gt; S&lt;Box&lt;dyn Single&lt;'a&gt;&gt;&gt; { fn f01() {} } // 'a (not 'static)
impl&lt;'a, 'r&gt; S&lt;&amp;'r dyn Single&lt;'a&gt;&gt; { fn f02() {} } // 'a (not 'r)
impl&lt;'a, 'b&gt; S&lt;Box&lt;dyn Halfie&lt;'a, 'b&gt;&gt;&gt; { fn f03() {} } // 'a (not 'static)
impl&lt;'a, 'b, 'r&gt; S&lt;&amp;'r dyn Halfie&lt;'a, 'b&gt;&gt; { fn f04() {} } // 'a (not 'r)
// Ambiguous (uncomment for error)
// impl&lt;'a, 'b&gt; S&lt;Box&lt;dyn Double&lt;'a, 'b&gt;&gt;&gt; { fn f05() {} }
// impl&lt;'a, 'b, 'r&gt; S&lt;&amp;'r dyn Double&lt;'a, 'b&gt;&gt; { fn f05() {} }

// Try `+ 'static` or `+ 'r` for errors
fn f&lt;'a, 'b, 'r&gt;(_: &amp;'r &amp;'a str, _: &amp;'r &amp;'b str) {
    S::&lt;Box&lt;dyn Single&lt;'a&gt; + 'a&gt;&gt;::f01();
    S::&lt;&amp;'r (dyn Single&lt;'a&gt; + 'a)&gt;::f02();
    S::&lt;Box&lt;dyn Halfie&lt;'a, 'b&gt; + 'a&gt;&gt;::f03();
    S::&lt;&amp;'r (dyn Halfie&lt;'a, 'b&gt; + 'a)&gt;::f04();
}
<span class="boring">}</span></code></pre></pre>
<p>As in function signatures, but unlike function bodies, the wildcard lifetime
<code>'_</code> acts like normal elision (introducing a new anonymous lifetime variable).</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Single&lt;'a&gt;: 'a {}
</span><span class="boring">trait Halfie&lt;'a, 'b&gt;: 'a {}
</span><span class="boring">trait Double&lt;'a, 'b&gt;: 'a + 'b {}
</span><span class="boring">struct S&lt;T&gt;(T);
</span>// The wildcard lifetime `'_` introduces an independent lifetime
// (covering all cases including `'static`) as per normal
impl&lt;'a&gt; S&lt;Box&lt;dyn Single&lt;'a&gt; + '_&gt;&gt; { fn f26() {} }
impl&lt;'a, 'r&gt; S&lt;&amp;'r (dyn Single&lt;'a&gt; + '_)&gt; { fn f27() {} }
impl&lt;'a, 'b&gt; S&lt;Box&lt;dyn Halfie&lt;'a, 'b&gt; + '_&gt;&gt; { fn f28() {} }
impl&lt;'a, 'b, 'r&gt; S&lt;&amp;'r (dyn Halfie&lt;'a, 'b&gt; + '_)&gt; { fn f29() {} }
impl&lt;'a, 'b&gt; S&lt;Box&lt;dyn Double&lt;'a, 'b&gt; + '_&gt;&gt; { fn f30() {} }
impl&lt;'a, 'b, 'r&gt; S&lt;&amp;'r (dyn Double&lt;'a, 'b&gt; + '_)&gt; { fn f31() {} }

fn f&lt;'a, 'b, 'r&gt;(_: &amp;'r &amp;'a str, _: &amp;'r &amp;'b str) {
    S::&lt;Box&lt;dyn Single&lt;'a&gt; + 'static&gt;&gt;::f26();
    S::&lt;&amp;'r (dyn Single&lt;'a&gt; + 'static)&gt;::f27();
    S::&lt;Box&lt;dyn Halfie&lt;'a, 'b&gt; + 'static&gt;&gt;::f28();
    S::&lt;&amp;'r (dyn Halfie&lt;'a, 'b&gt; + 'static)&gt;::f29();
    S::&lt;Box&lt;dyn Double&lt;'a, 'b&gt; + 'static&gt;&gt;::f30();
    S::&lt;&amp;'r (dyn Double&lt;'a, 'b&gt; + 'static)&gt;::f31();
}
<span class="boring">}</span></code></pre></pre>
<h3 id="associated-types-2"><a class="header" href="#associated-types-2">Associated types</a></h3>
<p>Similar to <code>impl</code> headers, trait bounds always apply to associated types.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::marker::PhantomData;
</span>trait Single&lt;'a&gt;: 'a {}
trait Halfie&lt;'a, 'b&gt;: 'a {}
trait Double&lt;'a, 'b&gt;: 'a + 'b {}

trait Assoc {
    type A01: ?Sized + Default;
    type A02: ?Sized + Default;
    //type A03: ?Sized + Default;
    type A04: ?Sized + Default;
    type A05: ?Sized + Default;
    //type A06: ?Sized + Default;
}

impl&lt;'r, 'a, 'b&gt; Assoc for (&amp;'r &amp;'a (), &amp;'r &amp;'b ()) {
    // '_ is not allowed here
    // &amp; /* elided */ is not allowed here
    type A01 = PhantomData&lt;Box&lt;dyn Single&lt;'a&gt;&gt;&gt;;
    type A02 = PhantomData&lt;Box&lt;dyn Halfie&lt;'a, 'b&gt;&gt;&gt;;
    // ambiguous
    // type A03 = PhantomData&lt;Box&lt;dyn Double&lt;'a, 'b&gt;&gt;&gt;;
    type A04 = PhantomData&lt;&amp;'r dyn Single&lt;'a&gt;&gt;;
    type A05 = PhantomData&lt;&amp;'r dyn Halfie&lt;'a, 'b&gt;&gt;;
    // ambiguous
    // type A06 = PhantomData&lt;&amp;'r dyn Double&lt;'a, 'b&gt;&gt;;
}

fn f&lt;'r, 'a: 'r, 'b: 'r&gt;() {
    // 'a (not `'static`, `'r`, `'b`)
    let _: PhantomData&lt;Box&lt;dyn Single&lt;'a&gt; + 'a&gt;&gt; = &lt;(&amp;'r &amp;'a (), &amp;'r &amp;'b ()) as Assoc&gt;::A01::default();
    let _: PhantomData&lt;Box&lt;dyn Halfie&lt;'a, 'b&gt; + 'a&gt;&gt; = &lt;(&amp;'r &amp;'a (), &amp;'r &amp;'b ()) as Assoc&gt;::A02::default();
    let _: PhantomData&lt;&amp;'r (dyn Single&lt;'a&gt; + 'a)&gt; = &lt;(&amp;'r &amp;'a (), &amp;'r &amp;'b ()) as Assoc&gt;::A04::default();
    let _: PhantomData&lt;&amp;'r (dyn Halfie&lt;'a, 'b&gt; + 'a)&gt; = &lt;(&amp;'r &amp;'a (), &amp;'r &amp;'b ()) as Assoc&gt;::A05::default();
}
<span class="boring">}</span></code></pre></pre>
<p>Note: I have not performed extensive tests with GATs or associated types which themselves
have lifetime bounds in combination with bounded traits.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="citations"><a class="header" href="#citations">Citations</a></h1>
<p>Finally we compare what we've covered about <code>dyn Trait</code> lifetime elision to the
current reference material, and supply some citations to the elision's storied
history.</p>
<h2 id="summary-of-differences-from-the-reference"><a class="header" href="#summary-of-differences-from-the-reference">Summary of differences from the reference</a></h2>
<p>The official documentation on trait object lifetime elision
<a href="https://doc.rust-lang.org/reference/lifetime-elision.html#default-trait-object-lifetimes">can be found here.</a></p>
<p>In summary, it states that <code>dyn Trait</code> lifetimes have a <em>default object lifetime bound</em> which varies based on context.
It states that the default bound only takes effect when the lifetime is <em>entirely</em> omitted.  When you write out <code>dyn Trait + '_</code>, the
<a href="https://doc.rust-lang.org/reference/lifetime-elision.html#lifetime-elision-in-functions">normal lifetime elision rules</a>
apply instead.</p>
<p>In particular, as of this writing, the official documentation states that</p>
<blockquote>
<p>If the trait object is used as a type argument of a generic type then the containing type is first used to try to infer a bound.</p>
<ul>
<li>If there is a unique bound from the containing type then that is the default</li>
<li>If there is more than one bound from the containing type then an explicit bound must be specified</li>
</ul>
<p>If neither of those rules apply, then the bounds on the trait are used:</p>
<ul>
<li>If the trait is defined with a single lifetime bound then that bound is used.</li>
<li>If <code>'static</code> is used for any lifetime bound then <code>'static</code> is used.</li>
<li>If the trait has no lifetime bounds, then the lifetime is inferred in expressions and is <code>'static</code> outside of expressions.</li>
</ul>
</blockquote>
<p>Some differences from the reference which we have covered are that</p>
<ul>
<li><a href="./dyn-elision-advanced.html#an-exception-to-inference-in-function-bodies">inferring bounds in expressions applies to <code>&amp;T</code> types unless annotated with a named lifetime</a></li>
<li><a href="./dyn-elision-advanced.html#ambiguous-bounds">inferring bounds in expressions applies to ambiguous types</a></li>
<li><a href="./dyn-elision-trait-bounds.html#when-they-apply-trait-lifetime-bounds-override-struct-bounds">when trait bounds apply, they override struct bounds, not the other way around</a></li>
<li><a href="./dyn-elision-trait-bounds.html#the-static-case">a <code>'static</code> trait bound always applies</a></li>
<li><a href="./dyn-elision-trait-bounds.html#when-and-how-to-trait-lifetime-bounds-apply">otherwise, whether trait bounds apply or not depends on complicated contextual rules</a>
<ul>
<li>they always apply in <code>impl</code> headers, associated types, and function bodies</li>
<li>and technically in <code>static</code> contexts, with some odd caveats</li>
<li>whether they apply in function signatures depends on the bounding parameters being late or early bound
<ul>
<li>a single parameter can apply to a trait bounds with multiple bounds in this context, introducing new implied lifetime bounds</li>
</ul>
</li>
</ul>
</li>
<li><a href="./dyn-elision-trait-bounds.html#function-bodies">trait bounds override <code>'_</code> in function bodies</a></li>
</ul>
<p>And some other under or undocumented behaviors are that</p>
<ul>
<li><a href="./dyn-elision-advanced.html#iteraction-with-type-aliases">aliases override struct definitions</a></li>
<li><a href="./dyn-elision-trait-bounds.html#trait-lifetime-bounds-create-an-implied-bound">trait bounds create implied bounds on the trait object lifetime</a></li>
<li><a href="./dyn-elision-advanced.html#associated-types-and-gats">associated type and GAT bounds do not effect the default trait object lifetime</a></li>
</ul>
<h2 id="rfcs-issues-and-prs"><a class="header" href="#rfcs-issues-and-prs">RFCs, Issues, and PRs</a></h2>
<p>Trait objects, and trait object lifetime elision in particular, has undergone a lot of evolution over time.
Here we summarize some of the major developments and issues.</p>
<p>Reminder: a lot of these citations predate the <a href="https://rust-lang.github.io/rfcs/2113-dyn-trait-syntax.html"><code>dyn Trait</code> syntax.</a>
Trait objects used to be just "spelled" as <code>Trait</code> in type position, instead of <code>dyn Trait</code>.</p>
<ul>
<li><a href="https://rust-lang.github.io/rfcs/0192-bounds-on-object-and-generic-types.html#lifetime-bounds-on-object-types">RFC 0192</a> first introduced the trait object lifetime
<ul>
<li><a href="https://rust-lang.github.io/rfcs/0192-bounds-on-object-and-generic-types.html#appendix-b-why-object-types-must-have-exactly-one-bound">including the "intersection lifetime" consideration</a></li>
</ul>
</li>
<li><a href="https://rust-lang.github.io/rfcs/0599-default-object-bound.html">RFC 0599</a> first introduced <em>default</em> trait object lifetimes (<code>dyn Trait</code> lifetime elision)</li>
<li><a href="https://rust-lang.github.io/rfcs/1156-adjust-default-object-bounds.html">RFC 1156</a> superseded RFC 0599 (<code>dyn Trait</code> lifetime elision)</li>
<li><a href="https://github.com/rust-lang/rust/pull/39305">PR 39305</a> modified RFC 1156 (unofficially) to <a href="dyn-elision-advanced.html#an-exception-to-inference-in-function-bodies">allow more inference in function bodies</a></li>
<li><a href="https://rust-lang.github.io/rfcs/2093-infer-outlives.html#trait-object-lifetime-defaults">RFC 2093</a> defined <a href="dyn-elision-advanced.html#guiding-behavior-of-your-own-types">how <code>struct</code> bounds interact with <code>dyn Trait</code> lifetime elision</a></li>
<li><a href="https://github.com/rust-lang/rust/issues/100270">Issue 100270</a> notes that type aliases take precedent in terms of RFC 2093 <code>dyn Trait</code> lifetime elision rules</li>
<li><a href="https://github.com/rust-lang/rust/issues/47078">Issue 47078</a> notes that being late-bound influences <code>dyn Trait</code> lifetime elision</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn-trait-vs-alternatives"><a class="header" href="#dyn-trait-vs-alternatives"><code>dyn Trait</code> vs. alternatives</a></h1>
<p>When getting familiar with Rust, it can be hard at first to
recognize when you should use <code>dyn Trait</code> versus some other
type mechanism, such as <code>impl Trait</code> or generics.</p>
<p>In this section we look at some tradeoffs, depending on the
use case.</p>
<h2 id="generic-functions-and-argument-position-impl-trait"><a class="header" href="#generic-functions-and-argument-position-impl-trait">Generic functions and argument position <code>impl Trait</code></a></h2>
<h3 id="preliminaries-what-is-argument-position-impl-trait"><a class="header" href="#preliminaries-what-is-argument-position-impl-trait">Preliminaries: What is argument position <code>impl Trait</code>?</a></h3>
<p>When we talk about argument position <code>impl Trait</code>, aka APIT,
we're talking about functions such as this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span>fn foo(d: impl Display) { println!("{d}"); }
// APIT:  ^^^^^^^^^^^^
<span class="boring">}</span></code></pre></pre>
<p>That is, <code>impl Trait</code> as an argument type of a function.</p>
<p>APIT is, so far at least, mostly the same as a generic parameter:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span>fn foo&lt;D: Display&gt;(d: D) { println!("{d}"); }
<span class="boring">}</span></code></pre></pre>
<p>The main difference is that generics allow</p>
<ul>
<li>the function writer to refer to <code>D</code>
<ul>
<li>e.g. <code>D::to_string(&amp;d)</code></li>
</ul>
</li>
<li>other utilizers to turbofish the function
<ul>
<li>e.g. <code>let function_pointer = foo::&lt;String&gt;;</code></li>
</ul>
</li>
</ul>
<p>Whereas the <code>impl Display</code> parameter is not nameable inside nor
outside the function.</p>
<p>There may be more differences in the future, but for now at least,
generics are the more flexible and thus superior form -- unless you
have a burning hatred against the <code>&lt;...&gt;</code> syntax, anyway.</p>
<p>At any rate, comparing <code>dyn Trait</code> against APIT is essentially the
same as comparing <code>dyn Trait</code> against a function with a generic type
parameter.</p>
<h3 id="tradeoffs-between-generic-functions-and-dyn-trait"><a class="header" href="#tradeoffs-between-generic-functions-and-dyn-trait">Tradeoffs between generic functions and <code>dyn Trait</code></a></h3>
<p>Here, we're talking about choosing between signatures like so:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span>// Owned or borrowed generics
fn foo1&lt;T: Trait&gt;(t: T) {}
fn bar1&lt;T: Trait + ?Sized&gt;(t: &amp;T) {}

// Owned or borrowed `dyn Trait`
fn foo2(t: Box&lt;dyn Trait + '_&gt;) {}
fn bar2(t: &amp;dyn Trait) {}
<span class="boring">}</span></code></pre></pre>
<p>When a function has a generic parameter, the parameter is <em>monomorphized</em>
for every concrete type which is used to call the function (after lifetime
erasure).  That is, every type the parameter takes on results in a distinct
function in the compiled code.  (Some of the resulting functions may be
eliminated or combined by optimization if possible).  There could be many
copies of <code>foo1</code> and <code>bar1</code>, depending on how it's called.</p>
<p>But (after lifetime erasure), <code>dyn Trait</code> is a singular concrete type.
There will only be one copy of <code>foo2</code> and <code>bar2</code>.</p>
<p>Yet in your typical Rust program, generic arguments are preferred over
<code>dyn Trait</code> arguments.  Why is that?  There are a number of reasons:</p>
<ul>
<li>Each monomorphized function can typically be optimized better</li>
<li>Trait bounds are more general than <code>dyn Trait</code>
<ul>
<li>No <code>dyn</code> safety concerns (<code>T: Clone</code> is possible)</li>
<li>No single trait restriction (<code>T: Trait1 + Trait2</code> is allowed)</li>
</ul>
</li>
<li>Less indirection through dynamic dispatch</li>
<li>No need for boxing in the owned case
<ul>
<li><code>Box</code> isn't even available in <code>#![no_std]</code> programs</li>
</ul>
</li>
</ul>
<p>The <code>dyn Trait</code> versions do have the following advantages:</p>
<ul>
<li>Smaller code size</li>
<li>Faster code generation</li>
<li><a href="./dyn-trait-erased.html">Do not make traits <code>dyn</code>-unsafe</a></li>
</ul>
<p>In general, you should prefer generics unless you have a specific
reason to opt for <code>dyn Trait</code> in argument position.</p>
<h2 id="return-position-impl-trait-and-tait"><a class="header" href="#return-position-impl-trait-and-tait">Return position <code>impl Trait</code> and TAIT</a></h2>
<h3 id="preliminaries-what-are-return-position-impl-trait-and-tait"><a class="header" href="#preliminaries-what-are-return-position-impl-trait-and-tait">Preliminaries: What are return position <code>impl Trait</code> and TAIT?</a></h3>
<p>When we talk about return position <code>impl Trait</code>, aka RPIT, we're talking
about functions such as this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// RPIT:                vvvvvvvvvvvvvvvvvvvvvvv
fn foo&lt;T&gt;(v: Vec&lt;T&gt;) -&gt; impl Iterator&lt;Item = T&gt; {
    v.into_iter().inspect(|t| println!("{t:p}"))
}
<span class="boring">}</span></code></pre></pre>
<p>Unlike <abbr title="argument position impl trait">APIT</abbr>,
RPITs are not the same as a generic type parameter.  They are instead
opaque type aliases or opaque type alias constructors.  In the above
example, the RPIT is an opaque type alias constructor which depends
on the input type parameter of the function (<code>T</code>).  For every concrete
<code>T</code>, the RPIT is also an alias of a <em><strong>singular</strong></em> concrete type.</p>
<p>The function body and the compiler still know what the concrete type is,
but that is opaque to the caller and other code.  Instead, the only ways
you can use the type are those which are compatible with the trait or
traits in the <code>impl Trait</code>, plus any auto traits which the concrete type
happens to implement.  (Or things provable from such properties, such
as blanket trait implementations.)</p>
<p>The singular part is key: the following code does not compile because
it is trying to return two distinct types.  Rust is strictly and
statically typed, so this is not possible -- the opacity of the RPIT
does not and cannot change that.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span>fn foo(b: bool) -&gt; impl Display {
    if b { 0 } else { "hi!" }
}
<span class="boring">}</span></code></pre></pre>
<p><code>type</code> alias <code>impl Trait</code>, or TAIT, is a generalization of RPIT which
<a href="https://github.com/rust-lang/rust/issues/63063">is not yet stable,</a>
but will probably become stable before <em>too</em> much longer.  TAIT allows
one to define aliases for opaque types, which allows them to be named
and to be used in more than one location.</p>
<pre><pre class="playground"><code class="language-rust nightly edition2021"><span class="boring">#![allow(unused)]
</span>#![feature(type_alias_impl_trait)]
<span class="boring">fn main() {
</span>type MyDisplay = impl std::fmt::Display;

fn foo() -&gt; MyDisplay { "hello," }
fn bar() -&gt; MyDisplay { " world" }
<span class="boring">}</span></code></pre></pre>
<p>Notionally (and hopefully literally), RPIT desugars to a TAIT in
a manner similar to this:</p>
<pre><pre class="playground"><code class="language-rust nightly edition2021"><span class="boring">#![allow(unused)]
</span>#![feature(type_alias_impl_trait)]
<span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span>fn foo1() -&gt; impl Display { "hi" }

// Same thing... or so
type __Unnameable_Tait = impl Display;
fn foo2() -&gt; __Unnameable_Tait { "hi" }
<span class="boring">}</span></code></pre></pre>
<p>TAITs must still be an alias of a singular, concrete type.</p>
<p>Other downsides of opaque types generally from the perspective of the caller include</p>
<ul>
<li>Opaque types are invariant on all parameters, whereas nominal structs need not be</li>
<li>No traits, including local traits, can be implemented on opaque types</li>
<li>All of a nominal structs trait implementations, public fields, and public inherent
methods are available, while opaque types reveal much less</li>
</ul>
<h3 id="tradeoffs-between-rpit-and-dyn-trait"><a class="header" href="#tradeoffs-between-rpit-and-dyn-trait">Tradeoffs between RPIT and <code>dyn Trait</code></a></h3>
<p>RPITs and <code>dyn Trait</code> returns share some benefits for the function writer:</p>
<ul>
<li>So long as the bounds don't change, you can change the concrete or base type</li>
<li>You can return unnameable types, such as closures</li>
<li>It simplifies complicated types, such as long iterator combinator chains</li>
</ul>
<p><code>dyn Trait</code> does have some limitations and downsides:</p>
<ul>
<li>Only one non-auto-trait is supportable without <a href="./dyn-trait-combining.html">subtrait boilerplate</a>
<ul>
<li>In contrast, with RPIT you can return <code>impl Trait1 + Trait2</code></li>
</ul>
</li>
<li>Only <code>dyn</code>-safe traits are supportable
<ul>
<li>In contrast, with RPIT you can return <code>impl Clone</code></li>
</ul>
</li>
<li>Boxing in some form is required to returned owned types</li>
<li>You pay the typical optimization penalties of not knowing the base type and performing dynamic dispatch</li>
</ul>
<p>However, RPITs also have their downsides:</p>
<ul>
<li>As an opaque alias, you can only return one actual, concrete type</li>
<li>For now, the return type is unnameable, which can be awkward for consumers
<ul>
<li>e.g. you can't store the result as a non-generic field in your struct</li>
<li>...unless the opaque type bounds are <code>dyn</code>-safe and you can type erase it yourself</li>
</ul>
</li>
<li>Auto-traits are leaky, so it's easy for the function writer to accidentally break SemVer
<ul>
<li>Whereas auto-traits are explicit with <code>dyn Trait</code></li>
</ul>
</li>
<li>RPIT methods in traits (stabilized in Rust 1.75) are <a href="dyn-safety.html">not <code>dyn</code>-dispatchable</a></li>
<li>Every RPIT is a distinct opaque type (note that TAIT works around this restriction)</li>
</ul>
<p>RPITs also have some rather tricky behavior around type parameter and lifetime capture.
The planned <code>impl Trait</code> functionalities deserve their own exploration independent of
<code>dyn Trait</code>, so I'll only mention them in brief:</p>
<ul>
<li>RPIT captures all type parameters (<a href="https://github.com/rust-lang/rust/issues/42940">and their implied lifetimes</a>)
<ul>
<li>And also lifetime parameters, in traits and <a href="https://github.com/rust-lang/rust/issues/117587">in edition 2024</a></li>
</ul>
</li>
<li>RPIT captures specific lifetimes and not <a href="./dyn-trait-lifetime.html#when-multiple-lifetimes-are-involved">the intersection of all lifetimes</a>
<ul>
<li>And thus it is <a href="https://github.com/danielhenrymantilla/fix_hidden_lifetime_bug.rs">tedious to capture an intersection of input lifetimes</a> instead of a union</li>
<li>(The situation will be improved by <a href="https://github.com/rust-lang/rust/issues/123432">precise capturing</a>)</li>
</ul>
</li>
</ul>
<p>Despite all these downsides, I would say that RPIT has a <em>slight</em> edge over <code>dyn Trait</code>
in return position <em>when applicable,</em> especially for owned types.  The advantage between
<code>dyn Trait</code> and a (named) TAIT will be even greater, once that is available:</p>
<ul>
<li>You can give the return type a name and reuse it in multiple places</li>
<li>TAIT inherently has precise capturing
<ul>
<li>I.e. you have control over, and are explicit about, which lifetime and type parameters are captured</li>
</ul>
</li>
</ul>
<p>But <code>dyn Trait</code> will still sometimes the better option, e.g.:</p>
<ul>
<li>when you need to type erase and return distinct types</li>
<li>when you need trait object safety</li>
</ul>
<p>However, there is often a third possibility available, which we explore below:
return a generic struct.</p>
<h3 id="an-alternative-to-both-nominal-generic-structs"><a class="header" href="#an-alternative-to-both-nominal-generic-structs">An alternative to both: nominal generic structs</a></h3>
<p>Here we can take inspiration from the standard library.  One of the more popular
situations to use RPIT or return <code>dyn Trait</code> is when dealing with iterators
(as iterator chains have long types and often involve unnameable types such as
closures as well).
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">So let's look at the Iterator methods.</a></p>
<p>You may notice a pattern with the combinators:</p>
<pre><code class="language-rust ignore">fn chain&lt;U&gt;(self, other: U) -&gt; Chain&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;
where
    Self: Sized,
    U: IntoIterator&lt;Item = Self::Item&gt;,
{ todo!() }

fn filter&lt;P&gt;(self, predicate: P) -&gt; Filter&lt;Self, P&gt;
where
    Self: Sized,
    P: FnMut(&amp;Self::Item) -&gt; bool,
{ todo!() }

fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;
where
    Self: Sized,
    F: FnMut(Self::Item) -&gt; B,
{ todo!() }</code></pre>
<p>The pattern is to have a function which is parameterized by a generic type
return a concrete (nominal) struct, also parameterized by the generic type.
This is possible even if the parameter itself is unnameable -- for example,
in the case of <code>map</code>, the <code>F: FnMut(Self::Item) -&gt; B</code> parameter might well
be an unnameable closure.</p>
<p>The downside is much more boilerplate if you opt to follow this pattern
yourself: You have to define the struct, and (for examples like these)
implement the <code>Iterator</code> trait for them, and perhaps other traits such
as <code>DoubleEndedIterator</code> as desired.  This will probably involve storing
the original iterator and calling <code>next().map(|item| ...)</code> on it, or
such.</p>
<p>The upside is that you (and the consumers of your method) get many of the upsides of both RPIT and <code>dyn Trait</code>:</p>
<ul>
<li>No dynamic dispatch penalty</li>
<li>No boxing penalty</li>
<li>No concrete-type specific optimization loss</li>
<li>No single trait limitation</li>
<li>No <code>dyn</code>-safe limitation</li>
<li>Applicable in traits</li>
<li>Ability to be specific about captures</li>
<li>Ability to change your implementation within the API bounds</li>
<li>Nameable return type</li>
</ul>
<p>You do retain some of the downsides:</p>
<ul>
<li>Auto-traits are leaky and still a semver hazard, as with RPIT</li>
<li>Multiple concrete types aren't possible (without also utilizing type erasure), as with RPIT</li>
</ul>
<p>And incur some unique ones as well:</p>
<ul>
<li>Variance of data types are leaky too</li>
<li>Unnameable types that aren't input type parameters can't be supported (without also utilizing type erasure)</li>
</ul>
<p>On the whole, when using a nominal type is possible, it is the best option for
consumers of the function.  But it's also the most amount of work for the function
implementor.</p>
<p>I recommend nominal types for general libraries (i.e. intended for wide consumption)
when possible, following the lead of the standard library.</p>
<h2 id="generic-structs"><a class="header" href="#generic-structs">Generic structs</a></h2>
<p>In the last section, we covered how generic structs can often be used as an
alternative to RPIT or returning <code>dyn Trait</code> in some form.   A related question
is, when should you use type erasure within your data types?</p>
<p>The main reason to use type erasure in your data types are when you want to
treat implementors of a trait as if they were the same type, for instance when
storing a collection of callbacks.  In this case, the decision to use type
erasure is a question of functionality, and not really much of a choice.</p>
<p>However, you may also want to use type erasure in your data types in order
to make your own struct non-generic.  When your data type is generic, after
all, those who use your data type in such a way that the parameter takes on
more than one type will have to propagate the use of generics themselves, or
face the decision of type erasing your data type themselves.</p>
<p>This can not only be a question of ergonomics, but also of compile time and
even run time performance.  Compiling strictly more code by having all your
methods monomorphized will naturally tend to result in longer compile times,
and the increase in actual code size <em>can sometimes be slower at runtime</em>
than a touch of dynamic dispatch in the right areas.</p>
<p>Unfortunately, there is no silver bullet when it comes to choosing between
being generic and using type erasure.  However, a general principle is that
your optimization sensitive, call-heavy code areas should not be type erased,
and instead push type erasure to a boundary outside of your heavy computations.</p>
<p>For example, the failure to devirtualize and inline a call to
<code>&lt;dyn Iterator&gt;::next</code> in a tight loop may have a relatively large impact,
whereas a dynamic callback that only fires occasionally (and then dispatches
to the optimized, non-type-erased implementation) is not likely to be
noticeable at all.</p>
<h2 id="enums"><a class="header" href="#enums"><code>enum</code>s</a></h2>
<p>Finally we'll mention one other alternative to type erasure:
just put all of the implementing types in an <code>enum</code>!</p>
<p>This clearly only applies when you have a fixed set of types that you
expect to implement your trait.  The downside of using an <code>enum</code> is that
it can involve a lot of boilerplate, since you're frequently having to check
which variant you are instead of relying on dynamic dispatch to perform
that function for you.</p>
<p>The upside is avoiding practically all of the downsides of type erasure
and the other alternatives such as opaque types.</p>
<p>Macros can help ease the pain of such boilerplate, and there are also
<a href="https://crates.io/crates/ambassador">crates in the ecosystem</a> aimed at
reducing the boilerplate.</p>
<p>In fact, <a href="https://crates.io/crates/enum_dispatch">there are also crates for this pattern as a whole.</a></p>
<p>In particular, if you find yourself in a situation where you've
<a href="./dyn-any.html">chosen to use <code>dyn Any</code></a> but you find yourself with
a bunch of attempted downcasts against a known set of types, you
should <em>strongly</em> consider just using an <code>enum</code>.  It won't be much
less ergonomic (if at all) and will be more efficient.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn-trait-examples"><a class="header" href="#dyn-trait-examples"><code>dyn Trait</code> examples</a></h1>
<p>Here we provide some "recipes" for common <code>dyn Trait</code> implementation
patterns.</p>
<p>In the examples, we'll typically be working with <code>dyn Trait</code>, <code>Box&lt;dyn Trait&gt;</code>,
and so on for the sake of brevity.  But note that in more practical code, there
is a good chance you would also need to provide implementations for
<code>Box&lt;dyn Trait + Send + Sync&gt;</code> or other variations across auto-traits.  This
may be in place of implementations for <code>dyn Trait</code> (if you always need the
auto-trait bounds) or in addition to implementations for <code>dyn Trait</code>
(to provide maximum flexibility).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="combining-traits"><a class="header" href="#combining-traits">Combining traits</a></h1>
<p>Rust has no support for directly combining multiple non-auto traits
into one <code>dyn Trait1 + Trait2</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo { fn foo(&amp;self) {} }
trait Bar { fn bar(&amp;self) {} }

// Fails
let _: Box&lt;dyn Foo + Bar&gt; = todo!();
<span class="boring">}</span></code></pre></pre>
<p>However, the methods of a supertrait are available to the subtrait.
What's a supertrait?  A supertrait is a trait bound on <code>Self</code> in the
definition of the subtrait, like so:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Foo { fn foo(&amp;self) {} }
</span><span class="boring">trait Bar { fn bar(&amp;self) {} }
</span>trait Subtrait: Foo
//    ^^^^^^^^^^^^^  A supertrait bound
where
    Self: Bar,
//  ^^^^^^^^^ Another one
{}
<span class="boring">}</span></code></pre></pre>
<p>The supertrait bound is implied everywhere the subtrait bound is
present, and the methods of the supertrait are always available on
implementors of the subtrait.</p>
<p>Using these relationships, you can support something analogous to
<code>dyn Foo + Bar</code> by using <code>dyn Subtrait</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait Foo { fn foo(&amp;self) {} }
</span><span class="boring">trait Bar { fn bar(&amp;self) {} }
</span><span class="boring">impl Foo for () {}
</span><span class="boring">impl Bar for () {}
</span>trait Subtrait: Foo + Bar {}

// Blanket implement for everything that meets the bounds...
// ...including non-`Sized` types
impl&lt;T: ?Sized&gt; Subtrait for T where T: Foo + Bar {}

fn main() {
    let quz: &amp;dyn Subtrait = &amp;();
    quz.foo();
    quz.bar();
}</code></pre></pre>
<p>Note that despite the terminology, there is no sub/super <em>type</em> relationship
between sub/super traits, between <code>dyn SubTrait</code> and <code>dyn SuperTrait</code>,
between implementors of said traits, et cetera.
<a href="./dyn-trait-overview.html#dyn-trait-is-not-a-supertype">Traits are not about sub/super typing.</a></p>
<h2 id="manual-supertrait-upcasting"><a class="header" href="#manual-supertrait-upcasting">Manual supertrait upcasting</a></h2>
<p><a href="./dyn-trait-coercions.html#supertrait-upcasting">Supertrait upcasting is planned, but not yet stable.</a>
Until stabilized, if you need to cast something like <code>dyn Subtrait</code> to <code>dyn Foo</code>, you
have to supply the implementation yourself.</p>
<p>For a start, we could build it into our traits like so:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self) {}
    fn as_dyn_foo(&amp;self) -&gt; &amp;dyn Foo;
}
<span class="boring">}</span></code></pre></pre>
<p>But we can't supply a default function body, as <code>Self: Sized</code> is required to perform
the type erasing cast to <code>dyn Foo</code>.  We don't want that restriction or the method
won't be available on <code>dyn Supertrait</code>, which is not <code>Sized</code>.</p>
<p>Instead we can separate out the method and supply an implementation for all <code>Sized</code>
types, via another supertrait:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait AsDynFoo {
    fn as_dyn_foo(&amp;self) -&gt; &amp;dyn Foo;
}

trait Foo: AsDynFoo { fn foo(&amp;self) {} }
<span class="boring">}</span></code></pre></pre>
<p>And then supply the implementation for all <code>Sized + Foo</code> types:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait AsDynFoo { fn as_dyn_foo(&amp;self) -&gt; &amp;dyn Foo; }
</span><span class="boring">trait Foo: AsDynFoo { fn foo(&amp;self) {} }
</span>impl&lt;T: /* Sized + */ Foo&gt; AsDynFoo for T {
    fn as_dyn_foo(&amp;self) -&gt; &amp;dyn Foo {
        self
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler will supply the implementation for both <code>dyn AsDynFoo</code> and <code>dyn Foo</code>.</p>
<p>When we put this altogether with the <code>Subtrait</code> from above, we can now utilize
an explicit version of supertrait upcasting:</p>
<pre><pre class="playground"><code class="language-rust edition2021">trait Foo: AsDynFoo { fn foo(&amp;self) {} }
trait Bar: AsDynBar { fn bar(&amp;self) {} }

impl Foo for () {}
impl Bar for () {}

trait AsDynFoo { fn as_dyn_foo(&amp;self) -&gt; &amp;dyn Foo; }
trait AsDynBar { fn as_dyn_bar(&amp;self) -&gt; &amp;dyn Bar; }
impl&lt;T: Foo&gt; AsDynFoo for T { fn as_dyn_foo(&amp;self) -&gt; &amp;dyn Foo { self } }
impl&lt;T: Bar&gt; AsDynBar for T { fn as_dyn_bar(&amp;self) -&gt; &amp;dyn Bar { self } }

trait Subtrait: Foo + Bar {}
impl&lt;T: ?Sized&gt; Subtrait for T where T: Foo + Bar {}

fn main() {
    let quz: &amp;dyn Subtrait = &amp;();
    quz.foo();
    quz.bar();
    let _: &amp;dyn Foo = quz.as_dyn_foo();
    let _: &amp;dyn Bar = quz.as_dyn_bar();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-trait-for-boxdyn-trait"><a class="header" href="#impl-trait-for-boxdyn-trait"><code>impl Trait for Box&lt;dyn Trait&gt;</code></a></h1>
<p>Let's look at how one implements <code>Trait for Box&lt;dyn Trait + '_&gt;</code>.  One
thing to note off that bat is that most methods are going to involve
calling a method of the <code>dyn Trait</code> <em>inside</em> of our box, but if we just
use <code>self.method()</code> we would instantly recurse with the very method
we're writing (<code>&lt;Box&lt;dyn Trait&gt;&gt;::method</code>)!</p>
<p><em><strong>We need to take care to call <code>&lt;dyn Trait&gt;::method</code> and not <code>&lt;Box&lt;dyn Trait&gt;&gt;::method</code>
in those cases to avoid infinite recursion.</strong></em></p>
<p>Now that we've highlighted that consideration, let's dive right in:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn look(&amp;self);
    fn boop(&amp;mut self);
    fn bye(self) where Self: Sized;
}

impl Trait for Box&lt;dyn Trait + '_&gt; {
    fn look(&amp;self) {
        // We do NOT want to do this!
        // self.look()

        // That would recursively call *this* function!
        // We need to call `&lt;dyn Trait as Trait&gt;::look`.

        // Any of the below forms work, it depends on
        // how explicit you want to be.

        // Very explicit
        // &lt;dyn Trait as Trait&gt;::look(&amp;**self)

        // Yay auto-deref for function parameters
        // &lt;dyn Trait&gt;::look(self)

        // Very succinct and a "makes sense once you've
        // seen it enough times" form.  The first deref
        // is for the reference (`&amp;Self`) and the second
        // deref is for the `Box&lt;_&gt;`.
        (**self).look()
    }

    fn boop(&amp;mut self) {
        // This is similar to the `&amp;self` case
        (**self).boop()
    }

    fn bye(self) {
        // Uh... see below
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Oh yeah, that last one.  <a href="dyn-trait-impls.html#boxdyn-trait-and-dyn-trait-do-not-automatically-implement-trait">Remember what we said before?</a>
<code>dyn Trait</code> doesn't have this method, but <code>Box&lt;dyn Trait + '_&gt;</code> does.
The compiler isn't going to just guess what to do here (and couldn't if,
say, we needed a return value).  We can't move the <code>dyn Trait</code> out of
the <code>Box</code> because it's unsized.  And we can't
<a href="./dyn-any.html#downcasting-methods-are-not-trait-methods">downcast from <code>dyn Trait</code></a>
either; even if we could, it would rarely help here, as we'd have to both
impose a <code>'static</code> constraint and also know every type that implements our
trait to attempt downcasting on each one (or have some other clever scheme
for more efficient downcasting).</p>
<p>Ugh, no wonder <code>Box&lt;dyn Trait&gt;</code> doesn't implement <code>Trait</code> automatically.</p>
<p>Assuming we want to call <code>Trait::bye</code> on the erased type, are we out of luck?
No, there are ways to work around this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Supertrait bound
trait Trait: BoxedBye {
    fn bye(self);
}

trait BoxedBye {
    // Unlike `self: Self`, this does *not* imply `Self: Sized` and
    // thus *will* be available for `dyn BoxedBye + '_`... and for
    // `dyn Trait + '_` too, automatically.
    fn boxed_bye(self: Box&lt;Self&gt;);
}

// We implement it for all `Sized` implementors of `trait: Trait` by
// unboxing and calling `Trait::bye`
impl&lt;T: Trait&gt; BoxedBye for T {
    fn boxed_bye(self: Box&lt;Self&gt;) {
        &lt;Self as Trait&gt;::bye(*self)
    }
}

impl Trait for Box&lt;dyn Trait + '_&gt; {
    fn bye(self) {
        // This time we pass `self` not `*self`
        &lt;dyn Trait as BoxedBye&gt;::boxed_bye(self);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>By adding the supertrait bound, the compiler will supply an implementation of
<code>BoxedBye for dyn Trait + '_</code>.  That implementation will call the implementation
of <code>BoxedBye</code> for <code>Box&lt;Erased&gt;</code>, where <code>Erased</code> is the erased base type.  That
is our blanket implementation, which unboxes <code>Erased</code> and calls <code>Erased</code>'s
<code>Trait::bye</code>.</p>
<p>The signature of <code>&lt;dyn Trait as BoxedBye&gt;::boxed_bye</code> has a receiver with the
type <code>Box&lt;dyn Trait + '_&gt;</code>, which is exactly the same signature as
<code>&lt;Box&lt;dyn Trait + '_&gt; as Trait&gt;::bye</code>.  And that's how we were able to
complete the implementation of <code>Trait</code> for <code>Box&lt;dyn Trait + '_&gt;</code>.</p>
<p>Here's how things flow when calling <code>Trait::bye</code> on <code>Box&lt;dyn Trait + '_&gt;</code>:</p>
<pre><code class="language-rust ignore">&lt;Box&lt;dyn Trait&gt;&gt;::bye      (_: Box&lt;dyn Trait&gt;) -- just passed --&gt;
&lt;    dyn Trait &gt;::boxed_bye(_: Box&lt;dyn Trait&gt;) -- via vtable  --&gt;
&lt;      Erased  &gt;::boxed_bye(_: Box&lt;  Erased &gt;) -- via unbox   --&gt;
&lt;      Erased  &gt;::bye      (_:       Erased  ) :)</code></pre>
<p>There's rarely a reason to implement <code>BoxedBye for Box&lt;dyn Trait + '_&gt;</code>, since
that takes a nested <code>Box&lt;Box&lt;dyn Trait + '_&gt;&gt;</code> receiver.</p>
<p>Any <code>Sized</code> implementor of <code>Trait</code> will get our blanket implementation of
the <code>BoxedBye</code> supertrait "for free", so they don't have to do anything
special.</p>
<hr />
<p>The last thing I'll point out is how we did</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span>impl Trait for Box&lt;dyn Trait + '_&gt; {
// this:                     ^^^^
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p><a href="dyn-elision-basic.html#impl-headers">We didn't need to require <code>'static</code>, so this is more flexible.</a>
It's also very easy to forget.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clonable-boxdyn-trait"><a class="header" href="#clonable-boxdyn-trait">Clonable <code>Box&lt;dyn Trait&gt;</code></a></h1>
<p>What can you do if you want a <code>Box&lt;dyn Trait&gt;</code> that you can clone?
You can't have <code>Clone</code> as a <a href="dyn-trait-combining.html">supertrait,</a>
because <code>Clone</code> requires <code>Sized</code> and that will make <code>Trait</code> be
<a href="dyn-safety.html">non-object-safe.</a></p>
<p>You might be tempted to do this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn dyn_clone(&amp;self) -&gt; Self where Self: Sized;
}
<span class="boring">}</span></code></pre></pre>
<p>But then <code>dyn Trait</code> won't have the method available, and that will
<a href="dyn-trait-box-impl.html">be a barrier to implementing <code>Trait</code> for <code>Box&lt;dyn Trait&gt;</code>.</a></p>
<p>But hey, you know what?  Since this only really makes sense for
base types that implement <code>Clone</code>, we don't need a method that returns
<code>Self</code>.  The base types already have that, it's called <code>clone</code>.</p>
<p>What we ultimately want is to get a <code>Box&lt;dyn Trait&gt;</code> instead, like so:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn dyn_clone&lt;'s&gt;(&amp;self) -&gt; Box&lt;dyn Trait + 's&gt; where Self: 's;
}

// example implementor
impl Trait for String {
    fn dyn_clone&lt;'s&gt;(&amp;self) -&gt; Box&lt;dyn Trait + 's&gt; where Self: 's {
        Box::new(self.clone())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If we omit all the lifetime stuff, it only works with <code>Self: 'static</code>
due to the <a href="dyn-elision-basic.html">default <code>'static</code> lifetime.</a>  And
sometimes, that's perfectly ok!  But we'll stick with the more general
version for this example.</p>
<p>The example implementation will make <code>dyn Trait</code> do the right thing
(clone the underlying base type via its implementation).  We can't have
a default body though, because the implementation requires <code>Clone</code>
and <code>Sized</code>, which again, we don't want as bounds.</p>
<p>But this is exactly the situation we had when we looked at
<a href="./dyn-trait-combining.html#manual-supertrait-upcasting">manual supertrait upcasting</a>
and the <a href="./dyn-trait-box-impl.html"><code>self</code> receiver helper</a>
in previous examples.  The same pattern
will work here: move the method to a helper supertrait and supply
a blanket implementation for those cases where it makes sense.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait DynClone {
    fn dyn_clone&lt;'s&gt;(&amp;self) -&gt; Box&lt;dyn Trait + 's&gt; where Self: 's;
}

impl&lt;T: Clone + Trait&gt; DynClone for T {
    fn dyn_clone&lt;'s&gt;(&amp;self) -&gt; Box&lt;dyn Trait + 's&gt; where Self: 's {
        Box::new(self.clone())
    }
}

trait Trait: DynClone {}
<span class="boring">}</span></code></pre></pre>
<p>Now we're ready for <code>Box&lt;dyn Trait + '_&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait: DynClone {}
</span><span class="boring">trait DynClone {
</span><span class="boring">   fn dyn_clone&lt;'s&gt;(&amp;self) -&gt; Box&lt;dyn Trait + 's&gt; where Self: 's;
</span><span class="boring">}
</span><span class="boring">impl&lt;T: Clone + Trait&gt; DynClone for T {
</span><span class="boring">   fn dyn_clone&lt;'s&gt;(&amp;self) -&gt; Box&lt;dyn Trait + 's&gt; where Self: 's {
</span><span class="boring">       Box::new(self.clone())
</span><span class="boring">   }
</span><span class="boring">}
</span>impl Trait for Box&lt;dyn Trait + '_&gt; {}

impl Clone for Box&lt;dyn Trait + '_&gt; {
    fn clone(&amp;self) -&gt; Self {
        // Important! "recursive trait implementation" style
        (**self).dyn_clone()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It's important that we called <code>&lt;dyn Trait as DynClone&gt;::dyn_clone</code>!  Our
blanket implementation of <code>DynClone</code> was bounded on <code>Clone + Trait</code>, but
now we have implemented both of those for <code>Box&lt;dyn Trait + '_&gt;</code>.  If we
had just called <code>self.dyn_clone()</code>, the call graph would go like so:</p>
<pre><code class="language-rust ignore">&lt;Box&lt;dyn Trait&gt; as Clone   &gt;::clone()
&lt;Box&lt;dyn Trait&gt; as DynClone&gt;::dyn_clone()
&lt;Box&lt;dyn Trait&gt; as Clone   &gt;::clone()
&lt;Box&lt;dyn Trait&gt; as DynClone&gt;::dyn_clone()
&lt;Box&lt;dyn Trait&gt; as Clone   &gt;::clone()
&lt;Box&lt;dyn Trait&gt; as DynClone&gt;::dyn_clone()
...</code></pre>
<p>Yep, infinite recursion.  Just like when implementing <code>Trait for Box&lt;dyn Trait&gt;</code>,
we need to call the <code>dyn Trait</code> method directly to avoid this.</p>
<hr />
<p>There is also a crate for this use case: <a href="https://crates.io/crates/dyn_clone">the <code>dyn-clone</code> crate.</a></p>
<p>A comparison with the crate is beyond the scope of this guide for now.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="downcasting-self-parameters"><a class="header" href="#downcasting-self-parameters">Downcasting <code>Self</code> parameters</a></h1>
<p>Now let's move on to something a little more complicated.  We
<a href="./dyn-safety.html#use-of-self-limitations">mentioned before</a> that
<code>Self</code> is not accepted outside of the receiver, such as when it's
another parameter, as there is no guarantee that the other
parameter has the same base type as the receiver (and if they
are not the same base type, there is no actual implementation to
call).</p>
<p>Let's see how we can work around this to implement
<a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a>
for <code>dyn Trait</code>, despite the <code>&amp;Self</code> parameter.  The trait is a good
fit in the face of type erasure, as we can just return <code>None</code> when
the types don't match, indicating that comparison is not possible.</p>
<p><code>PartialOrd</code> requires <code>PartialEq</code>, so we'll tackle that as well.</p>
<h2 id="downcasting-with-dyn-any-to-emulate-dynamic-typing"><a class="header" href="#downcasting-with-dyn-any-to-emulate-dynamic-typing">Downcasting with <code>dyn Any</code> to emulate dynamic typing</a></h2>
<p>We haven't had to use <code>dyn Any</code> in the previous examples, because
we've been able to maneuver our implementations in such a way that
dynamic dispatch implicitly "downcasted" our erased types to their
concrete base types for us.  It's able to do this because the pointer
to the base type is coupled with a vtable that only accepts said base
type, and there is no need for actual dynamic typing or comparing types
at runtime.  The conversion is infallible for those cases.</p>
<p>However, now we have two wide pointers which may point to different
base types.  In this particular application, we only really need to
know if they have the same base type or not... though it would be
nice to have some <em>safe</em> way to recover the erased type of non-receiver
too, instead of whatever casting shenanigans might be necessary.</p>
<p>You might think you could somehow use the vtable pointers to see if
the base types are the same.  But unfortunately, <a href="https://doc.rust-lang.org/std/ptr/fn.eq.html">we can't rely on the
vtable to compare their types at runtime.</a></p>
<blockquote>
<p>When comparing wide pointers, both the address and the metadata are
tested for equality. However, note that comparing trait object pointers
(<code>*const dyn Trait</code>) is unreliable: pointers to values of the same
underlying type can compare unequal (because vtables are duplicated in
multiple codegen units), and pointers to values of different underlying
type can compare equal (since identical vtables can be deduplicated
within a codegen unit).</p>
</blockquote>
<p>That's right, false negatives <em>and</em> false positives.  Fun!</p>
<p>So we need a different mechanism to compare types and know when we
have two wide pointers to the same base type, and that's where <code>dyn Any</code>
comes in.  <a href="https://doc.rust-lang.org/std/any/trait.Any.html"><code>Any</code></a> is
the trait to emulate dynamic typing, and
<a href="https://doc.rust-lang.org/std/any/trait.Any.html#implementations">many fallible downcasting methods</a>
are supplied for the type-erased forms of <code>dyn Any</code>, <code>Box&lt;dyn Any + Send&gt;</code>,
et cetera.  This will allow us to not just compare for base type equality,
but also to safely recover the erased base type ("downcast").</p>
<p>The <code>Any</code> trait comes with a <code>'static</code> constraint for soundness reasons,
so note that our base types are going to be more limited for this example.</p>
<p>Additionally, the <a href="dyn-trait-coercions.html#supertrait-upcasting">lack of supertrait upcasting</a>
is going to make things less ergonomic than they will be once that feature is
available.</p>
<p>One last side note, <a href="./dyn-any.html">we look at <code>dyn Any</code> in a bit more detail later.</a></p>
<p>Well enough meta, let's dive in!</p>
<h2 id="partialeq"><a class="header" href="#partialeq"><code>PartialEq</code></a></h2>
<p>The general idea is that we're going to have a comparison trait, <code>DynCompare</code>,
and then implement <code>PartialEq</code> for <code>dyn DynCompare</code> in a universal manner.
Then our actual trait (<code>Trait</code>) can have <code>DynCompare</code> as a supertrait, and
implement <code>PartialEq</code> for <code>dyn Trait</code> by upcasting to <code>dyn DynCompare</code>.</p>
<p>In the implementation for <code>dyn DynCompare</code>, we're going to have to (attempt to)
downcast to the erased base type.  For that to be available we will need to
first be able to upcast from <code>dyn DynCompare</code> to <code>dyn Any</code>.</p>
<p>As the first step, we're going to use the "supertrait we can blanket implement"
pattern yet again to make a trait that can handle all of our supertrait upcasting needs.</p>
<p>Here it is, <a href="dyn-trait-combining.html#manual-supertrait-upcasting">similar to how we've done it before:</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::any::Any;

trait AsDynCompare: Any {
    fn as_any(&amp;self) -&gt; &amp;dyn Any;
    fn as_dyn_compare(&amp;self) -&gt; &amp;dyn DynCompare;
}

// Sized types only
impl&lt;T: Any + DynCompare&gt; AsDynCompare for T {
    fn as_any(&amp;self) -&gt; &amp;dyn Any {
        self
    }
    fn as_dyn_compare(&amp;self) -&gt; &amp;dyn DynCompare {
        self
    }
}

trait DynCompare: AsDynCompare {
    fn dyn_eq(&amp;self, other: &amp;dyn DynCompare) -&gt; bool;
}
<span class="boring">}</span></code></pre></pre>
<p>There's an <code>Any: 'static</code> bound which applies to <code>dyn Any + '_</code>, so
<a href="dyn-elision-trait-bounds.html#the-static-case">all of those <code>&amp;dyn Any</code> are actually <code>&amp;dyn Any + 'static</code>.</a>
I have also included an <code>Any</code> supertrait to <code>AsDynCompare</code>, so the
"always <code>'static</code>" property holds for <code>&amp;dyn DynCompare</code> as well, even
though it isn't strictly necessary.  This way, we don't have to worry
about being flexible with the trait object lifetime at all -- it is
just always <code>'static</code>.</p>
<p>The downside is that only base types that satisfy the <code>'static</code> bound
can be supported, so there may be niche circumstances where you don't
want to include the supertrait bound.  However, given that we need to
upcast to <code>dyn Any</code>, this must mean you're pretending to be another
type, which seems quite niche indeed.  If you do try the non-<code>'static</code>
route for your own use case, note that some of the implementations in
this example could be made more general.</p>
<p>Anyway, let's move on to performing cross-type equality checking:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::any::Any;
</span><span class="boring">
</span><span class="boring">trait AsDynCompare: Any {
</span><span class="boring">   fn as_any(&amp;self) -&gt; &amp;dyn Any;
</span><span class="boring">   fn as_dyn_compare(&amp;self) -&gt; &amp;dyn DynCompare;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T: Any + DynCompare&gt; AsDynCompare for T {
</span><span class="boring">   fn as_any(&amp;self) -&gt; &amp;dyn Any {
</span><span class="boring">       self
</span><span class="boring">   }
</span><span class="boring">   fn as_dyn_compare(&amp;self) -&gt; &amp;dyn DynCompare {
</span><span class="boring">       self
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait DynCompare: AsDynCompare {
</span><span class="boring">   fn dyn_eq(&amp;self, other: &amp;dyn DynCompare) -&gt; bool;
</span><span class="boring">}
</span>impl&lt;T: Any + PartialEq&gt; DynCompare for T {
    fn dyn_eq(&amp;self, other: &amp;dyn DynCompare) -&gt; bool {
        if let Some(other) = other.as_any().downcast_ref::&lt;Self&gt;() {
            self == other
        } else {
            false
        }
    }
}

// n.b. this could be implemented in a more general way when
// the trait object lifetime is not constrained to `'static`
impl PartialEq&lt;dyn DynCompare&gt; for dyn DynCompare {
    fn eq(&amp;self, other: &amp;dyn DynCompare) -&gt; bool {
        self.dyn_eq(other)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here we've utilized our <code>dyn Any</code> upcasting to try and recover a
parameter of our own base type, and if successful, do the actual
(partial) comparison.  Otherwise we say they're not equal.</p>
<p>This allows us to implement <code>PartialEq</code> for <code>dyn Compare</code>.</p>
<p>Then we want to wire this functionality up to our actual trait:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::any::Any;
</span><span class="boring">
</span><span class="boring">trait AsDynCompare: Any {
</span><span class="boring">   fn as_any(&amp;self) -&gt; &amp;dyn Any;
</span><span class="boring">   fn as_dyn_compare(&amp;self) -&gt; &amp;dyn DynCompare;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T: Any + DynCompare&gt; AsDynCompare for T {
</span><span class="boring">   fn as_any(&amp;self) -&gt; &amp;dyn Any {
</span><span class="boring">       self
</span><span class="boring">   }
</span><span class="boring">   fn as_dyn_compare(&amp;self) -&gt; &amp;dyn DynCompare {
</span><span class="boring">       self
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait DynCompare: AsDynCompare {
</span><span class="boring">   fn dyn_eq(&amp;self, other: &amp;dyn DynCompare) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">impl&lt;T: Any + PartialEq&gt; DynCompare for T {
</span><span class="boring">   fn dyn_eq(&amp;self, other: &amp;dyn DynCompare) -&gt; bool {
</span><span class="boring">       if let Some(other) = other.as_any().downcast_ref::&lt;Self&gt;() {
</span><span class="boring">           self == other
</span><span class="boring">       } else {
</span><span class="boring">           false
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PartialEq&lt;dyn DynCompare&gt; for dyn DynCompare {
</span><span class="boring">   fn eq(&amp;self, other: &amp;dyn DynCompare) -&gt; bool {
</span><span class="boring">       self.dyn_eq(other)
</span><span class="boring">   }
</span><span class="boring">}
</span>trait Trait: DynCompare {}
impl Trait for i32 {}
impl Trait for bool {}

impl PartialEq&lt;dyn Trait&gt; for dyn Trait {
    fn eq(&amp;self, other: &amp;dyn Trait) -&gt; bool {
        self.as_dyn_compare() == other.as_dyn_compare()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The supertrait bound does most of the work, and we just use
upcasting again -- to <code>dyn DynCompare</code> this time -- to be
able to perform <code>PartialEq</code> on our <code>dyn Trait</code>.</p>
<p><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#impl-PartialEq%3CBox%3CT,+A%3E%3E-for-Box%3CT,+A%3E">A blanket implementation in <code>std</code></a>
gives us <code>PartialEq</code> for <code>Box&lt;dyn Trait&gt;</code> automatically.</p>
<p>Now let's try it out:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">use std::any::Any;
</span><span class="boring">
</span><span class="boring">trait AsDynCompare: Any {
</span><span class="boring">   fn as_any(&amp;self) -&gt; &amp;dyn Any;
</span><span class="boring">   fn as_dyn_compare(&amp;self) -&gt; &amp;dyn DynCompare;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T: Any + DynCompare&gt; AsDynCompare for T {
</span><span class="boring">   fn as_any(&amp;self) -&gt; &amp;dyn Any {
</span><span class="boring">       self
</span><span class="boring">   }
</span><span class="boring">   fn as_dyn_compare(&amp;self) -&gt; &amp;dyn DynCompare {
</span><span class="boring">       self
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait DynCompare: AsDynCompare {
</span><span class="boring">   fn dyn_eq(&amp;self, other: &amp;dyn DynCompare) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T: Any + PartialEq&gt; DynCompare for T {
</span><span class="boring">   fn dyn_eq(&amp;self, other: &amp;dyn DynCompare) -&gt; bool {
</span><span class="boring">       if let Some(other) = other.as_any().downcast_ref::&lt;Self&gt;() {
</span><span class="boring">           self == other
</span><span class="boring">       } else {
</span><span class="boring">           false
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PartialEq&lt;dyn DynCompare&gt; for dyn DynCompare {
</span><span class="boring">   fn eq(&amp;self, other: &amp;dyn DynCompare) -&gt; bool {
</span><span class="boring">       self.dyn_eq(other)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Trait: DynCompare {}
</span><span class="boring">impl Trait for i32 {}
</span><span class="boring">impl Trait for bool {}
</span><span class="boring">
</span><span class="boring">impl PartialEq&lt;dyn Trait&gt; for dyn Trait {
</span><span class="boring">   fn eq(&amp;self, other: &amp;dyn Trait) -&gt; bool {
</span><span class="boring">       self.as_dyn_compare() == other.as_dyn_compare()
</span><span class="boring">   }
</span><span class="boring">}
</span>fn main() {
    let bx1a: Box&lt;dyn Trait&gt; = Box::new(1);
    let bx1b: Box&lt;dyn Trait&gt; = Box::new(1);
    let bx2: Box&lt;dyn Trait&gt; = Box::new(2);
    let bx3: Box&lt;dyn Trait&gt; = Box::new(true);

    println!("{}", bx1a == bx1a);
    println!("{}", bx1a == bx1b);
    println!("{}", bx1a == bx2);
    println!("{}", bx1a == bx3);
}</code></pre></pre>
<p>Uh... it didn't work, but for weird reasons.  Why is it trying to move out of the
<code>Box</code> for a comparison?  As it turns out, this is <a href="https://github.com/rust-lang/rust/issues/31740">a longstanding bug in the
language.</a> Fortunately that issue
also offers a workaround that's ergonomic at the use site: implement <code>PartialEq&lt;&amp;Self&gt;</code>
too.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::any::Any;
</span><span class="boring">
</span><span class="boring">trait AsDynCompare: Any {
</span><span class="boring">   fn as_any(&amp;self) -&gt; &amp;dyn Any;
</span><span class="boring">   fn as_dyn_compare(&amp;self) -&gt; &amp;dyn DynCompare;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Sized types only
</span><span class="boring">impl&lt;T: Any + DynCompare&gt; AsDynCompare for T {
</span><span class="boring">   fn as_any(&amp;self) -&gt; &amp;dyn Any {
</span><span class="boring">       self
</span><span class="boring">   }
</span><span class="boring">   fn as_dyn_compare(&amp;self) -&gt; &amp;dyn DynCompare {
</span><span class="boring">       self
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait DynCompare: AsDynCompare {
</span><span class="boring">   fn dyn_eq(&amp;self, other: &amp;dyn DynCompare) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T: Any + PartialEq&gt; DynCompare for T {
</span><span class="boring">   fn dyn_eq(&amp;self, other: &amp;dyn DynCompare) -&gt; bool {
</span><span class="boring">       if let Some(other) = other.as_any().downcast_ref::&lt;Self&gt;() {
</span><span class="boring">           self == other
</span><span class="boring">       } else {
</span><span class="boring">           false
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PartialEq&lt;dyn DynCompare&gt; for dyn DynCompare {
</span><span class="boring">   fn eq(&amp;self, other: &amp;dyn DynCompare) -&gt; bool {
</span><span class="boring">       self.dyn_eq(other)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Trait: DynCompare {}
</span><span class="boring">impl Trait for i32 {}
</span><span class="boring">impl Trait for bool {}
</span><span class="boring">
</span><span class="boring">impl PartialEq&lt;dyn Trait&gt; for dyn Trait {
</span><span class="boring">   fn eq(&amp;self, other: &amp;dyn Trait) -&gt; bool {
</span><span class="boring">       self.as_dyn_compare() == other.as_dyn_compare()
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span>// New
impl PartialEq&lt;&amp;Self&gt; for Box&lt;dyn Trait&gt; {
    fn eq(&amp;self, other: &amp;&amp;Self) -&gt; bool {
        &lt;Self as PartialEq&gt;::eq(self, *other)
    }
}

fn main() {
    let bx1a: Box&lt;dyn Trait&gt; = Box::new(1);
    let bx1b: Box&lt;dyn Trait&gt; = Box::new(1);
    let bx2: Box&lt;dyn Trait&gt; = Box::new(2);
    let bx3: Box&lt;dyn Trait&gt; = Box::new(true);

    println!("{}", bx1a == bx1a);
    println!("{}", bx1a == bx1b);
    println!("{}", bx1a == bx2);
    println!("{}", bx1a == bx3);
}</code></pre></pre>
<p>Ok, now it works.  Phew!</p>
<h2 id="partialord"><a class="header" href="#partialord"><code>PartialOrd</code></a></h2>
<p>From here it's mostly mechanical to add <code>PartialOrd</code> support:</p>
<pre><code class="language-diff">+use core::cmp::Ordering;

 trait DynCompare: AsDynCompare {
     fn dyn_eq(&amp;self, other: &amp;dyn DynCompare) -&gt; bool;
+    fn dyn_partial_cmp(&amp;self, other: &amp;dyn DynCompare) -&gt; Option&lt;Ordering&gt;;
 }

-impl&lt;T: Any + PartialEq&gt; DynCompare for T {
+impl&lt;T: Any + PartialOrd&gt; DynCompare for T {
     fn dyn_eq(&amp;self, other: &amp;dyn DynCompare) -&gt; bool {
         if let Some(other) = other.as_any().downcast_ref::&lt;Self&gt;() {
             self == other
         } else {
             false
         }
     }
+
+    fn dyn_partial_cmp(&amp;self, other: &amp;dyn DynCompare) -&gt; Option&lt;Ordering&gt; {
+        other
+            .as_any()
+            .downcast_ref::&lt;Self&gt;()
+            .and_then(|other| self.partial_cmp(other))
+    }
 }

+impl PartialOrd&lt;dyn DynCompare&gt; for dyn DynCompare {
+    fn partial_cmp(&amp;self, other: &amp;dyn DynCompare) -&gt; Option&lt;Ordering&gt; {
+        self.dyn_partial_cmp(other)
+    }
+}

+impl PartialOrd&lt;dyn Trait&gt; for dyn Trait {
+    fn partial_cmp(&amp;self, other: &amp;dyn Trait) -&gt; Option&lt;Ordering&gt; {
+        self.as_dyn_compare().partial_cmp(other.as_dyn_compare())
+    }
+}

+impl PartialOrd&lt;&amp;Self&gt; for Box&lt;dyn Trait&gt; {
+    fn partial_cmp(&amp;self, other: &amp;&amp;Self) -&gt; Option&lt;Ordering&gt; {
+        &lt;Self as PartialOrd&gt;::partial_cmp(self, *other)
+    }
+}
</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=8142d76abd2b2a4ef75950029e035371">Here's the final playground.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generalizing-borrows"><a class="header" href="#generalizing-borrows">Generalizing borrows</a></h1>
<p>A lot of core traits are built around some sort of <em>field projection,</em> where
the implementing type contains some other type <code>T</code> and you can convert a
<code>&amp;self</code> to a <code>&amp;T</code> or <code>&amp;mut self</code> to a <code>&amp;mut T</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Deref {
    type Target: ?Sized;
    fn deref(&amp;self) -&gt; &amp;Self::Target;
}

pub trait Index&lt;Idx: ?Sized&gt; {
    type Output: ?Sized;
    fn index(&amp;self, index: Idx) -&gt; &amp;Self::Output;
}

pub trait AsRef&lt;T: ?Sized&gt; {
    fn as_ref(&amp;self) -&gt; &amp;T;
}

pub trait Borrow&lt;Borrowed: ?Sized&gt; {
    fn borrow(&amp;self) -&gt; &amp;Borrowed;
}

// `DerefMut`, `IndexMut`, `AsMut`, ...
<span class="boring">}</span></code></pre></pre>
<p>There's generally no way to implement these traits if the type you want to
return is not contained within <code>Self</code> (except for returning a reference to
some static value or similar, which is rarely what you want).</p>
<p>However, sometimes you have a custom borrowing type which is <em>not</em>
actually contained within your owning type:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// We wish we could implement `Borrow&lt;DataRef&lt;'?&gt;&gt;`, but we can't
pub struct Data {
    first: usize,
    others: Vec&lt;usize&gt;,
}

pub struct DataRef&lt;'a&gt; {
    first: usize,
    others: &amp;'a [usize],
}

pub struct DataMut&lt;'a&gt; {
    first: usize,
    others: &amp;'a mut Vec&lt;usize&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>This can be problematic when interacting with libraries and data structures
such as <a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html"><code>std::collections::HashSet</code>,</a>
which <a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html#method.contains">rely on the <code>Borrow</code> trait</a>
to be able to look up entries without taking ownership.</p>
<p>One way around this problem is to use
<a href="https://docs.rs/hashbrown/0.14.0/hashbrown/struct.HashSet.html#method.contains">a different library or type which is more flexible.</a>
However, it's also possible to tackle the problem with a bit of indirection and type erasure.</p>
<h2 id="your-types-contain-a-borrower"><a class="header" href="#your-types-contain-a-borrower">Your types contain a borrower</a></h2>
<p>Here we present a solution to the problem by
<a href="https://orcid.org/0000-0002-6439-9757">Eric Michael Sumner</a>, who has
graciously blessed its inclusion in this guide.  I've rewritten the
original for the sake of presentation, and any errors are my own.</p>
<p>The main idea behind the approach is to utilize the following trait, which
encapsulates the ability to borrow <code>self</code> in the form of your custom borrowed
type:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Data { first: usize, others: Vec&lt;usize&gt; }
</span><span class="boring">pub struct DataRef&lt;'a&gt; { first: usize, others: &amp;'a [usize] }
</span>pub trait Lend {
    fn lend(&amp;self) -&gt; DataRef&lt;'_&gt;;
}

impl Lend for Data {
    fn lend(&amp;self) -&gt; DataRef&lt;'_&gt; {
        DataRef {
            first: self.first,
            others: &amp;self.others,
        }
    }
}

impl Lend for DataRef&lt;'_&gt; {
    fn lend(&amp;self) -&gt; DataRef&lt;'_&gt; {
        DataRef {
            first: self.first,
            others: self.others,
        }
    }
}

// impl Lend for DataMut&lt;'_&gt; ...
<span class="boring">}</span></code></pre></pre>
<p>And the key insight is that any implementor can also coerce from
<code>&amp;self</code> to <code>&amp;dyn Lend</code>.  We can therefore implement traits like
<code>Borrow</code>, because every implementor "contains" a <code>dyn Lend</code> --
themselves!</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Data { first: usize, others: Vec&lt;usize&gt; }
</span><span class="boring">pub struct DataRef&lt;'a&gt; { first: usize, others: &amp;'a [usize] }
</span><span class="boring">pub trait Lend { fn lend(&amp;self) -&gt; DataRef&lt;'_&gt;; }
</span><span class="boring">impl Lend for Data {
</span><span class="boring">   fn lend(&amp;self) -&gt; DataRef&lt;'_&gt; {
</span><span class="boring">       DataRef {
</span><span class="boring">           first: self.first,
</span><span class="boring">           others: &amp;self.others,
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">impl Lend for DataRef&lt;'_&gt; {
</span><span class="boring">   fn lend(&amp;self) -&gt; DataRef&lt;'_&gt; {
</span><span class="boring">       DataRef {
</span><span class="boring">           first: self.first,
</span><span class="boring">           others: self.others,
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span>use std::borrow::Borrow;

impl&lt;'a&gt; Borrow&lt;dyn Lend + 'a&gt; for Data {
    fn borrow(&amp;self) -&gt; &amp;(dyn Lend + 'a) { self }
}

impl&lt;'a, 'b: 'a&gt; Borrow&lt;dyn Lend + 'a&gt; for DataRef&lt;'b&gt; {
    fn borrow(&amp;self) -&gt; &amp;(dyn Lend + 'a) { self }
}

// impl&lt;'a, 'b: 'a&gt; Borrow&lt;dyn Lend + 'a&gt; for DataMut&lt;'b&gt; ...
<span class="boring">}</span></code></pre></pre>
<p>This gives us a common <code>Borrow</code> type for both our owning and
custom borrowing data structures.  To look up borrowed entries
in a <code>HashSet</code>, for example, we can cast a <code>&amp;DataRef&lt;'_&gt;</code> to
a <code>&amp;dyn Lend</code> and pass that to <code>set.contains</code>; the <code>HashSet</code> can
hash the <code>dyn Lend</code> and then borrow the owned <code>Data</code> entries as
<code>dyn Lend</code> as well, in order to do the necessary lookup
comparisons.</p>
<p>That means we need to implement the requisite functionality such as
<code>PartialEq</code> and <code>Hash</code> for <code>dyn Lend</code>.  But this is a different use case
than <a href="./dyn-trait-eq.html">our general solution in the previous section.</a>
In that case we wanted <code>PartialEq</code> for our already-type-erased <code>dyn Trait</code>,
so we could compare values across any arbitrary implementing types.</p>
<p>Here we don't care about arbitrary types, and we also have the ability
to produce a concrete type that references our actual data.  We can
use that to implement the functionality; there's no need for downcasting
or any of that in order to implement the requisite traits for <code>dyn Lend</code>.
We don't really <em>care</em> that <code>dyn Lend</code> will implement <code>PartialEq</code> and
<code>Hash</code> per se, as that is just a means to an end: giving <code>HashSet</code> and
friends a way to compare our custom concrete borrowing types despite the
<code>Borrow</code> trait bound.</p>
<p>First things first though, we need our concrete types to implement
the requisite traits themselves.  The main thing to be mindful of
is that we maintain
<a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html">the invariants expected by <code>Borrow</code>.</a>
For this example, we're lucky enough that our borrowing
type can just derive all of the requisite functionality:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub struct DataRef&lt;'a&gt; {
    first: usize,
    others: &amp;'a [usize],
}

#[derive(Debug, Clone)]
pub struct Data {
    first: usize,
    others: Vec&lt;usize&gt;,
}

#[derive(Debug)]
pub struct DataMut&lt;'a&gt; {
    first: usize,
    others: &amp;'a mut Vec&lt;usize&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>However, we haven't derived the traits that are semantically important
to <code>Borrow</code> for our other types.  We technically could have in
this case, because</p>
<ul>
<li>our fields are in the same order as they are in the borrowed type</li>
<li>every field is present</li>
<li>every field has a <code>Borrow</code> relationship when comparing with the borrowed type's field</li>
<li>we understand how the <code>derive</code> works</li>
</ul>
<p>But all those things might not be true for your use case, and even
when they are, relying on them creates a very fragile arrangement.
It's just too easy to accidentally break things by adding a field
or even just rearranging the field order.</p>
<p>Instead, we implement the traits directly by deferring to the borrowed type:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Data; impl Data { fn lend(&amp;self) {} }
</span>// Exercise for the reader: `PartialEq` across all of our
// owned and borrowed types :-)
impl std::cmp::PartialEq for Data {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.lend() == other.lend()
    }
}

impl std::cmp::Eq for Data {}

impl std::hash::Hash for Data {
    fn hash&lt;H: std::hash::Hasher&gt;(&amp;self, hasher: &amp;mut H) {
        self.lend().hash(hasher)
    }
}

// Similarly for `DataMut&lt;'_&gt;`
<span class="boring">}</span></code></pre></pre>
<p>And in fact, this is exactly the approach we want to take for
<code>dyn Lend</code> as well:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct DataRef&lt;'a&gt; { first: usize, others: &amp;'a [usize] }
</span><span class="boring">pub trait Lend { fn lend(&amp;self); }
</span>impl std::cmp::PartialEq&lt;dyn Lend + '_&gt; for dyn Lend + '_ {
    fn eq(&amp;self, other: &amp;(dyn Lend + '_)) -&gt; bool {
        self.lend() == other.lend()
    }
}

impl std::cmp::Eq for dyn Lend + '_ {}

impl std::hash::Hash for dyn Lend + '_ {
    fn hash&lt;H: std::hash::Hasher&gt;(&amp;self, hasher: &amp;mut H) {
        self.lend().hash(hasher)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Whew, that was a lot of boilerplate.  But we're finally at a
place where we can store <code>Data</code> in a <code>HashSet</code> and look up
entries when we only have a <code>DataRef</code>:</p>
<pre><code class="language-rust ignore">use std::collections::HashSet;
let set = [
    Data { first: 3, others: vec![5,7]},
].into_iter().collect::&lt;HashSet&lt;_&gt;&gt;();

assert!(set.contains::&lt;dyn Lend&gt;(&amp;DataRef { first: 3, others: &amp;[5,7]}))

// Alternative to turbofishing
let data_ref = DataRef { first: 3, others: &amp;[5,7]};
assert!(set.contains(&amp;data_ref as &amp;dyn Lend));</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=cae538dbbf73e3e7692135bf2d397f39">Here's a playground with the complete example.</a></p>
<p>Another alternative to casting or turbofish is to add an
<code>as_lend(&amp;self) -&gt; &amp;dyn Lend + '_</code> method, similar to many
of the previous examples.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="erased-traits"><a class="header" href="#erased-traits">Erased traits</a></h1>
<p>Let's say you have an existing trait which works well for the most part:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod useful {
    pub trait Iterable {
        type Item;
        type Iter&lt;'a&gt;: Iterator&lt;Item = &amp;'a Self::Item&gt; where Self: 'a;
        fn iter(&amp;self) -&gt; Self::Iter&lt;'_&gt;;
        fn visit&lt;F: FnMut(&amp;Self::Item)&gt;(&amp;self, mut f: F) {
            for item in self.iter() {
                f(item);
            }
        }
    }

    impl&lt;I: Iterable + ?Sized&gt; Iterable for &amp;I {
        type Item = &lt;I as Iterable&gt;::Item;
        type Iter&lt;'a&gt; = &lt;I as Iterable&gt;::Iter&lt;'a&gt; where Self: 'a;
        fn iter(&amp;self) -&gt; Self::Iter&lt;'_&gt; {
            &lt;I as Iterable&gt;::iter(*self)
        }
    }

    impl&lt;I: Iterable + ?Sized&gt; Iterable for Box&lt;I&gt; {
        type Item = &lt;I as Iterable&gt;::Item;
        type Iter&lt;'a&gt; = &lt;I as Iterable&gt;::Iter&lt;'a&gt; where Self: 'a;
        fn iter(&amp;self) -&gt; Self::Iter&lt;'_&gt; {
            &lt;I as Iterable&gt;::iter(&amp;**self)
        }
    }

    impl&lt;T&gt; Iterable for Vec&lt;T&gt; {
        type Item = T;
        type Iter&lt;'a&gt; = std::slice::Iter&lt;'a, T&gt; where Self: 'a;
        fn iter(&amp;self) -&gt; Self::Iter&lt;'_&gt; {
            &lt;[T]&gt;::iter(self)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>However, it's not <a href="./dyn-safety.html"><code>dyn</code> safe</a> and you wish it was.
Even if we get support for GATs in <code>dyn Trait</code> some day, there
are no plans to support functions with generic type parameters
like <code>Iterable::visit</code>.  Besides, you want the functionality now,
not "some day".</p>
<p>Perhaps you also have a lot of code utilizing this useful trait,
and you don't want to redo everything.  Maybe it's not even your
own trait.</p>
<p>This may be a case where you want to provide an "erased" version
of the trait to make it <code>dyn</code> safe.  The general idea is to use
<code>dyn</code> (type erasure) to replace all the non-<code>dyn</code>-safe uses such
as GATs and type-parameterized methods.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod erased {
    // This trait is `dyn` safe
    pub trait Iterable {
        type Item;
        // No more GAT
        fn iter(&amp;self) -&gt; Box&lt;dyn Iterator&lt;Item = &amp;Self::Item&gt; + '_&gt;;
        // No more type parameter
        fn visit(&amp;self, f: &amp;mut dyn FnMut(&amp;Self::Item));
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We want to be able to create a <code>dyn erased::Iterable</code> from anything
that is <code>useful::Iterable</code>, so we need a blanket implementation to
connect the two:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {}
</span><span class="boring">pub mod useful {
</span><span class="boring">   pub trait Iterable {
</span><span class="boring">       type Item;
</span><span class="boring">       type Iter&lt;'a&gt;: Iterator&lt;Item = &amp;'a Self::Item&gt; where Self: 'a;
</span><span class="boring">       fn iter(&amp;self) -&gt; Self::Iter&lt;'_&gt;;
</span><span class="boring">       fn visit&lt;F: FnMut(&amp;Self::Item)&gt;(&amp;self, f: F);
</span><span class="boring">   }
</span><span class="boring">}
</span>pub mod erased {
    use crate::useful;
<span class="boring">   pub trait Iterable {
</span><span class="boring">       type Item;
</span><span class="boring">       fn iter(&amp;self) -&gt; Box&lt;dyn Iterator&lt;Item = &amp;Self::Item&gt; + '_&gt;;
</span><span class="boring">       fn visit(&amp;self, f: &amp;mut dyn FnMut(&amp;Self::Item)) {
</span><span class="boring">           for item in self.iter() {
</span><span class="boring">               f(item);
</span><span class="boring">           }
</span><span class="boring">       }
</span><span class="boring">   }
</span>
    impl&lt;I: useful::Iterable + ?Sized&gt; Iterable for I {
        type Item = &lt;I as useful::Iterable&gt;::Item;
        fn iter(&amp;self) -&gt; Box&lt;dyn Iterator&lt;Item = &amp;Self::Item&gt; + '_&gt; {
            Box::new(useful::Iterable::iter(self))
        }
        // By not using a default function body, we can avoid
        // boxing up the iterator
        fn visit(&amp;self, f: &amp;mut dyn FnMut(&amp;Self::Item)) {
            for item in &lt;Self as useful::Iterable&gt;::iter(self) {
                f(item)
            }
        }
    }
}</code></pre></pre>
<p>We're also going to want to pass our <code>erased::Iterable</code>s to functions
that have a <code>useful::Iterable</code> trait bound.  However, we can't add
that as a supertrait, because that would remove the <code>dyn</code> safety.</p>
<p>The purpose of our <code>erased::Iterable</code> is to be able to type-erase to
<code>dyn erased::Iterable</code> anyway though, so instead we just implement
<code>useful::Iterable</code> directly on <code>dyn erased::Iterable</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {}
</span><span class="boring">pub mod useful {
</span><span class="boring">   pub trait Iterable {
</span><span class="boring">       type Item;
</span><span class="boring">       type Iter&lt;'a&gt;: Iterator&lt;Item = &amp;'a Self::Item&gt; where Self: 'a;
</span><span class="boring">       fn iter(&amp;self) -&gt; Self::Iter&lt;'_&gt;;
</span><span class="boring">       fn visit&lt;F: FnMut(&amp;Self::Item)&gt;(&amp;self, f: F);
</span><span class="boring">   }
</span><span class="boring">}
</span>pub mod erased {
    use crate::useful;
<span class="boring">   pub trait Iterable {
</span><span class="boring">       type Item;
</span><span class="boring">       fn iter(&amp;self) -&gt; Box&lt;dyn Iterator&lt;Item = &amp;Self::Item&gt; + '_&gt;;
</span><span class="boring">       fn visit(&amp;self, f: &amp;mut dyn FnMut(&amp;Self::Item)) {
</span><span class="boring">           for item in self.iter() {
</span><span class="boring">               f(item);
</span><span class="boring">           }
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">   impl&lt;I: useful::Iterable + ?Sized&gt; Iterable for I {
</span><span class="boring">       type Item = &lt;I as useful::Iterable&gt;::Item;
</span><span class="boring">       fn iter(&amp;self) -&gt; Box&lt;dyn Iterator&lt;Item = &amp;Self::Item&gt; + '_&gt; {
</span><span class="boring">           Box::new(useful::Iterable::iter(self))
</span><span class="boring">       }
</span><span class="boring">       fn visit(&amp;self, f: &amp;mut dyn FnMut(&amp;Self::Item)) {
</span><span class="boring">           for item in &lt;Self as useful::Iterable&gt;::iter(self) {
</span><span class="boring">               f(item)
</span><span class="boring">           }
</span><span class="boring">       }
</span><span class="boring">   }
</span>
    impl&lt;Item&gt; useful::Iterable for dyn Iterable&lt;Item = Item&gt; + '_ {
        type Item = Item;
        type Iter&lt;'a&gt; = Box&lt;dyn Iterator&lt;Item = &amp;'a Item&gt; + 'a&gt; where Self: 'a;
        fn iter(&amp;self) -&gt; Self::Iter&lt;'_&gt; {
            Iterable::iter(self)
        }
        // Here we can choose to override the default function body to avoid
        // boxing up the iterator, or we can use the default function body
        // to avoid dynamic dispatch of `F`.  I've opted for the former.
        fn visit&lt;F: FnMut(&amp;Self::Item)&gt;(&amp;self, mut f: F) {
            &lt;Self as Iterable&gt;::visit(self, &amp;mut f)
        }
    }
}</code></pre></pre>
<p>Technically our blanket implementation of <code>erased::Iterable</code> now applies to
<code>dyn erased::Iterable</code>, but things still work out due to some
<a href="./dyn-trait-impls.html#the-implementation-cannot-be-directly-overrode">language magic.</a></p>
<p>The blanket implementations of <code>useful::Iterable</code> in the <code>useful</code> module gives
us implementations for <code>&amp;dyn erased::Iterable</code> and <code>Box&lt;dyn erased::Iterable&gt;</code>,
so now we're good to go!</p>
<h2 id="mindful-implementations-and-their-limitations"><a class="header" href="#mindful-implementations-and-their-limitations">Mindful implementations and their limitations</a></h2>
<p>You may have noticed how we took care to avoid boxing the iterator when possible
by being mindful of how we implemented some of the methods, for example not
having a default body for <code>erased::Iterable::visit</code>, and then overriding the
default body of <code>useful::Iterable::visit</code>.  This can lead to better performance
but isn't necessarily critical, so long as you avoid things like accidental
infinite recursion.</p>
<p>How well did we do on this front?
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=31dbe5ae8a7a6b7677ed942962424e03">Let's take a look in the playground.</a></p>
<p>Hmm, perhaps not as well as we hoped!  <code>&lt;dyn erased::Iterable as useful::Iterable&gt;::visit</code>
avoids the boxing as designed, but <code>Box&lt;dyn erased::Iterable&gt;</code>'s <code>visit</code> still boxes the
iterator.</p>
<p>Why is that?  It is because the implementation for the <code>Box</code> is supplied by the <code>useful</code>
module, and that implementation uses the default body.  In order to avoid the boxing,
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=02ae6370cdd7f7b5b1586e0281e090d2">it would need to recurse to the underlying implementation instead.</a>
That way, the call to <code>visit</code> will "drill down" until the implementation for
<code>dyn erased::Iterable::visit</code>, which takes care to avoid the boxed iterator.  Or
phrased another way, the recursive implementations "respects" any overrides of the
default function body by other implementors of <code>useful::Iterable</code>.</p>
<p>Since the original trait might not even be in your crate, this might be out of your
control.  Oh well, so it goes; maybe submit a PR 🙂.  In this particular case you
could take care to pass <code>&amp;dyn erased::Iterable</code> by coding <code>&amp;*boxed_erased_iterable</code>.</p>
<p>Or maybe it doesn't really matter enough to bother in practice for your use case.</p>
<h2 id="real-world-examples"><a class="header" href="#real-world-examples">Real world examples</a></h2>
<p>Perhaps the most popular crate to use this pattern is
<a href="https://crates.io/crates/erased-serde">the <code>erased-serde</code> crate.</a></p>
<p>Another use case is <a href="https://smallcultfollowing.com/babysteps/blog/2021/10/15/dyn-async-traits-part-6/">working with <code>async</code>-esque traits,</a>
which tends to involve a lot of type erasure and unnameable types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashable-boxdyn-trait"><a class="header" href="#hashable-boxdyn-trait">Hashable <code>Box&lt;dyn Trait&gt;</code></a></h1>
<p>Let's say we have a <a href="./dyn-trait-eq.html"><code>dyn Trait</code> that implements <code>Eq</code></a>, but we also want it to implement <code>Hash</code>
so that we can use <code>Box&lt;dyn Trait&gt;</code> in a <code>HashSet</code> or as the key of a <code>HashMap</code> and so on.</p>
<details>
<summary>Here's our starting point</summary>
<p>The only update from <a href="./dyn-trait-eq.html">before</a> is to require <code>Eq</code>:</p>
<pre><code class="language-diff">-impl&lt;T: Any + PartialOrd&gt; DynCompare for T {
+impl&lt;T: Any + PartialOrd + Eq&gt; DynCompare for T {

+impl Eq for dyn DynCompare {}
+impl Eq for dyn Trait {}
</code></pre>
<p>The complete code:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::cmp::Ordering;
use std::any::Any;

trait AsDynCompare: Any {
    fn as_any(&amp;self) -&gt; &amp;dyn Any;
    fn as_dyn_compare(&amp;self) -&gt; &amp;dyn DynCompare;
}

// Sized types only
impl&lt;T: Any + DynCompare&gt; AsDynCompare for T {
    fn as_any(&amp;self) -&gt; &amp;dyn Any {
        self
    }
    fn as_dyn_compare(&amp;self) -&gt; &amp;dyn DynCompare {
        self
    }
}

trait DynCompare: AsDynCompare {
    fn dyn_eq(&amp;self, other: &amp;dyn DynCompare) -&gt; bool;
    fn dyn_partial_cmp(&amp;self, other: &amp;dyn DynCompare) -&gt; Option&lt;Ordering&gt;;
}

impl&lt;T: Any + PartialOrd + Eq&gt; DynCompare for T {
    fn dyn_eq(&amp;self, other: &amp;dyn DynCompare) -&gt; bool {
        if let Some(other) = other.as_any().downcast_ref::&lt;Self&gt;() {
            self == other
        } else {
            false
        }
    }

    fn dyn_partial_cmp(&amp;self, other: &amp;dyn DynCompare) -&gt; Option&lt;Ordering&gt; {
        other
            .as_any()
            .downcast_ref::&lt;Self&gt;()
            .and_then(|other| self.partial_cmp(other))
    }
}

impl Eq for dyn DynCompare {}
impl PartialEq&lt;dyn DynCompare&gt; for dyn DynCompare {
    fn eq(&amp;self, other: &amp;dyn DynCompare) -&gt; bool {
        self.dyn_eq(other)
    }
}

impl PartialOrd&lt;dyn DynCompare&gt; for dyn DynCompare {
    fn partial_cmp(&amp;self, other: &amp;dyn DynCompare) -&gt; Option&lt;Ordering&gt; {
        self.dyn_partial_cmp(other)
    }
}

trait Trait: DynCompare {}
impl Trait for i32 {}
impl Trait for bool {}

impl Eq for dyn Trait {}
impl PartialEq&lt;dyn Trait&gt; for dyn Trait {
    fn eq(&amp;self, other: &amp;dyn Trait) -&gt; bool {
        self.as_dyn_compare() == other.as_dyn_compare()
    }
}

impl PartialOrd&lt;dyn Trait&gt; for dyn Trait {
    fn partial_cmp(&amp;self, other: &amp;dyn Trait) -&gt; Option&lt;Ordering&gt; {
        self.as_dyn_compare().partial_cmp(other.as_dyn_compare())
    }
}

impl PartialEq&lt;&amp;Self&gt; for Box&lt;dyn Trait&gt; {
    fn eq(&amp;self, other: &amp;&amp;Self) -&gt; bool {
        &lt;Self as PartialEq&gt;::eq(self, *other)
    }
}

impl PartialOrd&lt;&amp;Self&gt; for Box&lt;dyn Trait&gt; {
    fn partial_cmp(&amp;self, other: &amp;&amp;Self) -&gt; Option&lt;Ordering&gt; {
        &lt;Self as PartialOrd&gt;::partial_cmp(self, *other)
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
</details>
<p>Similarly to <a href="./dyn-trait-clone.html">when we looked at <code>Clone</code>,</a> <code>Hash</code> is not an object safe trait.  So we can't
just add <code>Hash</code> as a supertrait bound.  This time it's not because it requires <code>Sized</code>, though, it's because
<a href="https://doc.rust-lang.org/std/hash/trait.Hash.html#tymethod.hash">it has a generic method:</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::hash::Hasher;
</span>pub trait Hash {
    fn hash&lt;H&gt;(&amp;self, state: &amp;mut H)
       where H: Hasher;
}
<span class="boring">}</span></code></pre></pre>
<p>Fortunately, we can use an <a href="./dyn-trait-erased.html">erased trait</a> approach:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashSet;
use core::hash::{Hash, Hasher};

trait DynHash {
    fn dyn_hash(&amp;self, state: &amp;mut dyn Hasher);
}

// impl&lt;T: ?Sized + Hash&gt; DynHash for T {
impl&lt;T: Hash&gt; DynHash for T {
    fn dyn_hash(&amp;self, mut state: &amp;mut dyn Hasher) {
        self.hash(&amp;mut state)
    }
}

impl Hash for dyn DynHash + '_ {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {
        self.dyn_hash(state)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now is a good time to point out a couple of things we're relying on:</p>
<ul>
<li>
<p><a href="https://doc.rust-lang.org/std/hash/trait.Hasher.html"><code>Hasher</code></a> <em>is</em> object safe
<br><br>If this wasn't the case, we couldn't take a <code>&amp;mut dyn Hasher</code> in our <code>dyn_hash</code> method.</p>
</li>
<li>
<p>The generic <code>H</code> in <code>Hash::hash&lt;H: Hasher&gt;</code> has an implicit <code>Sized</code> bound
<br><br>If this wasn't the case, we couldn't coerce the <code>&amp;mut H</code> to a <code>&amp;mut dyn Hasher</code>
in our implementation of <code>Hash</code> for <code>dyn DynHash</code>.</p>
</li>
</ul>
<p>This demonstrates that <em>relaxing</em> a <code>Sized</code> bound can be a breaking change!</p>
<p>Moving on, we still need to wire up this new functionality to our own trait.</p>
<pre><code class="language-diff">-trait Trait: DynCompare;
+trait Trait: DynCompare + DynHash {}
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::hash::{Hash, Hasher};
</span><span class="boring">trait DynHash { fn dyn_hash(&amp;self, _: &amp;mut dyn Hasher); }
</span><span class="boring">trait Trait: DynHash {}
</span>// Same as what we did for `dyn DynHash`
impl Hash for dyn Trait {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {
        self.dyn_hash(state)
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=de3908f78bbeeb4da109ca0fa8e1d53b">And that's it!</a></p>
<pre><code class="language-rust ignore">    let bx1a: Box&lt;dyn Trait&gt; = Box::new(1);
    let bx1b: Box&lt;dyn Trait&gt; = Box::new(1);
    let bx2: Box&lt;dyn Trait&gt; = Box::new(2);
    let bx3: Box&lt;dyn Trait&gt; = Box::new(true);

    let hm: HashSet&lt;_&gt; = HashSet::from_iter([bx1a, bx1b, bx2, bx3].into_iter());
    assert_eq!(hm.len(), 3);
</code></pre>
<h2 id="closing-remarks"><a class="header" href="#closing-remarks">Closing remarks</a></h2>
<p><a href="./dyn-trait-borrow.html">Borrowing a concrete type</a> is probably a better approach if it applies
to your use case, since it doesn't require <code>Any + 'static</code>.</p>
<p>Although terribly inefficient, an implementation of <code>Hash</code> that returns the hash for everything
is a correct implementation.  So are other "rough approximations", like if we only hashed the
<code>TypeId</code>.  All that's required for logical behavior is that two equal values must also have
equal hashes.  So arguably we didn't need to go to such lengths to get the exact hashes of the
values.</p>
<p>You may have noticed this commented out line:</p>
<pre><code class="language-rust ignore">// impl&lt;T: ?Sized + Hash&gt; DynHash for T {
impl&lt;T: Hash&gt; DynHash for T {</code></pre>
<p>The reason I went with the less general implementation is two-fold:</p>
<ul>
<li>It wasn't needed for the example</li>
<li>Prudency: because we <code>impl Hash for dyn DynHash</code>, it technically overlaps with the compiler's implementation of <code>DynHash for dyn DynHash</code>.
<a href="./dyn-trait-impls.html#the-implementation-cannot-be-directly-overrode">See the final paragraph of this subsection.</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dyn-any-examples"><a class="header" href="#dyn-any-examples"><code>dyn Any</code> examples</a></h1>
<p>There are some additional examples in the <a href="./dyn-any.html"><code>dyn Any</code> section</a>, since they make more sense there.</p>
<ul>
<li><a href="./dyn-any.html#the-typemap-pattern">A simple <code>TypeMap</code></a></li>
<li><a href="./dyn-any.html#custom-downcasting">Custom downcasting</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more-about-dyn-any"><a class="header" href="#more-about-dyn-any">More about <code>dyn Any</code></a></h1>
<p>We've taken a lot of care to emphasize that <code>dyn Trait</code> isn't
a supertype nor a form of dynamic typing, but
<a href="dyn-trait-eq.html#downcasting-with-dyn-any-to-emulate-dynamic-typing">in one of the examples</a>
we saw that <code>dyn Any</code> <em>can</em> "downcast" back to the erased
base type.  Or <a href="https://doc.rust-lang.org/std/any/trait.Any.html">to quote the official documentation,</a>
<code>Any</code> is</p>
<blockquote>
<p>A trait to emulate dynamic typing.</p>
</blockquote>
<p>Here we take a closer look at <code>dyn Any</code> specifically.</p>
<h2 id="the-general-idea"><a class="header" href="#the-general-idea">The general idea</a></h2>
<p>The <code>Any</code> trait is implemented for all types which satisfy a <code>'static</code> bound.
It supplies a method <code>type_id</code>, which returns
<a href="https://doc.rust-lang.org/std/any/struct.TypeId.html">an opaque but unique identifier</a>
of the implementing type.  We also have
<a href="https://doc.rust-lang.org/std/any/struct.TypeId.html#method.of"><code>TypeId::of::&lt;T&gt;</code>,</a>
which lets us look up the <code>TypeId</code> of any <code>'static</code> type.</p>
<p>Together, this allows fallible downcasting by doing <a href="https://doc.rust-lang.org/src/core/any.rs.html">things along these lines:</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn downcast_ref&lt;T: Any&gt;(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        if self.is::&lt;T&gt;() {
            // SAFETY: just checked whether we are pointing to the correct type, and we can rely on
            // that check for memory safety because we have implemented Any for all types; no other
            // impls can exist as they would conflict with our impl.
            unsafe { Some(self.downcast_ref_unchecked()) }
        } else {
            None
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>And <a href="https://doc.rust-lang.org/std/any/trait.Any.html#method.is"><code>is</code></a> simply compares
<code>TypeId::of::&lt;T&gt;()</code> to <code>self.type_id()</code>.</p>
<p>Details of specific downcasts aside, that's pretty much it!  All that was
needed is the global identifier (<code>TypeId</code>).  The standard library provides
the various downcasting methods in order to encapsulate the required
<code>unsafe</code>ty.</p>
<p><a href="dyn-trait-eq.html#downcasting-with-dyn-any-to-emulate-dynamic-typing">As a reminder from before,</a>
the vtable pointers themselves are not suitable to use as a global identifier
of erased types.  The same trait can have multiple vtables due to codegen
units and linker implementations, and different traits can have the same
vtable due to deduplication optimizations.</p>
<p><a href="https://github.com/rust-lang/rust/issues/106447">Where exactly the language goes with respect to comparing vtable pointers
is an open question.</a>  It's
not unimaginable that all vtables will gain some lifetime-erased version of
<code>TypeId</code>, but <a href="dyn-any.html#why-static">related to some discussion below,</a> this may not
be as straightforward as it may sound.</p>
<h2 id="downcasting-methods-are-not-trait-methods"><a class="header" href="#downcasting-methods-are-not-trait-methods">Downcasting methods are not trait methods</a></h2>
<p>Note that the <em>only</em> method available in the <code>Any</code> trait is <code>type_id</code>.
<a href="https://doc.rust-lang.org/std/any/trait.Any.html#implementations">All of the downcasting methods</a>
are implemented on the erased <code>dyn Any</code> directly, or on <code>Box&lt;dyn Any&gt;</code>, or
on <code>dyn Any + Send</code>, etc.  Downcasting doesn't generally make sense for a
non-erased base type -- you already know what it is!</p>
<p>Another good reason for this is that
<a href="https://doc.rust-lang.org/std/any/index.html#smart-pointers-and-dyn-any">types like <code>Box&lt;dyn Any&gt;</code> implement <code>Any</code>,</a>
making easy to accidentally call the <code>Box&lt;dyn Any&gt;</code> implementation instead of
the <code>dyn Any</code> implementation in the case of <code>type_id</code>.  It would be much more
fraught if <code>downcast_ref</code> worked like this, for example.</p>
<p>However, this does mean that having <code>Any</code> as a supertrait does not allow
downcasting for your own <code>dyn Trait</code>s.  <a href="./dyn-trait-combining.html#manual-supertrait-upcasting">Instead you have to first upcast
to dyn Any,</a> and then
downcast.  Once we have <a href="dyn-trait-coercions.html#supertrait-upcasting">built-in supertrait upcasting,</a>
the process will involve much less boilerplate when an <code>Any</code> suptertrait
bound is acceptable.</p>
<p>But note that a supertrait <code>Any</code> bound is not the only solution for custom downcasting!
<a href="dyn-any.html#custom-downcasting">We explore another approach below.</a></p>
<h2 id="some-brief-examples"><a class="header" href="#some-brief-examples">Some brief examples</a></h2>
<p><a href="dyn-trait-eq.html#downcasting-with-dyn-any-to-emulate-dynamic-typing">In our other example,</a>
we used <a href="./dyn-trait-combining.html#manual-supertrait-upcasting">manual supertrait casting</a> to
turn a <code>dyn DynCompare</code> into a <code>dyn Any</code>.  This was a case where we really just wished we
could attempt to downcast <code>dyn DynCompare</code> itself.</p>
<p>Here we instead look at some simple examples of type erasing and downcasting concrete
types directly.</p>
<h3 id="the-basics"><a class="header" href="#the-basics">The basics</a></h3>
<p>Getting a <code>dyn Any</code> isn't any different than any other kind of type erasure:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::any::Any;
</span>let mut i = 0;
let rf: &amp;dyn Any = &amp;();
let mt: &amp;mut dyn Any = &amp;mut i;
let bx: Box&lt;dyn Any&gt; = Box::new(String::new());
<span class="boring">}</span></code></pre></pre>
<p>You have to keep in mind the <code>'static</code> requirement though:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::any::Any;
</span>let local = ();
let borrow = &amp;local;
// fails because `borrow` is not `'static`
let _: &amp;dyn Any = &amp;borrow;
<span class="boring">}</span></code></pre></pre>
<p>On the upside, <a href="dyn-elision-trait-bounds.html#the-static-case"><code>dyn Any</code> is <em>always</em> <code>dyn Any + 'static</code>,</a>
which makes many trait object related borrow check errors impossible.</p>
<p>Although <code>Any</code> is implemented for unsized types, and unsized types can
have <code>TypeId</code>s too, the <code>Sized</code> restriction for type erasure still applies:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::any::Any;
</span>// fails because `str` is not `Sized`
let _: &amp;dyn Any = "";
<span class="boring">}</span></code></pre></pre>
<p>Fallible downcasting is pretty straightforward as well.  For references
the return is an <code>Option</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::any::Any;
</span><span class="boring">let mut i = 0;
</span><span class="boring">let rf: &amp;dyn Any = &amp;();
</span><span class="boring">let mt: &amp;mut dyn Any = &amp;mut i;
</span>assert_eq!( rf.downcast_ref::&lt;()&gt;(), Some(&amp;()) );
assert_eq!( rf.downcast_ref::&lt;String&gt;(), None );

assert!( mt.downcast_mut::&lt;i32&gt;().is_some() );
assert_eq!( mt.downcast_mut::&lt;String&gt;(), None );
<span class="boring">}</span></code></pre></pre>
<p>For <code>Box</code>es, the return type is a <code>Result</code> so that the you can keep
ownership of the <code>Box&lt;dyn Any&gt;</code> if the downcast is not applicable.
The <code>Ok</code> variant is a <code>Box&lt;T&gt;</code> so that you can choose whether it's
appropriate to unbox the type or not.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::any::Any;
</span><span class="boring">let bx: Box&lt;dyn Any&gt; = Box::new(String::new());
</span>if let Err(bx) = bx.downcast::&lt;i32&gt;() {
    println!("Hmm, not an `i32`.");
    if let Ok(bx) = bx.downcast::&lt;String&gt;() {
        let s: String = *bx;
        println!("Yep, it was a `String`.");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>That's it for the basics!</p>
<h3 id="the-typemap-pattern"><a class="header" href="#the-typemap-pattern">The <code>TypeMap</code> pattern</a></h3>
<p>For an example with a more practical bent, let's say you wanted to store a distinct
value for each distinct type you may encounter, for some reason.  Maybe you're
storing callbacks for types which are likewise type erased, say, and the callback
for a <code>Dog</code> would be different than that for a <code>Cat</code>, and you might not even have
a callback for the <code>Mouse</code>.</p>
<p>One way to do this would be to have a data structure that maps a <code>TypeId</code> to the
values.  A "type map", if you will:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::any::Any;
</span><span class="boring">use std::any::TypeId;
</span><span class="boring">use std::collections::HashMap;
</span>pub struct TypeMap&lt;V&gt; {
    map: HashMap&lt;TypeId, V&gt;,
}

impl&lt;V&gt; TypeMap&lt;V&gt; {
    pub fn insert&lt;T: Any&gt;(&amp;mut self, value: V) -&gt; Option&lt;V&gt; {
        let id = TypeId::of::&lt;T&gt;();
        self.map.insert(id, value)
    }
    pub fn get_mut&lt;T: Any&gt;(&amp;mut self) -&gt; Option&lt;&amp;mut V&gt; {
        self.get_mut_of(&amp;TypeId::of::&lt;T&gt;())
    }
    pub fn get_mut_of(&amp;mut self, id: &amp;TypeId) -&gt; Option&lt;&amp;mut V&gt; {
        self.map.get_mut(id)
    }
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>This could be used for the callback idea:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::any::Any;
</span><span class="boring">use std::any::TypeId;
</span><span class="boring">use std::collections::HashMap;
</span><span class="boring">pub struct TypeMap&lt;V&gt; {
</span><span class="boring">    map: HashMap&lt;TypeId, V&gt;,
</span><span class="boring">}
</span><span class="boring">impl&lt;V&gt; TypeMap&lt;V&gt; {
</span><span class="boring">    pub fn insert&lt;T: Any&gt;(&amp;mut self, value: V) -&gt; Option&lt;V&gt; {
</span><span class="boring">        let id = TypeId::of::&lt;T&gt;();
</span><span class="boring">        self.map.insert(id, value)
</span><span class="boring">    }
</span><span class="boring">    pub fn get_mut&lt;T: Any&gt;(&amp;mut self) -&gt; Option&lt;&amp;mut V&gt; {
</span><span class="boring">        self.get_mut_of(&amp;TypeId::of::&lt;T&gt;())
</span><span class="boring">    }
</span><span class="boring">    pub fn get_mut_of(&amp;mut self, id: &amp;TypeId) -&gt; Option&lt;&amp;mut V&gt; {
</span><span class="boring">        self.map.get_mut(id)
</span><span class="boring">    }
</span><span class="boring">}
</span>pub struct Visitor {
    map: TypeMap&lt;Box&lt;dyn FnMut(&amp;dyn Any)&gt;&gt;,
}

impl Visitor {
    // Because we return closures we have previously created,
    // we should take care to not *assume* that the parameter
    // in the callback is of the correct type.  If we never
    // let our closures escape to the outside world, we could
    // safely assume that the parameter was, in fact, `T`.
    //
    // It would be sound to `panic` if the parameter was not
    // `T` even if we let the closures escape, but it would
    // not be sound to use the unstable `downcast_ref_unchecked`
    // so long as we're letting the closure escape.
    pub fn register&lt;T, F&gt;(&amp;mut self, mut callback: F) -&gt; Option&lt;Box&lt;dyn FnMut(&amp;dyn Any)&gt;&gt;
    where
        T: Any,
        F: 'static + FnMut(&amp;T),
    {
        let callback = Box::new(move |any: &amp;dyn Any| {
            if let Some(t) = any.downcast_ref::&lt;T&gt;() {
                callback(t);
            }
        });

        self.map.insert::&lt;T&gt;(callback)
    }

    pub fn get_callback&lt;T: Any&gt;(&amp;mut self) -&gt; Option&lt;impl FnMut(&amp;T) + '_&gt; {
        self.map
            .get_mut::&lt;T&gt;()
            .map(|f| {
                |t: &amp;T| f(t)
            })
    }

    pub fn visit&lt;T: Any&gt;(&amp;mut self, value: &amp;T) -&gt; bool {
        if let Some(mut callback) = self.get_callback::&lt;T&gt;() {
            callback(value);
            true
        } else {
            false
        }
    }

    pub fn visit_erased(&amp;mut self, value: &amp;dyn Any) -&gt; bool {
        if let Some(callback) = self.map.get_mut_of(&amp;value.type_id()) {
            callback(value);
            true
        } else {
            false
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Above we have also type erased our callback signatures, since we needed
a single type for our values.  This is somewhat the data structure version
of <a href="./dyn-trait-erased.html">erasing a trait.</a></p>
<p>For whatever reason you might want to map by types, this is
<a href="https://lib.rs/keywords/typemap">an existing pattern in the ecosystem.</a></p>
<h3 id="custom-downcasting"><a class="header" href="#custom-downcasting">Custom downcasting</a></h3>
<p>In this example, we explore how you can add (emulated) downcasting to your own
traits, without an <code>Any</code> supertrait bound and without a <code>'static</code> bound on your
entire <em>trait,</em> either.  The implementation does still depend on the <code>TypeId</code>,
so the actual downcasting is still limited to types which satisfy a <code>'static</code> bound.</p>
<p>The approach is to make implementing <a href="dyn-any.html#the-general-idea">the general idea</a> possible
by having a method in our trait that returns the <code>TypeId</code> of the implementing type.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::any::TypeId;
</span>pub trait Trait {
    // Heads up: We'll need to revisit this definition in just a bit
    fn type_id(&amp;self) -&gt; TypeId
    where
        Self: 'static
    {
        TypeId::of::&lt;Self&gt;()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Recall that the compiler's implementation of <code>Trait for dyn Trait</code> will implicitly
downcast the receiver and call this method.  Therefore, we now have a way to get
the <code>TypeId</code> of the base type out of <code>dyn Trait</code>.</p>
<p>Then we can implement our own downcast methods:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::any::TypeId;
</span><span class="boring">pub trait Trait { fn type_id(&amp;self) -&gt; TypeId where Self: 'static { TypeId::of::&lt;Self&gt;() } }
</span>// n.b. this is `dyn Trait + 'static` :-)
impl dyn Trait {
    pub fn is&lt;T: 'static&gt;(&amp;self) -&gt; bool {
        TypeId::of::&lt;T&gt;() == self.type_id()
    }

    pub fn downcast&lt;T: 'static&gt;(self: Box&lt;Self&gt;) -&gt; Result&lt;Box&lt;T&gt;, Box&lt;Self&gt;&gt; {
        if (*self).is::&lt;T&gt;() {
            let ptr = Box::into_raw(self) as *mut T;
            // SAFETY: Keep reading :-)
            unsafe { Ok(Box::from_raw(ptr)) }
        } else {
            Err(self)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>...and similarly for <code>downcast_ref</code>, <code>downcast_mut</code>, and more implementations for
<code>dyn Trait + Send</code>, <code>dyn Trait + Send + Sync</code>, and so on.  (Yes, it can be a lot
of boilerplate.)</p>
<p>However, there's a large soundness hole in this example.  Implementors of <code>Trait</code>
can supply their own implementation of the <code>type_id</code> method!  They can override
the default body and return a <code>TypeId</code> that is not the implementing type.  That
makes our <code>unsafe</code> produce UB; since <code>type_id</code> isn't an <code>unsafe</code> method, our
implementation is to blame.</p>
<p>We could make the method <code>unsafe</code>.  In this example, we will instead make it
impossible to override the default body.  To do this, we need that method
to be <code>final</code>.  Well, Rust doesn't have <code>final</code> yet.  However, we can
<a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed"><em>seal</em></a>
the method by giving it a parameter which can only be named within our module.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A private module (no `pub`)
mod private {
    // Containing a `pub` type (to avoid errors on our public trait method)
    pub struct Seal;
}
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-diff"> pub trait Trait {
-    fn type_id(&amp;self) -&gt; TypeId
+    #[doc(hidden)]
+    fn type_id(&amp;self, _: private::Seal) {
     where
         Self: 'static
     {
         TypeId::of::&lt;Self&gt;()
     }
 }

 impl dyn Trait {
     pub fn is&lt;T: 'static&gt;(&amp;self) -&gt; bool {
-        TypeId::of::&lt;T&gt;() == self.type_id()
+        TypeId::of::&lt;T&gt;() == self.type_id(private::Seal)
     }
</code></pre>
<p>Now if an implementor tries to write out the signature of the <code>type_id</code> method,
they'll get a privacy error.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=af12a6896f44c7843dd331904c5b6bce">Here's a playground with a couple more methods.</a>
This example is based on <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a>
and its own custom downcasting implementation.</p>
<h2 id="why-static"><a class="header" href="#why-static">Why <code>'static</code>?</a></h2>
<p>The <code>Any</code> trait is implemented for all types which satisfy a <code>'static</code> bound,
but no other types; in fact, it has a <code>'static</code> bound and thus <em>cannot</em> be implemented
for types that do not meet a <code>'static</code> bound.  This means that emulating dynamic
typing with <code>Any</code> cannot be done for borrowing types (except those that borrow for
<code>'static</code>), for example.</p>
<p>Why such a harsh restriction?  In short, lifetimes are erased before runtime, types
with different lifetimes would have to have the same <code>TypeId</code> identifier, and thus
downcasting based on the <code>TypeId</code> would ignore lifetimes and be <em>wildly unsound</em>.
Lifetimes are a part of types and certain relationships must be preserved for
soundness, but as the lifetimes have been erased before runtime, it's not possible
to preserve the relationships dynamically.</p>
<p>Thus there is just no sound way to use <code>TypeId</code> or any similar lifetime-unaware
identifier to perform non-<code>'static</code> downcasts directly.</p>
<p><a href="https://github.com/rust-lang/rfcs/pull/1849">There is more information in this RFC PR,</a>
for the curious.  Note that the PR was accepted but then later removed, and was never
about non-<code>'static</code> downcasting; it was about a non-<code>'static</code> <code>type_id</code> method.  The
idea was to get a "type" identifier that ignored lifetimes.</p>
<p>It was withdrawn in large part because if such a thing existed, <a href="https://internals.rust-lang.org/t/pre-rfc-non-footgun-non-static-typeid/17079/10">the chances of it
being abused in some wildly unsound way are about 100%.</a></p>
<p>An alternative (as presented in that thread) is to have some way to dynamically check
if two types (which are perhaps generic) are equal without imposing a <code>'static</code> bound.
The check could only be meaningful for types that were "inherently <code>'static</code>", that is,
types that do not involve any lifetime parameters at all.  That would be possible
without actually exposing a non-<code>'static</code> <code>TypeId</code> or otherwise enabling downcasting.</p>
<p>The tradeoff results in pretty unintuitive behavior: <code>&amp;'static str</code> cannot be
compared to <code>&amp;'static str</code> with this approach, because there <em>is</em> a lifetime parameter
involved with <code>&amp;str</code>!</p>
<p>Another alternative is to provide some sort of "type lambda" which is itself <code>'static</code>,
but can soundly map erased lifetimes back to their proper position.  <a href="https://github.com/sagebind/castaway/pull/6#issuecomment-1150952050">A sketch is
provided here,</a>
but an in-depth exploration is out of scope for this guide.</p>
<h2 id="a-potential-footgun-around-subtypes-subtitle-why-not-const"><a class="header" href="#a-potential-footgun-around-subtypes-subtitle-why-not-const">A potential footgun around subtypes (subtitle: why not <code>const</code>?)</a></h2>
<p>Let's take a minute to talk about types that <em>do</em> have a sub and supertype
relationship in Rust!  Types which are <a href="./dyn-hr.html">higher-ranked</a> have this
relationship.  For example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// More explicitly, this is a `for&lt;'any&gt; fn(&amp;'any str)` function pointer.
// The type is higher-ranked over the lifetime.
let fp: fn(&amp;str) = |_| {};

// This type is a supertype of the higher-ranked type.
let fp: fn(&amp;'static str) = fp;

// This errors because you can't soundly downcast the types.
// let fp: fn(&amp;str) = fp;
<span class="boring">}</span></code></pre></pre>
<p>And as it turns out, it is possible for two Rust types which are more than
superficially syntactically different to be <em>subtypes of one another.</em>  Some
parts of the language consider the existence of such a relationship to mean
that the two types are equal.  Let's say they are semantically equal.</p>
<p>Below is an example.  Due to covariance, it's always possible to call
either of the functions from the other, which helps explain why they are
considered subtypes of one another.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let one: for&lt;'a    &gt; fn(&amp;'a str, &amp;'a str) = |_, _| {};
let two: for&lt;'a, 'b&gt; fn(&amp;'a str, &amp;'b str) = |_, _| {};
let mut fp = one;
fp = two;
let mut fp = two;
fp = one;
<span class="boring">}</span></code></pre></pre>
<p><a href="https://github.com/rust-lang/rust/issues/97156">However, these two types have different <code>TypeId</code>s!</a></p>
<p>So different parts of Rust currently disagree about what types are equal or not.</p>
<p>As the issue explains, this is a bit of a footgun if you were expecting consistency.
Additionally, it's a blocker for <a href="https://github.com/rust-lang/rust/issues/77125">a <code>const type_id</code> function</a>
as it is possible to cause UB in safe code with a <code>const type_id</code> function so long
as this inconsistency remains.</p>
<p>How the language will evolve around this is unclear.  People want the <code>const</code> feature
bad enough that <a href="https://github.com/rust-lang/libs-team/issues/231">some version with caveats about false negatives</a>
may be pursued.  Personally I feel making the type system consistent would be the
better solution and worth waiting for.</p>
<h2 id="more-considerations-around-higher-ranked-types"><a class="header" href="#more-considerations-around-higher-ranked-types">More considerations around higher-ranked types</a></h2>
<p>Even if the issue discussed above gets resolved and Rust becomes consistent about
what types are equal, <a href="./dyn-hr.html">higher-ranked types</a> introduce some nuance to
be aware of.  For example, when considering these two types:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Look&lt;'s&gt; {}
type HR = dyn for&lt;'any&gt; Look&lt;'any&gt; + 'static;
type ST = dyn Look&lt;'static&gt; + 'static;
<span class="boring">}</span></code></pre></pre>
<p><code>HR</code> is a <em>subtype</em> of <code>ST</code>, but not <em>the same type</em>.
However, they both satisfy a <code>'static</code> bound:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Look&lt;'s&gt; {}
</span><span class="boring">type HR = dyn for&lt;'any&gt; Look&lt;'any&gt; + 'static;
</span><span class="boring">type ST = dyn Look&lt;'static&gt; + 'static;
</span>fn assert_static&lt;T: ?Sized + 'static&gt;() {}

assert_static::&lt;HR&gt;();
assert_static::&lt;ST&gt;();
<span class="boring">}</span></code></pre></pre>
<p>As <code>'static</code> types, they have <code>TypeId</code>s.  As distinct types, their
<code>TypeId</code>s are different, even though one is a subtype of the other.</p>
<p>And this in turn means that you can't stop thinking about sub-and-super types
by simply applying a <code>'static</code> bound.  If you need to "disable" sub/super type
coercions in a generic context for soundness, you must make that context invariant
or take other steps to avoid a soundness hole, even if you have a <code>'static</code> bound.</p>
<p><a href="https://github.com/rust-lang/rust/issues/85863">See this issue</a> for a real-life
example of such a soundness hole, and
<a href="https://github.com/rust-lang/rust/issues/85863#issuecomment-872536139">this comment in particular</a>
exploring the sub/super type relationships of higher-ranked function pointers.</p>
<h2 id="the-representation-of-typeid"><a class="header" href="#the-representation-of-typeid">The representation of <code>TypeId</code></a></h2>
<p><code>TypeId</code> is intentionally opaque and subject to change.  It was internally represented
by a <code>u64</code> for quite some time; as of Rust 1.72
<a href="https://github.com/rust-lang/rust/pull/109953">the representation is a <code>u128</code>.</a>
At some future time it could be <a href="https://github.com/rust-lang/rust/pull/95845">something more exotic.</a></p>
<p>Long story short, you're not meant to rely on the exact representation of <code>TypeId</code>,
only it's type comparing properties.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
