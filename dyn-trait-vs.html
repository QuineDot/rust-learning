<!DOCTYPE HTML>
<html lang="en" class="navy" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>dyn Trait vs. alternatives - Learning Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Advice for learning Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('navy')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Practical suggestions for building intuition around borrow errors</li><li class="chapter-item "><a href="lifetime-intuition.html"><strong aria-hidden="true">1.</strong> Sectional introduction</a></li><li class="chapter-item "><a href="community.html"><strong aria-hidden="true">2.</strong> Keep at it and participate in the community</a></li><li class="chapter-item "><a href="have-no-life.html"><strong aria-hidden="true">3.</strong> Prefer ownership over long-lived references</a></li><li class="chapter-item "><a href="dont-hide.html"><strong aria-hidden="true">4.</strong> Don't hide lifetimes</a></li><li class="chapter-item "><a href="elision.html"><strong aria-hidden="true">5.</strong> Understand elision and get a feel for when to name lifetimes</a></li><li class="chapter-item "><a href="subtypes.html"><strong aria-hidden="true">6.</strong> Get a feel for variance, references, and reborrows</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="st-model.html"><strong aria-hidden="true">6.1.</strong> The seed of a mental model</a></li><li class="chapter-item "><a href="st-types.html"><strong aria-hidden="true">6.2.</strong> Reference types</a></li><li class="chapter-item "><a href="st-bounds.html"><strong aria-hidden="true">6.3.</strong> Lifetime bounds</a></li><li class="chapter-item "><a href="st-references.html"><strong aria-hidden="true">6.4.</strong> Reference lifetimes</a></li><li class="chapter-item "><a href="st-reborrow.html"><strong aria-hidden="true">6.5.</strong> Copy and reborrows</a></li><li class="chapter-item "><a href="st-invariance.html"><strong aria-hidden="true">6.6.</strong> Nested borrows and invariance</a></li><li class="chapter-item "><a href="st-more-invariance.html"><strong aria-hidden="true">6.7.</strong> Invariance elsewhere</a></li><li class="chapter-item "><a href="st-non-references.html"><strong aria-hidden="true">6.8.</strong> Non-references</a></li></ol></li><li class="chapter-item "><a href="methods.html"><strong aria-hidden="true">7.</strong> Get a feel for borrow-returning methods</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="m-naming.html"><strong aria-hidden="true">7.1.</strong> When not to name lifetimes</a></li><li class="chapter-item "><a href="m-infect.html"><strong aria-hidden="true">7.2.</strong> Bound-related lifetimes "infect" each other</a></li><li class="chapter-item "><a href="m-no-downgrades.html"><strong aria-hidden="true">7.3.</strong> &mut inputs don't "downgrade" to &</a></li><li class="chapter-item "><a href="m-rpitit-alikes.html"><strong aria-hidden="true">7.4.</strong> async and returning impl Trait</a></li></ol></li><li class="chapter-item "><a href="fn-parameters.html"><strong aria-hidden="true">8.</strong> Understand function lifetime parameters</a></li><li class="chapter-item "><a href="lifetime-analysis.html"><strong aria-hidden="true">9.</strong> Understand borrows within a function</a></li><li class="chapter-item "><a href="pitfalls.html"><strong aria-hidden="true">10.</strong> Learn some pitfalls and antipatterns</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pf-dyn.html"><strong aria-hidden="true">10.1.</strong> dyn Trait lifetimes and Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="pf-nll3.html"><strong aria-hidden="true">10.2.</strong> Conditional return of a borrow</a></li><li class="chapter-item "><a href="pf-borrow-forever.html"><strong aria-hidden="true">10.3.</strong> Borrowing something forever</a></li><li class="chapter-item "><a href="pf-self.html"><strong aria-hidden="true">10.4.</strong> &'a mut self and Self aliasing more generally</a></li><li class="chapter-item "><a href="pf-meta.html"><strong aria-hidden="true">10.5.</strong> Avoid self-referential structs</a></li><li class="chapter-item "><a href="pf-shared-nested.html"><strong aria-hidden="true">10.6.</strong> &'a Struct&lt;'a&gt; and covariance</a></li></ol></li><li class="chapter-item "><a href="compiler.html"><strong aria-hidden="true">11.</strong> Scrutinize compiler advice</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c-signatures.html"><strong aria-hidden="true">11.1.</strong> Advice to change function signature when aliases are involved</a></li><li class="chapter-item "><a href="c-equality.html"><strong aria-hidden="true">11.2.</strong> Advice to add bound which implies lifetime equality</a></li><li class="chapter-item "><a href="c-static.html"><strong aria-hidden="true">11.3.</strong> Advice to add a static bound</a></li></ol></li><li class="chapter-item "><a href="lt-examples.html"><strong aria-hidden="true">12.</strong> Illustrative examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lt-ex-mut-slice.html"><strong aria-hidden="true">12.1.</strong> Mutable slice iterator</a></li></ol></li><li class="chapter-item "><a href="circle.html"><strong aria-hidden="true">13.</strong> Circle back</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Miscellanea</li><li class="chapter-item "><a href="miscellanea.html"><strong aria-hidden="true">14.</strong> Sectional introduction</a></li><li class="chapter-item "><a href="misc-slice.html"><strong aria-hidden="true">15.</strong> Slice layout</a></li><li class="chapter-item "><a href="misc-default-param.html"><strong aria-hidden="true">16.</strong> Default parameter mechanics</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">A tour of dyn Trait</li><li class="chapter-item "><a href="dyn-trait.html"><strong aria-hidden="true">17.</strong> Sectional introduction</a></li><li class="chapter-item "><a href="dyn-trait-overview.html"><strong aria-hidden="true">18.</strong> dyn Trait overview</a></li><li class="chapter-item "><a href="dyn-trait-impls.html"><strong aria-hidden="true">19.</strong> dyn Trait implementations</a></li><li class="chapter-item "><a href="dyn-trait-coercions.html"><strong aria-hidden="true">20.</strong> dyn Trait coercions</a></li><li class="chapter-item "><a href="dyn-safety.html"><strong aria-hidden="true">21.</strong> dyn safety (object safety)</a></li><li class="chapter-item "><a href="dyn-trait-lifetime.html"><strong aria-hidden="true">22.</strong> dyn Trait lifetimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dyn-covariance.html"><strong aria-hidden="true">22.1.</strong> Variance</a></li><li class="chapter-item "><a href="dyn-hr.html"><strong aria-hidden="true">22.2.</strong> Higher-ranked types</a></li><li class="chapter-item "><a href="dyn-elision.html"><strong aria-hidden="true">22.3.</strong> Elision rules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dyn-elision-basic.html"><strong aria-hidden="true">22.3.1.</strong> Basic guidelines</a></li><li class="chapter-item "><a href="dyn-elision-advanced.html"><strong aria-hidden="true">22.3.2.</strong> Advanced guidelines</a></li><li class="chapter-item "><a href="dyn-elision-trait-bounds.html"><strong aria-hidden="true">22.3.3.</strong> Trait bound interactions</a></li><li class="chapter-item "><a href="dyn-elision-citations.html"><strong aria-hidden="true">22.3.4.</strong> Citations</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="dyn-trait-vs.html" class="active"><strong aria-hidden="true">23.</strong> dyn Trait vs. alternatives</a></li><li class="chapter-item "><a href="dyn-trait-examples.html"><strong aria-hidden="true">24.</strong> dyn Trait examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dyn-trait-combining.html"><strong aria-hidden="true">24.1.</strong> Combining traits</a></li><li class="chapter-item "><a href="dyn-trait-box-impl.html"><strong aria-hidden="true">24.2.</strong> impl Trait for Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="dyn-trait-clone.html"><strong aria-hidden="true">24.3.</strong> Cloneable Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="dyn-trait-eq.html"><strong aria-hidden="true">24.4.</strong> dyn PartialEq</a></li><li class="chapter-item "><a href="dyn-trait-borrow.html"><strong aria-hidden="true">24.5.</strong> Generalizing borrows</a></li><li class="chapter-item "><a href="dyn-trait-erased.html"><strong aria-hidden="true">24.6.</strong> Erased traits</a></li><li class="chapter-item "><a href="dyn-trait-hash.html"><strong aria-hidden="true">24.7.</strong> Hashable Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="dyn-any-examples.html"><strong aria-hidden="true">24.8.</strong> dyn Any examples</a></li></ol></li><li class="chapter-item "><a href="dyn-any.html"><strong aria-hidden="true">25.</strong> dyn Any</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learning Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/QuineDot/rust-learning" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="dyn-trait-vs-alternatives"><a class="header" href="#dyn-trait-vs-alternatives"><code>dyn Trait</code> vs. alternatives</a></h1>
<p>When getting familiar with Rust, it can be hard at first to
recognize when you should use <code>dyn Trait</code> versus some other
type mechanism, such as <code>impl Trait</code> or generics.</p>
<p>In this section we look at some tradeoffs, depending on the
use case.</p>
<h2 id="generic-functions-and-argument-position-impl-trait"><a class="header" href="#generic-functions-and-argument-position-impl-trait">Generic functions and argument position <code>impl Trait</code></a></h2>
<h3 id="preliminaries-what-is-argument-position-impl-trait"><a class="header" href="#preliminaries-what-is-argument-position-impl-trait">Preliminaries: What is argument position <code>impl Trait</code>?</a></h3>
<p>When we talk about argument position <code>impl Trait</code>, aka APIT,
we're talking about functions such as this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span>fn foo(d: impl Display) { println!("{d}"); }
// APIT:  ^^^^^^^^^^^^
<span class="boring">}</span></code></pre></pre>
<p>That is, <code>impl Trait</code> as an argument type of a function.</p>
<p>APIT is, so far at least, mostly the same as a generic parameter:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span>fn foo&lt;D: Display&gt;(d: D) { println!("{d}"); }
<span class="boring">}</span></code></pre></pre>
<p>The main difference is that generics allow</p>
<ul>
<li>the function writer to refer to <code>D</code>
<ul>
<li>e.g. <code>D::to_string(&amp;d)</code></li>
</ul>
</li>
<li>other utilizers to turbofish the function
<ul>
<li>e.g. <code>let function_pointer = foo::&lt;String&gt;;</code></li>
</ul>
</li>
</ul>
<p>Whereas the <code>impl Display</code> parameter is not nameable inside nor
outside the function.</p>
<p>There may be more differences in the future, but for now at least,
generics are the more flexible and thus superior form -- unless you
have a burning hatred against the <code>&lt;...&gt;</code> syntax, anyway.</p>
<p>At any rate, comparing <code>dyn Trait</code> against APIT is essentially the
same as comparing <code>dyn Trait</code> against a function with a generic type
parameter.</p>
<h3 id="tradeoffs-between-generic-functions-and-dyn-trait"><a class="header" href="#tradeoffs-between-generic-functions-and-dyn-trait">Tradeoffs between generic functions and <code>dyn Trait</code></a></h3>
<p>Here, we're talking about choosing between signatures like so:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span>// Owned or borrowed generics
fn foo1&lt;T: Trait&gt;(t: T) {}
fn bar1&lt;T: Trait + ?Sized&gt;(t: &amp;T) {}

// Owned or borrowed `dyn Trait`
fn foo2(t: Box&lt;dyn Trait + '_&gt;) {}
fn bar2(t: &amp;dyn Trait) {}
<span class="boring">}</span></code></pre></pre>
<p>When a function has a generic parameter, the parameter is <em>monomorphized</em>
for every concrete type which is used to call the function (after lifetime
erasure).  That is, every type the parameter takes on results in a distinct
function in the compiled code.  (Some of the resulting functions may be
eliminated or combined by optimization if possible).  There could be many
copies of <code>foo1</code> and <code>bar1</code>, depending on how it's called.</p>
<p>But (after lifetime erasure), <code>dyn Trait</code> is a singular concrete type.
There will only be one copy of <code>foo2</code> and <code>bar2</code>.</p>
<p>Yet in your typical Rust program, generic arguments are preferred over
<code>dyn Trait</code> arguments.  Why is that?  There are a number of reasons:</p>
<ul>
<li>Each monomorphized function can typically be optimized better</li>
<li>Trait bounds are more general than <code>dyn Trait</code>
<ul>
<li>No <code>dyn</code> safety concerns (<code>T: Clone</code> is possible)</li>
<li>No single trait restriction (<code>T: Trait1 + Trait2</code> is allowed)</li>
</ul>
</li>
<li>Less indirection through dynamic dispatch</li>
<li>No need for boxing in the owned case
<ul>
<li><code>Box</code> isn't even available in <code>#![no_std]</code> programs</li>
</ul>
</li>
</ul>
<p>The <code>dyn Trait</code> versions do have the following advantages:</p>
<ul>
<li>Smaller code size</li>
<li>Faster code generation</li>
<li><a href="./dyn-trait-erased.html">Do not make traits <code>dyn</code>-unsafe</a></li>
</ul>
<p>In general, you should prefer generics unless you have a specific
reason to opt for <code>dyn Trait</code> in argument position.</p>
<h2 id="return-position-impl-trait-and-tait"><a class="header" href="#return-position-impl-trait-and-tait">Return position <code>impl Trait</code> and TAIT</a></h2>
<h3 id="preliminaries-what-are-return-position-impl-trait-and-tait"><a class="header" href="#preliminaries-what-are-return-position-impl-trait-and-tait">Preliminaries: What are return position <code>impl Trait</code> and TAIT?</a></h3>
<p>When we talk about return position <code>impl Trait</code>, aka RPIT, we're talking
about functions such as this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// RPIT:                vvvvvvvvvvvvvvvvvvvvvvv
fn foo&lt;T&gt;(v: Vec&lt;T&gt;) -&gt; impl Iterator&lt;Item = T&gt; {
    v.into_iter().inspect(|t| println!("{t:p}"))
}
<span class="boring">}</span></code></pre></pre>
<p>Unlike <abbr title="argument position impl trait">APIT</abbr>,
RPITs are not the same as a generic type parameter.  They are instead
opaque type aliases or opaque type alias constructors.  In the above
example, the RPIT is an opaque type alias constructor which depends
on the input type parameter of the function (<code>T</code>).  For every concrete
<code>T</code>, the RPIT is also an alias of a <em><strong>singular</strong></em> concrete type.</p>
<p>The function body and the compiler still know what the concrete type is,
but that is opaque to the caller and other code.  Instead, the only ways
you can use the type are those which are compatible with the trait or
traits in the <code>impl Trait</code>, plus any auto traits which the concrete type
happens to implement.  (Or things provable from such properties, such
as blanket trait implementations.)</p>
<p>The singular part is key: the following code does not compile because
it is trying to return two distinct types.  Rust is strictly and
statically typed, so this is not possible -- the opacity of the RPIT
does not and cannot change that.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span>fn foo(b: bool) -&gt; impl Display {
    if b { 0 } else { "hi!" }
}
<span class="boring">}</span></code></pre></pre>
<p><code>type</code> alias <code>impl Trait</code>, or TAIT, is a generalization of RPIT which
<a href="https://github.com/rust-lang/rust/issues/63063">is not yet stable,</a>
but will probably become stable before <em>too</em> much longer.  TAIT allows
one to define aliases for opaque types, which allows them to be named
and to be used in more than one location.</p>
<pre><pre class="playground"><code class="language-rust nightly edition2021"><span class="boring">#![allow(unused)]
</span>#![feature(type_alias_impl_trait)]
<span class="boring">fn main() {
</span>type MyDisplay = impl std::fmt::Display;

fn foo() -&gt; MyDisplay { "hello," }
fn bar() -&gt; MyDisplay { " world" }
<span class="boring">}</span></code></pre></pre>
<p>Notionally (and hopefully literally), RPIT desugars to a TAIT in
a manner similar to this:</p>
<pre><pre class="playground"><code class="language-rust nightly edition2021"><span class="boring">#![allow(unused)]
</span>#![feature(type_alias_impl_trait)]
<span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span>fn foo1() -&gt; impl Display { "hi" }

// Same thing... or so
type __Unnameable_Tait = impl Display;
fn foo2() -&gt; __Unnameable_Tait { "hi" }
<span class="boring">}</span></code></pre></pre>
<p>TAITs must still be an alias of a singular, concrete type.</p>
<p>Other downsides of opaque types generally from the perspective of the caller include</p>
<ul>
<li>Opaque types are invariant on all parameters, whereas nominal structs need not be</li>
<li>No traits, including local traits, can be implemented on opaque types</li>
<li>All of a nominal structs trait implementations, public fields, and public inherent
methods are available, while opaque types reveal much less</li>
</ul>
<h3 id="tradeoffs-between-rpit-and-dyn-trait"><a class="header" href="#tradeoffs-between-rpit-and-dyn-trait">Tradeoffs between RPIT and <code>dyn Trait</code></a></h3>
<p>RPITs and <code>dyn Trait</code> returns share some benefits for the function writer:</p>
<ul>
<li>So long as the bounds don't change, you can change the concrete or base type</li>
<li>You can return unnameable types, such as closures</li>
<li>It simplifies complicated types, such as long iterator combinator chains</li>
</ul>
<p><code>dyn Trait</code> does have some limitations and downsides:</p>
<ul>
<li>Only one non-auto-trait is supportable without <a href="./dyn-trait-combining.html">subtrait boilerplate</a>
<ul>
<li>In contrast, with RPIT you can return <code>impl Trait1 + Trait2</code></li>
</ul>
</li>
<li>Only <code>dyn</code>-safe traits are supportable
<ul>
<li>In contrast, with RPIT you can return <code>impl Clone</code></li>
</ul>
</li>
<li>Boxing in some form is required to returned owned types</li>
<li>You pay the typical optimization penalties of not knowing the base type and performing dynamic dispatch</li>
</ul>
<p>However, RPITs also have their downsides:</p>
<ul>
<li>As an opaque alias, you can only return one actual, concrete type</li>
<li>For now, the return type is unnameable, which can be awkward for consumers
<ul>
<li>e.g. you can't store the result as a non-generic field in your struct</li>
<li>...unless the opaque type bounds are <code>dyn</code>-safe and you can type erase it yourself</li>
</ul>
</li>
<li>Auto-traits are leaky, so it's easy for the function writer to accidentally break SemVer
<ul>
<li>Whereas auto-traits are explicit with <code>dyn Trait</code></li>
</ul>
</li>
<li>RPIT methods in traits (stabilized in Rust 1.75) are <a href="dyn-safety.html">not <code>dyn</code>-dispatchable</a></li>
<li>Every RPIT is a distinct opaque type (note that TAIT works around this restriction)</li>
</ul>
<p>RPITs also have some rather tricky behavior around type parameter and lifetime capture.
The planned <code>impl Trait</code> functionalities deserve their own exploration independent of
<code>dyn Trait</code>, so I'll only mention them in brief:</p>
<ul>
<li>RPIT captures all type parameters (<a href="https://github.com/rust-lang/rust/issues/42940">and their implied lifetimes</a>)
<ul>
<li>And also lifetime parameters, in traits and <a href="https://github.com/rust-lang/rust/issues/117587">in edition 2024</a></li>
</ul>
</li>
<li>RPIT captures specific lifetimes and not <a href="./dyn-trait-lifetime.html#when-multiple-lifetimes-are-involved">the intersection of all lifetimes</a>
<ul>
<li>And thus it is <a href="https://github.com/danielhenrymantilla/fix_hidden_lifetime_bug.rs">tedious to capture an intersection of input lifetimes</a> instead of a union</li>
<li>(The situation will be improved by <a href="https://github.com/rust-lang/rust/issues/123432">precise capturing</a>)</li>
</ul>
</li>
</ul>
<p>Despite all these downsides, I would say that RPIT has a <em>slight</em> edge over <code>dyn Trait</code>
in return position <em>when applicable,</em> especially for owned types.  The advantage between
<code>dyn Trait</code> and a (named) TAIT will be even greater, once that is available:</p>
<ul>
<li>You can give the return type a name and reuse it in multiple places</li>
<li>TAIT inherently has precise capturing
<ul>
<li>I.e. you have control over, and are explicit about, which lifetime and type parameters are captured</li>
</ul>
</li>
</ul>
<p>But <code>dyn Trait</code> will still sometimes the better option, e.g.:</p>
<ul>
<li>when you need to type erase and return distinct types</li>
<li>when you need trait object safety</li>
</ul>
<p>However, there is often a third possibility available, which we explore below:
return a generic struct.</p>
<h3 id="an-alternative-to-both-nominal-generic-structs"><a class="header" href="#an-alternative-to-both-nominal-generic-structs">An alternative to both: nominal generic structs</a></h3>
<p>Here we can take inspiration from the standard library.  One of the more popular
situations to use RPIT or return <code>dyn Trait</code> is when dealing with iterators
(as iterator chains have long types and often involve unnameable types such as
closures as well).
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">So let's look at the Iterator methods.</a></p>
<p>You may notice a pattern with the combinators:</p>
<pre><code class="language-rust ignore">fn chain&lt;U&gt;(self, other: U) -&gt; Chain&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;
where
    Self: Sized,
    U: IntoIterator&lt;Item = Self::Item&gt;,
{ todo!() }

fn filter&lt;P&gt;(self, predicate: P) -&gt; Filter&lt;Self, P&gt;
where
    Self: Sized,
    P: FnMut(&amp;Self::Item) -&gt; bool,
{ todo!() }

fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;
where
    Self: Sized,
    F: FnMut(Self::Item) -&gt; B,
{ todo!() }</code></pre>
<p>The pattern is to have a function which is parameterized by a generic type
return a concrete (nominal) struct, also parameterized by the generic type.
This is possible even if the parameter itself is unnameable -- for example,
in the case of <code>map</code>, the <code>F: FnMut(Self::Item) -&gt; B</code> parameter might well
be an unnameable closure.</p>
<p>The downside is much more boilerplate if you opt to follow this pattern
yourself: You have to define the struct, and (for examples like these)
implement the <code>Iterator</code> trait for them, and perhaps other traits such
as <code>DoubleEndedIterator</code> as desired.  This will probably involve storing
the original iterator and calling <code>next().map(|item| ...)</code> on it, or
such.</p>
<p>The upside is that you (and the consumers of your method) get many of the upsides of both RPIT and <code>dyn Trait</code>:</p>
<ul>
<li>No dynamic dispatch penalty</li>
<li>No boxing penalty</li>
<li>No concrete-type specific optimization loss</li>
<li>No single trait limitation</li>
<li>No <code>dyn</code>-safe limitation</li>
<li>Applicable in traits</li>
<li>Ability to be specific about captures</li>
<li>Ability to change your implementation within the API bounds</li>
<li>Nameable return type</li>
</ul>
<p>You do retain some of the downsides:</p>
<ul>
<li>Auto-traits are leaky and still a semver hazard, as with RPIT</li>
<li>Multiple concrete types aren't possible (without also utilizing type erasure), as with RPIT</li>
</ul>
<p>And incur some unique ones as well:</p>
<ul>
<li>Variance of data types are leaky too</li>
<li>Unnameable types that aren't input type parameters can't be supported (without also utilizing type erasure)</li>
</ul>
<p>On the whole, when using a nominal type is possible, it is the best option for
consumers of the function.  But it's also the most amount of work for the function
implementor.</p>
<p>I recommend nominal types for general libraries (i.e. intended for wide consumption)
when possible, following the lead of the standard library.</p>
<h2 id="generic-structs"><a class="header" href="#generic-structs">Generic structs</a></h2>
<p>In the last section, we covered how generic structs can often be used as an
alternative to RPIT or returning <code>dyn Trait</code> in some form.   A related question
is, when should you use type erasure within your data types?</p>
<p>The main reason to use type erasure in your data types are when you want to
treat implementors of a trait as if they were the same type, for instance when
storing a collection of callbacks.  In this case, the decision to use type
erasure is a question of functionality, and not really much of a choice.</p>
<p>However, you may also want to use type erasure in your data types in order
to make your own struct non-generic.  When your data type is generic, after
all, those who use your data type in such a way that the parameter takes on
more than one type will have to propagate the use of generics themselves, or
face the decision of type erasing your data type themselves.</p>
<p>This can not only be a question of ergonomics, but also of compile time and
even run time performance.  Compiling strictly more code by having all your
methods monomorphized will naturally tend to result in longer compile times,
and the increase in actual code size <em>can sometimes be slower at runtime</em>
than a touch of dynamic dispatch in the right areas.</p>
<p>Unfortunately, there is no silver bullet when it comes to choosing between
being generic and using type erasure.  However, a general principle is that
your optimization sensitive, call-heavy code areas should not be type erased,
and instead push type erasure to a boundary outside of your heavy computations.</p>
<p>For example, the failure to devirtualize and inline a call to
<code>&lt;dyn Iterator&gt;::next</code> in a tight loop may have a relatively large impact,
whereas a dynamic callback that only fires occasionally (and then dispatches
to the optimized, non-type-erased implementation) is not likely to be
noticeable at all.</p>
<h2 id="enums"><a class="header" href="#enums"><code>enum</code>s</a></h2>
<p>Finally we'll mention one other alternative to type erasure:
just put all of the implementing types in an <code>enum</code>!</p>
<p>This clearly only applies when you have a fixed set of types that you
expect to implement your trait.  The downside of using an <code>enum</code> is that
it can involve a lot of boilerplate, since you're frequently having to check
which variant you are instead of relying on dynamic dispatch to perform
that function for you.</p>
<p>The upside is avoiding practically all of the downsides of type erasure
and the other alternatives such as opaque types.</p>
<p>Macros can help ease the pain of such boilerplate, and there are also
<a href="https://crates.io/crates/ambassador">crates in the ecosystem</a> aimed at
reducing the boilerplate.</p>
<p>In fact, <a href="https://crates.io/crates/enum_dispatch">there are also crates for this pattern as a whole.</a></p>
<p>In particular, if you find yourself in a situation where you've
<a href="./dyn-any.html">chosen to use <code>dyn Any</code></a> but you find yourself with
a bunch of attempted downcasts against a known set of types, you
should <em>strongly</em> consider just using an <code>enum</code>.  It won't be much
less ergonomic (if at all) and will be more efficient.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="dyn-elision-citations.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="dyn-trait-examples.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="dyn-elision-citations.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="dyn-trait-examples.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
