<!DOCTYPE HTML>
<html lang="en" class="navy" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mutable slice iterator - Learning Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Advice for learning Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('navy')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Practical suggestions for building intuition around borrow errors</li><li class="chapter-item "><a href="lifetime-intuition.html"><strong aria-hidden="true">1.</strong> Sectional introduction</a></li><li class="chapter-item "><a href="community.html"><strong aria-hidden="true">2.</strong> Keep at it and participate in the community</a></li><li class="chapter-item "><a href="have-no-life.html"><strong aria-hidden="true">3.</strong> Prefer ownership over long-lived references</a></li><li class="chapter-item "><a href="dont-hide.html"><strong aria-hidden="true">4.</strong> Don't hide lifetimes</a></li><li class="chapter-item "><a href="elision.html"><strong aria-hidden="true">5.</strong> Understand elision and get a feel for when to name lifetimes</a></li><li class="chapter-item "><a href="subtypes.html"><strong aria-hidden="true">6.</strong> Get a feel for variance, references, and reborrows</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="st-model.html"><strong aria-hidden="true">6.1.</strong> The seed of a mental model</a></li><li class="chapter-item "><a href="st-types.html"><strong aria-hidden="true">6.2.</strong> Reference types</a></li><li class="chapter-item "><a href="st-bounds.html"><strong aria-hidden="true">6.3.</strong> Lifetime bounds</a></li><li class="chapter-item "><a href="st-references.html"><strong aria-hidden="true">6.4.</strong> Reference lifetimes</a></li><li class="chapter-item "><a href="st-reborrow.html"><strong aria-hidden="true">6.5.</strong> Copy and reborrows</a></li><li class="chapter-item "><a href="st-invariance.html"><strong aria-hidden="true">6.6.</strong> Nested borrows and invariance</a></li><li class="chapter-item "><a href="st-more-invariance.html"><strong aria-hidden="true">6.7.</strong> Invariance elsewhere</a></li><li class="chapter-item "><a href="st-non-references.html"><strong aria-hidden="true">6.8.</strong> Non-references</a></li></ol></li><li class="chapter-item "><a href="methods.html"><strong aria-hidden="true">7.</strong> Get a feel for borrow-returning methods</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="m-naming.html"><strong aria-hidden="true">7.1.</strong> When not to name lifetimes</a></li><li class="chapter-item "><a href="m-infect.html"><strong aria-hidden="true">7.2.</strong> Bound-related lifetimes "infect" each other</a></li><li class="chapter-item "><a href="m-no-downgrades.html"><strong aria-hidden="true">7.3.</strong> &mut inputs don't "downgrade" to &</a></li><li class="chapter-item "><a href="m-rpitit-alikes.html"><strong aria-hidden="true">7.4.</strong> async and returning impl Trait</a></li></ol></li><li class="chapter-item "><a href="fn-parameters.html"><strong aria-hidden="true">8.</strong> Understand function lifetime parameters</a></li><li class="chapter-item "><a href="lifetime-analysis.html"><strong aria-hidden="true">9.</strong> Understand borrows within a function</a></li><li class="chapter-item "><a href="pitfalls.html"><strong aria-hidden="true">10.</strong> Learn some pitfalls and antipatterns</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pf-dyn.html"><strong aria-hidden="true">10.1.</strong> dyn Trait lifetimes and Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="pf-nll3.html"><strong aria-hidden="true">10.2.</strong> Conditional return of a borrow</a></li><li class="chapter-item "><a href="pf-borrow-forever.html"><strong aria-hidden="true">10.3.</strong> Borrowing something forever</a></li><li class="chapter-item "><a href="pf-self.html"><strong aria-hidden="true">10.4.</strong> &'a mut self and Self aliasing more generally</a></li><li class="chapter-item "><a href="pf-meta.html"><strong aria-hidden="true">10.5.</strong> Avoid self-referential structs</a></li><li class="chapter-item "><a href="pf-shared-nested.html"><strong aria-hidden="true">10.6.</strong> &'a Struct&lt;'a&gt; and covariance</a></li></ol></li><li class="chapter-item "><a href="compiler.html"><strong aria-hidden="true">11.</strong> Scrutinize compiler advice</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c-signatures.html"><strong aria-hidden="true">11.1.</strong> Advice to change function signature when aliases are involved</a></li><li class="chapter-item "><a href="c-equality.html"><strong aria-hidden="true">11.2.</strong> Advice to add bound which implies lifetime equality</a></li><li class="chapter-item "><a href="c-static.html"><strong aria-hidden="true">11.3.</strong> Advice to add a static bound</a></li></ol></li><li class="chapter-item expanded "><a href="lt-examples.html"><strong aria-hidden="true">12.</strong> Illustrative examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lt-ex-mut-slice.html" class="active"><strong aria-hidden="true">12.1.</strong> Mutable slice iterator</a></li></ol></li><li class="chapter-item "><a href="circle.html"><strong aria-hidden="true">13.</strong> Circle back</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Miscellanea</li><li class="chapter-item "><a href="miscellanea.html"><strong aria-hidden="true">14.</strong> Sectional introduction</a></li><li class="chapter-item "><a href="misc-slice.html"><strong aria-hidden="true">15.</strong> Slice layout</a></li><li class="chapter-item "><a href="misc-default-param.html"><strong aria-hidden="true">16.</strong> Default parameter mechanics</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">A tour of dyn Trait</li><li class="chapter-item "><a href="dyn-trait.html"><strong aria-hidden="true">17.</strong> Sectional introduction</a></li><li class="chapter-item "><a href="dyn-trait-overview.html"><strong aria-hidden="true">18.</strong> dyn Trait overview</a></li><li class="chapter-item "><a href="dyn-trait-impls.html"><strong aria-hidden="true">19.</strong> dyn Trait implementations</a></li><li class="chapter-item "><a href="dyn-trait-coercions.html"><strong aria-hidden="true">20.</strong> dyn Trait coercions</a></li><li class="chapter-item "><a href="dyn-safety.html"><strong aria-hidden="true">21.</strong> dyn safety (object safety)</a></li><li class="chapter-item "><a href="dyn-trait-lifetime.html"><strong aria-hidden="true">22.</strong> dyn Trait lifetimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dyn-covariance.html"><strong aria-hidden="true">22.1.</strong> Variance</a></li><li class="chapter-item "><a href="dyn-hr.html"><strong aria-hidden="true">22.2.</strong> Higher-ranked types</a></li><li class="chapter-item "><a href="dyn-elision.html"><strong aria-hidden="true">22.3.</strong> Elision rules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dyn-elision-basic.html"><strong aria-hidden="true">22.3.1.</strong> Basic guidelines</a></li><li class="chapter-item "><a href="dyn-elision-advanced.html"><strong aria-hidden="true">22.3.2.</strong> Advanced guidelines</a></li><li class="chapter-item "><a href="dyn-elision-trait-bounds.html"><strong aria-hidden="true">22.3.3.</strong> Trait bound interactions</a></li><li class="chapter-item "><a href="dyn-elision-citations.html"><strong aria-hidden="true">22.3.4.</strong> Citations</a></li></ol></li></ol></li><li class="chapter-item "><a href="dyn-trait-vs.html"><strong aria-hidden="true">23.</strong> dyn Trait vs. alternatives</a></li><li class="chapter-item "><a href="dyn-trait-examples.html"><strong aria-hidden="true">24.</strong> dyn Trait examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dyn-trait-combining.html"><strong aria-hidden="true">24.1.</strong> Combining traits</a></li><li class="chapter-item "><a href="dyn-trait-box-impl.html"><strong aria-hidden="true">24.2.</strong> impl Trait for Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="dyn-trait-clone.html"><strong aria-hidden="true">24.3.</strong> Cloneable Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="dyn-trait-eq.html"><strong aria-hidden="true">24.4.</strong> dyn PartialEq</a></li><li class="chapter-item "><a href="dyn-trait-borrow.html"><strong aria-hidden="true">24.5.</strong> Generalizing borrows</a></li><li class="chapter-item "><a href="dyn-trait-erased.html"><strong aria-hidden="true">24.6.</strong> Erased traits</a></li><li class="chapter-item "><a href="dyn-trait-hash.html"><strong aria-hidden="true">24.7.</strong> Hashable Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="dyn-any-examples.html"><strong aria-hidden="true">24.8.</strong> dyn Any examples</a></li></ol></li><li class="chapter-item "><a href="dyn-any.html"><strong aria-hidden="true">25.</strong> dyn Any</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learning Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/QuineDot/rust-learning" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="mutable-slice-iterator"><a class="header" href="#mutable-slice-iterator">Mutable slice iterator</a></h1>
<p>The standard library has <a href="https://doc.rust-lang.org/std/slice/struct.IterMut.html">an iterator over <code>&amp;mut [T]</code></a>
which is implemented (as of this writing) in terms of pointer arithmetic, presumably for the sake of optimization.
In this example, we'll show how one can implement their own mutable slice iterator with entirely safe code.</p>
<p>Here's the starting place for our implementation:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyIterMut&lt;'a, T&gt; {
    slice: &amp;'a mut [T],
    // ...maybe other fields for your needs...
}

impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        todo!()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Below are a few starting attempts at it.  Spoilers, they don't compile.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyIterMut&lt;'a, T&gt; { slice: &amp;'a mut [T], }
</span><span class="boring">impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
</span><span class="boring">  type Item = &amp;'a mut T;
</span>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // Eh, we'll worry about iterative logic later!
        self.slice.get_mut(0)
    }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyIterMut&lt;'a, T&gt; { slice: &amp;'a mut [T], }
</span><span class="boring">impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
</span><span class="boring">  type Item = &amp;'a mut T;
</span>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // Actually, this method looks perfect for our iteration logic
        let (first, rest) = self.slice.split_first_mut()?;
        self.slice = rest;
        Some(first)
    }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyIterMut&lt;'a, T&gt; { slice: &amp;'a mut [T], }
</span><span class="boring">impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
</span><span class="boring">   type Item = &amp;'a mut T;
</span>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // 🤔 Pattern matching??
        match &amp;mut self.slice {
            [] =&gt; None,
            [first, rest @ ..] =&gt; Some(first),
        }
    }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Yeah, the compiler really doesn't like any of that.  Let's take a minute to write out all the elided
lifetimes.  Some of them are in aliases, which we're also going to expand:</p>
<ul>
<li><code>Item</code> is <code>&amp;'a mut T</code></li>
<li><code>&amp;mut self</code> is short for <code>self: &amp;mut Self</code>, and
<ul>
<li><code>Self</code> is <code>MyIterMut&lt;'a, T&gt;</code></li>
</ul>
</li>
</ul>
<p>Here's what it looks like with everything being explicit:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyIterMut&lt;'a, T&gt; { slice: &amp;'a mut [T], }
</span><span class="boring">impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
</span><span class="boring">  type Item = &amp;'a mut T;
</span>    fn next&lt;'s&gt;(self: &amp;'s mut MyIterMut&lt;'a, T&gt;) -&gt; Option&lt;&amp;'a mut T&gt; {
        todo!()
    }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>And remember that in <code>MyIterMut&lt;'a, T&gt;</code>, <code>slice</code> is a <code>&amp;'a mut [T]</code>.</p>
<p>Ah, yes.  <a href="./st-invariance.html">We have a nested exclusive borrow</a> here.</p>
<blockquote>
<p>You cannot get a <code>&amp;'long mut U</code> through dereferencing a <code>&amp;'short mut &amp;'long mut U</code>.</p>
<ul>
<li>You can only reborrow a <code>&amp;'short mut U</code>.</li>
</ul>
</blockquote>
<p>There is no safe way to go <em>through</em> the <code>&amp;'s mut self</code> and pull out a <code>&amp;'a mut T</code>.</p>
<p>Are we stuck then?  No, there is actually a way forward! As it turns out,
slices are special.  In particular, the compiler understands that an <em>empty</em> slice
covers <em>no actual data</em>, so there can't be any memory aliasing concerns or data races,
et cetera.  So the compiler understands it's perfectly sound to pull an empty slice
reference out of no where, with any lifetime at all.  Even if it's an exclusive slice reference!</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn magic&lt;T&gt;() -&gt; &amp;'static mut [T] {
    &amp;mut []
}
<span class="boring">}</span></code></pre></pre>
<p>For our purposes, we don't even need the magic: the standard library
<a href="https://doc.rust-lang.org/std/default/trait.Default.html#impl-Default-for-%26mut+%5BT%5D">has a <code>Default</code> implementation</a>
for <code>&amp;mut [T]</code>.</p>
<p>Why does this unstick us?  With that implementation, we can conjure an empty <code>&amp;mut [T]</code>
out of nowhere and <em>move our <code>slice</code> field out from behind <code>&amp;mut self</code>:</em></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyIterMut&lt;'a, T&gt; { slice: &amp;'a mut [T], }
</span><span class="boring">impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
</span><span class="boring">  type Item = &amp;'a mut T;
</span>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let mut slice = std::mem::take(&amp;mut self.slice);
        // Eh, we'll worry about iterative logic later!
        slice.get_mut(0)
    }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p><a href="https://doc.rust-lang.org/std/mem/fn.take.html"><code>std::mem::take</code></a> and <code>swap</code> and <code>replace</code> are
very useful and safe functions; don't be thrown off by them being in <code>std::mem</code> along side the
dangerous <code>transmute</code> and other low-level functions.  Note how we passed <code>&amp;mut self.slice</code> --
that's a <code>&amp;mut &amp;mut [T]</code>.  <code>take</code> replaces everything inside of the outer <code>&amp;mut</code>, which can have
an arbitrarily short lifetime -- just long enough to move the memory around.</p>
<p>So we're done aside from iterative logic, right?  This should just give us the first element forever?</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyIterMut&lt;'a, T&gt; { slice: &amp;'a mut [T], }
</span><span class="boring">impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
</span><span class="boring">  type Item = &amp;'a mut T;
</span><span class="boring">  fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">      let mut slice = std::mem::take(&amp;mut self.slice);
</span><span class="boring">      slice.get_mut(0)
</span><span class="boring">  }
</span><span class="boring">}
</span>let mut arr = [0, 1, 2, 3];
let iter = MyIterMut { slice: &amp;mut arr };
for x in iter.take(10) {
    println!("{x}");
}
<span class="boring">}</span></code></pre></pre>
<p>Uh, it only gave us one item.  Oh right -- when we're done with the slice, we need to move it
back into our <code>slice</code> field.  We only want to <em>temporarily</em> replace that field with an empty slice.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyIterMut&lt;'a, T&gt; { slice: &amp;'a mut [T], }
</span><span class="boring">impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
</span><span class="boring">  type Item = &amp;'a mut T;
</span>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let mut slice = std::mem::take(&amp;mut self.slice);
        // Eh, we'll worry about iterative logic later!
        let first = slice.get_mut(0);
        self.slice = slice;
        first
    }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Uh oh, now what.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>error[E0499]: cannot borrow `*slice` as mutable more than once at a time
9  |         let first = slice.get_mut(0);
   |                     ----- first mutable borrow occurs here
10 |         self.slice = slice;
   |                      ^^^^^ second mutable borrow occurs here
11 |         first
   |         ----- returning this value requires that `*slice` is borrowed for `'a`
<span class="boring">}</span></code></pre></pre>
<p>Oh, right!  These are <em>exclusive</em> references.  We can't return the same item multiple
times -- that would mean someone could get multiple <code>&amp;mut</code> to the same element if they
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect">collect</a>ed the
iterator, for example.  Come to think of it, we can't punt on our iteration logic
either -- if we try to hold on to the entire <code>&amp;mut [T]</code> while handing out <code>&amp;mut T</code>
to the elements, that's <em>also</em> multiple <code>&amp;mut</code> to the same memory!</p>
<p>This is what the error is telling us: We can't hold onto the entire <code>slice</code> and
return <code>first</code>.</p>
<p>(There's a pattern called "leanding iterators" where you can hand out borrows of
data you own in an iterator-like fashion, but it's not possible with the current
<code>Iterator</code> trait; it is also a topic for another day.)</p>
<p>Alright, let's try <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_first_mut"><code>split_first_mut</code></a>
again instead, that really did seem like a perfect fit for our iteration logic.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyIterMut&lt;'a, T&gt; { slice: &amp;'a mut [T], }
</span><span class="boring">impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
</span><span class="boring">  type Item = &amp;'a mut T;
</span>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let mut slice = std::mem::take(&amp;mut self.slice);
        let (first, rest) = slice.split_first_mut()?;
        self.slice = rest;
        Some(first)
    }
<span class="boring">}
</span>
// ...

let mut arr = [0, 1, 2, 3];
let iter = MyIterMut { slice: &amp;mut arr };
for x in iter {
    println!("{x}");
}
<span class="boring">}</span></code></pre></pre>
<p>Finally, a working version!  <code>split_first_mut</code> is a form of <a href="./lifetime-analysis.html#independently-borrowing-fields">borrow splitting,</a>
which we briefly mentioned before.</p>
<p>And for the sake of completion, here's the pattern based approach to borrow splitting:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyIterMut&lt;'a, T&gt; { slice: &amp;'a mut [T], }
</span><span class="boring">impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
</span><span class="boring">  type Item = &amp;'a mut T;
</span>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        //    ....these are all that changed....
        //    vvvvvvvvvvvvvvvvvv               v
        match std::mem::take(&amp;mut self.slice) {
            [] =&gt; None,
            [first, rest @ ..] =&gt; Some(first),
        }
     }
<span class="boring">}
</span>
// ...

let mut arr = [0, 1, 2, 3];
let iter = MyIterMut { slice: &amp;mut arr };
for x in iter {
    println!("{x}");
}
<span class="boring">}</span></code></pre></pre>
<p>Oh whoops, just one element again.  Right.  We need to put the <code>rest</code> back in <code>self.slice</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyIterMut&lt;'a, T&gt; { slice: &amp;'a mut [T], }
</span><span class="boring">impl&lt;'a, T&gt; Iterator for MyIterMut&lt;'a, T&gt; {
</span><span class="boring">  type Item = &amp;'a mut T;
</span>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        match std::mem::take(&amp;mut self.slice) {
            [] =&gt; None,
            [first, rest @ ..] =&gt; {
                self.slice = rest;
                Some(first)
            }
        }
     }
<span class="boring">}
</span>
// ...

let mut arr = [0, 1, 2, 3];
let iter = MyIterMut { slice: &amp;mut arr };
for x in iter {
    println!("{x}");
}
<span class="boring">}</span></code></pre></pre>
<p>👍</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="lt-examples.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="circle.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="lt-examples.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="circle.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
