<!DOCTYPE HTML>
<html lang="en" class="navy" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Higher-ranked types - Learning Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Advice for learning Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('navy')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Practical suggestions for building intuition around borrow errors</li><li class="chapter-item "><a href="lifetime-intuition.html"><strong aria-hidden="true">1.</strong> Sectional introduction</a></li><li class="chapter-item "><a href="community.html"><strong aria-hidden="true">2.</strong> Keep at it and participate in the community</a></li><li class="chapter-item "><a href="have-no-life.html"><strong aria-hidden="true">3.</strong> Prefer ownership over long-lived references</a></li><li class="chapter-item "><a href="dont-hide.html"><strong aria-hidden="true">4.</strong> Don't hide lifetimes</a></li><li class="chapter-item "><a href="elision.html"><strong aria-hidden="true">5.</strong> Understand elision and get a feel for when to name lifetimes</a></li><li class="chapter-item "><a href="subtypes.html"><strong aria-hidden="true">6.</strong> Get a feel for variance, references, and reborrows</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="st-model.html"><strong aria-hidden="true">6.1.</strong> The seed of a mental model</a></li><li class="chapter-item "><a href="st-types.html"><strong aria-hidden="true">6.2.</strong> Reference types</a></li><li class="chapter-item "><a href="st-bounds.html"><strong aria-hidden="true">6.3.</strong> Lifetime bounds</a></li><li class="chapter-item "><a href="st-references.html"><strong aria-hidden="true">6.4.</strong> Reference lifetimes</a></li><li class="chapter-item "><a href="st-reborrow.html"><strong aria-hidden="true">6.5.</strong> Copy and reborrows</a></li><li class="chapter-item "><a href="st-invariance.html"><strong aria-hidden="true">6.6.</strong> Nested borrows and invariance</a></li><li class="chapter-item "><a href="st-more-invariance.html"><strong aria-hidden="true">6.7.</strong> Invariance elsewhere</a></li><li class="chapter-item "><a href="st-non-references.html"><strong aria-hidden="true">6.8.</strong> Non-references</a></li></ol></li><li class="chapter-item "><a href="methods.html"><strong aria-hidden="true">7.</strong> Get a feel for borrow-returning methods</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="m-naming.html"><strong aria-hidden="true">7.1.</strong> When not to name lifetimes</a></li><li class="chapter-item "><a href="m-infect.html"><strong aria-hidden="true">7.2.</strong> Bound-related lifetimes "infect" each other</a></li><li class="chapter-item "><a href="m-no-downgrades.html"><strong aria-hidden="true">7.3.</strong> &mut inputs don't "downgrade" to &</a></li><li class="chapter-item "><a href="m-rpitit-alikes.html"><strong aria-hidden="true">7.4.</strong> async and returning impl Trait</a></li></ol></li><li class="chapter-item "><a href="fn-parameters.html"><strong aria-hidden="true">8.</strong> Understand function lifetime parameters</a></li><li class="chapter-item "><a href="lifetime-analysis.html"><strong aria-hidden="true">9.</strong> Understand borrows within a function</a></li><li class="chapter-item "><a href="pitfalls.html"><strong aria-hidden="true">10.</strong> Learn some pitfalls and antipatterns</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pf-dyn.html"><strong aria-hidden="true">10.1.</strong> dyn Trait lifetimes and Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="pf-nll3.html"><strong aria-hidden="true">10.2.</strong> Conditional return of a borrow</a></li><li class="chapter-item "><a href="pf-borrow-forever.html"><strong aria-hidden="true">10.3.</strong> Borrowing something forever</a></li><li class="chapter-item "><a href="pf-self.html"><strong aria-hidden="true">10.4.</strong> &'a mut self and Self aliasing more generally</a></li><li class="chapter-item "><a href="pf-meta.html"><strong aria-hidden="true">10.5.</strong> Avoid self-referential structs</a></li><li class="chapter-item "><a href="pf-shared-nested.html"><strong aria-hidden="true">10.6.</strong> &'a Struct&lt;'a&gt; and covariance</a></li></ol></li><li class="chapter-item "><a href="compiler.html"><strong aria-hidden="true">11.</strong> Scrutinize compiler advice</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c-signatures.html"><strong aria-hidden="true">11.1.</strong> Advice to change function signature when aliases are involved</a></li><li class="chapter-item "><a href="c-equality.html"><strong aria-hidden="true">11.2.</strong> Advice to add bound which implies lifetime equality</a></li><li class="chapter-item "><a href="c-static.html"><strong aria-hidden="true">11.3.</strong> Advice to add a static bound</a></li></ol></li><li class="chapter-item "><a href="lt-examples.html"><strong aria-hidden="true">12.</strong> Illustrative examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lt-ex-mut-slice.html"><strong aria-hidden="true">12.1.</strong> Mutable slice iterator</a></li></ol></li><li class="chapter-item "><a href="circle.html"><strong aria-hidden="true">13.</strong> Circle back</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Miscellanea</li><li class="chapter-item "><a href="miscellanea.html"><strong aria-hidden="true">14.</strong> Sectional introduction</a></li><li class="chapter-item "><a href="misc-slice.html"><strong aria-hidden="true">15.</strong> Slice layout</a></li><li class="chapter-item "><a href="misc-default-param.html"><strong aria-hidden="true">16.</strong> Default parameter mechanics</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">A tour of dyn Trait</li><li class="chapter-item "><a href="dyn-trait.html"><strong aria-hidden="true">17.</strong> Sectional introduction</a></li><li class="chapter-item "><a href="dyn-trait-overview.html"><strong aria-hidden="true">18.</strong> dyn Trait overview</a></li><li class="chapter-item "><a href="dyn-trait-impls.html"><strong aria-hidden="true">19.</strong> dyn Trait implementations</a></li><li class="chapter-item "><a href="dyn-trait-coercions.html"><strong aria-hidden="true">20.</strong> dyn Trait coercions</a></li><li class="chapter-item "><a href="dyn-safety.html"><strong aria-hidden="true">21.</strong> dyn safety (object safety)</a></li><li class="chapter-item expanded "><a href="dyn-trait-lifetime.html"><strong aria-hidden="true">22.</strong> dyn Trait lifetimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dyn-covariance.html"><strong aria-hidden="true">22.1.</strong> Variance</a></li><li class="chapter-item expanded "><a href="dyn-hr.html" class="active"><strong aria-hidden="true">22.2.</strong> Higher-ranked types</a></li><li class="chapter-item "><a href="dyn-elision.html"><strong aria-hidden="true">22.3.</strong> Elision rules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dyn-elision-basic.html"><strong aria-hidden="true">22.3.1.</strong> Basic guidelines</a></li><li class="chapter-item "><a href="dyn-elision-advanced.html"><strong aria-hidden="true">22.3.2.</strong> Advanced guidelines</a></li><li class="chapter-item "><a href="dyn-elision-trait-bounds.html"><strong aria-hidden="true">22.3.3.</strong> Trait bound interactions</a></li><li class="chapter-item "><a href="dyn-elision-citations.html"><strong aria-hidden="true">22.3.4.</strong> Citations</a></li></ol></li></ol></li><li class="chapter-item "><a href="dyn-trait-vs.html"><strong aria-hidden="true">23.</strong> dyn Trait vs. alternatives</a></li><li class="chapter-item "><a href="dyn-trait-examples.html"><strong aria-hidden="true">24.</strong> dyn Trait examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dyn-trait-combining.html"><strong aria-hidden="true">24.1.</strong> Combining traits</a></li><li class="chapter-item "><a href="dyn-trait-box-impl.html"><strong aria-hidden="true">24.2.</strong> impl Trait for Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="dyn-trait-clone.html"><strong aria-hidden="true">24.3.</strong> Cloneable Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="dyn-trait-eq.html"><strong aria-hidden="true">24.4.</strong> dyn PartialEq</a></li><li class="chapter-item "><a href="dyn-trait-borrow.html"><strong aria-hidden="true">24.5.</strong> Generalizing borrows</a></li><li class="chapter-item "><a href="dyn-trait-erased.html"><strong aria-hidden="true">24.6.</strong> Erased traits</a></li><li class="chapter-item "><a href="dyn-trait-hash.html"><strong aria-hidden="true">24.7.</strong> Hashable Box&lt;dyn Trait&gt;</a></li><li class="chapter-item "><a href="dyn-any-examples.html"><strong aria-hidden="true">24.8.</strong> dyn Any examples</a></li></ol></li><li class="chapter-item "><a href="dyn-any.html"><strong aria-hidden="true">25.</strong> dyn Any</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learning Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/QuineDot/rust-learning" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="higher-ranked-types"><a class="header" href="#higher-ranked-types">Higher-ranked types</a></h1>
<p>Another feature of trait objects is that they can be <em>higher-ranked</em> over
lifetime parameters of the trait:</p>
<pre><pre class="playground"><code class="language-rust edition2021">// A trait with a lifetime parameter
trait Look&lt;'s&gt; {
    fn method(&amp;self, s: &amp;'s str);
}

// An implementation that works for any lifetime
impl&lt;'s&gt; Look&lt;'s&gt; for () {
    fn method(&amp;self, s: &amp;'s str) {
        println!("Hi there, {s}!");
    }
}

fn main() {
    // A higher-ranked trait object
    //           vvvvvvvvvvvvvvvvvvvvvvvv
    let _bx: Box&lt;dyn for&lt;'any&gt; Look&lt;'any&gt;&gt; = Box::new(());
}</code></pre></pre>
<p>The <code>for&lt;'x&gt;</code> part is a <em>lifetime binder</em> that introduces higher-ranked
lifetimes.  There can be more than one lifetime, and you can give them
arbitrary names just like lifetime parameters on functions, structs,
and so on.</p>
<p>You can only coerce to a higher-ranked trait object if you implement
the trait in question for <em>all</em> lifetimes.  For example, this doesn't
work:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">trait Look&lt;'s&gt; { fn method(&amp;self, s: &amp;'s str); }
</span>impl&lt;'s&gt; Look&lt;'s&gt; for &amp;'s i32 {
    fn method(&amp;self, s: &amp;'s str) {
        println!("Hi there, {s}!");
    }
}

fn main() {
    let _bx: Box&lt;dyn for&lt;'any&gt; Look&lt;'any&gt;&gt; = Box::new(&amp;0);
}</code></pre></pre>
<p><code>&amp;'s i32</code> only implements <code>Look&lt;'s&gt;</code>, not <code>Look&lt;'a&gt;</code> for all lifetimes <code>'a</code>.</p>
<p>Similarly, this won't work either:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">trait Look&lt;'s&gt; { fn method(&amp;self, s: &amp;'s str); }
</span>impl Look&lt;'static&gt; for i32 {
    fn method(&amp;self, s: &amp;'static str) {
        println!("Hi there, {s}!");
    }
}

fn main() {
    let _bx: Box&lt;dyn for&lt;'any&gt; Look&lt;'any&gt;&gt; = Box::new(0);
}</code></pre></pre>
<p>Implementing the trait with <code>'static</code> as the lifetime parameter is not the
same thing as implementing the trait for any lifetime as the parameter.
Traits and trait implementations don't have something like variance; the
parameters of traits are always invariant and thus implementations are
always for the explicit lifetime(s) only.</p>
<h2 id="subtyping"><a class="header" href="#subtyping">Subtyping</a></h2>
<p>There's a relationship between higher-ranked types like <code>dyn for&lt;'any&gt; Look&lt;'any&gt;</code>
and non-higher-ranked types like <code>dyn Look&lt;'x&gt;</code> (for a single lifetime <code>'x</code>): the
higher-ranked type is a subtype of the non-higher-ranked types.  Thus you can
coerce a higher-ranked type to a non-higher-ranked type with any concrete lifetime:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Look&lt;'s&gt; { fn method(&amp;self, s: &amp;'s str); }
</span>fn as_static(bx: Box&lt;dyn for&lt;'any&gt; Look&lt;'any&gt;&gt;) -&gt; Box&lt;dyn Look&lt;'static&gt;&gt; {
    bx
}

fn as_whatever&lt;'w&gt;(bx: Box&lt;dyn for&lt;'any&gt; Look&lt;'any&gt;&gt;) -&gt; Box&lt;dyn Look&lt;'w&gt;&gt; {
    bx
}
<span class="boring">}</span></code></pre></pre>
<p>Note that this still isn't a form of variance for the <em>lifetime parameter</em> of the
trait.  This fails for example, because you can't coerce from <code>dyn Look&lt;'static&gt;</code>
to <code>dyn Look&lt;'w&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Look&lt;'s&gt; { fn method(&amp;self, s: &amp;'s str); }
</span><span class="boring">fn as_static(bx: Box&lt;dyn for&lt;'any&gt; Look&lt;'any&gt;&gt;) -&gt; Box&lt;dyn Look&lt;'static&gt;&gt; { bx }
</span>fn as_whatever&lt;'w&gt;(bx: Box&lt;dyn for&lt;'any&gt; Look&lt;'any&gt;&gt;) -&gt; Box&lt;dyn Look&lt;'w&gt;&gt; {
    as_static(bx)
}
<span class="boring">}</span></code></pre></pre>
<p>As a supertype coercion, going from higher-ranked to non-higher-ranked can
apply even in a covariant nested context,
<a href="./dyn-covariance.html#variance-in-nested-context">just like non-higher-ranked supertype coercions:</a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Look&lt;'s&gt; {}
</span>fn foo&lt;'l: 's, 's, 'p&gt;(
    v: Vec&lt;Box&lt;dyn for&lt;'any&gt; Look&lt;'any&gt; + 'l&gt;&gt;
) -&gt; Vec&lt;Box&lt;dyn Look&lt;'p&gt; + 's&gt;&gt;
{
    v
}
<span class="boring">}</span></code></pre></pre>
<h2 id="fn-traits-and-fn-pointers"><a class="header" href="#fn-traits-and-fn-pointers"><code>Fn</code> traits and <code>fn</code> pointers</a></h2>
<p>The <code>Fn</code> traits (<a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a>,
<a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>,
and <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>)
have special-cased syntax.  For one, you write them out to look more like
a function, using <code>(TypeOne, TypeTwo)</code> to list the input parameters and
<code>-&gt; ResultType</code> to list the associated type.  But for another, elided
input lifetimes are sugar that introduces higher-ranked bindings.</p>
<p>For example, these two trait object types are the same:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn identity(bx: Box&lt;dyn Fn(&amp;str)&gt;) -&gt; Box&lt;dyn for&lt;'any&gt; Fn(&amp;'any str)&gt; {
    bx
}
<span class="boring">}</span></code></pre></pre>
<p>This is similar to how elided lifetimes work for function declarations
as well, and indeed, the same output lifetime elision rules also apply:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The elided input lifetime becomes a higher-ranked lifetime
// The elided output lifetime is the same as the single input lifetime
//     (underneath the binder)
fn identity(bx: Box&lt;dyn Fn(&amp;str) -&gt; &amp;str&gt;) -&gt; Box&lt;dyn for&lt;'any&gt; Fn(&amp;'any str) -&gt; &amp;'any str&gt; {
    bx
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Doesn't compile as what the output lifetime should be is
// considered ambiguous
fn ambiguous(bx: Box&lt;dyn Fn(&amp;str, &amp;str) -&gt; &amp;str&gt;) {}

// Here's a possible fix, which is also an example of
// multiple lifetimes in the binder
fn first(bx: Box&lt;dyn for&lt;'a, 'b&gt; Fn(&amp;'a str, &amp;'b str) -&gt; &amp;'a str&gt;) {}
<span class="boring">}</span></code></pre></pre>
<p>Function pointers are another example of types which can be higher-ranked
in Rust.  They have analogous syntax and sugar to function declarations
and the <code>Fn</code> traits.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn identity(fp: fn(&amp;str) -&gt; &amp;str) -&gt; for&lt;'any&gt; fn(&amp;'any str) -&gt; &amp;'any str {
    fp
}
<span class="boring">}</span></code></pre></pre>
<h3 id="syntactic-inconsistencies"><a class="header" href="#syntactic-inconsistencies">Syntactic inconsistencies</a></h3>
<p>There are some inconsistencies around the syntax for function declarations,
function pointer types, and the <code>Fn</code> traits involving the "names" of the
input arguments.</p>
<p>First of all, only function (method) declarations can make use of the
shorthand <code>self</code> syntaxes for receivers, like <code>&amp;self</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct S;
</span>impl S {
    fn foo(&amp;self) {}
    //     ^^^^^
}
<span class="boring">}</span></code></pre></pre>
<p>This exception is pretty unsurprising as the <code>Self</code> alias only exists
within those implementation blocks.</p>
<p>Each non-<code>self</code> argument in a function declaration is an
<a href="https://doc.rust-lang.org/reference/items/functions.html#function-parameters">irrefutable pattern</a>
followed by a type annotation.  It is an error to leave out the pattern;
if you don't use the argument (and thus don't need to name it), you
still need to use at least the wildcard pattern.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn this_works(_: i32) {}
fn this_fails(i32) {}
<span class="boring">}</span></code></pre></pre>
<p>There is
<a href="https://rust-lang.github.io/rfcs/1685-deprecate-anonymous-parameters.html">an accidental exception</a>
to this rule, but it was removed in Edition 2018 and thus is only
available on Edition 2015.</p>
<p>In contrast, each argument in a function pointer can be</p>
<ul>
<li>An <em>identifier</em> followed by a type annotation (<code>i: i32</code>)</li>
<li><code>_</code> followed by a type annotation (<code>_: i32</code>)</li>
<li>Just a type name (<code>i32</code>)</li>
</ul>
<p>So these all work:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _: fn(i32) = |_| {};
let _: fn(i: i32) = |_| {};
let _: fn(_: i32) = |_| {};
<span class="boring">}</span></code></pre></pre>
<p>But <em>actual</em> patterns <a href="https://doc.rust-lang.org/stable/error_codes/E0561.html">are not allowed:</a></p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _: fn(&amp;i: &amp;i32) = |_| {};
<span class="boring">}</span></code></pre></pre>
<p>The idiomatic form is to just use the type name.</p>
<p>It's also allowed <a href="https://github.com/rust-lang/rust/issues/33995">to have colliding names in function pointer
arguments,</a> but this
is a property of having no function body -- so it's also possible in
a trait method declaration, for example.  It is also related to the
Edition 2015 exception for anonymous function arguments mentioned
above, and may be deprecated eventually.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn silly(a: u32, a: i32);
}

let _: fn(a: u32, a: i32) = |_, _| {};
<span class="boring">}</span></code></pre></pre>
<p>Finally, each argument in the <code>Fn</code> traits can <em>only</em> be a type name:
no identifiers, <code>_</code>, or patterns allowed.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// None of these compile
let _: Box&lt;dyn Fn(i: i32)&gt; = Box::new(|_| {});
let _: Box&lt;dyn Fn(_: i32)&gt; = Box::new(|_| {});
let _: Box&lt;dyn Fn(&amp;_: &amp;i32)&gt; = Box::new(|_| {});
<span class="boring">}</span></code></pre></pre>
<p>Why the differences? One reason is that
<a href="https://github.com/rust-lang/rust/issues/41686#issuecomment-366611096">patterns are grammatically incompatible with anonymous arguments,
apparently.</a>
I'm uncertain as to why identifiers are accepted on function pointers,
however, or more generally why the <code>Fn</code> sugar is inconsistent with
function pointer types.  But the simplest explanation is that function
pointers existed first with nameable parameters for whatever reason,
whereas the <code>Fn</code> sugar is for trait input type parameters which also
do not have names.</p>
<h2 id="higher-ranked-trait-bounds"><a class="header" href="#higher-ranked-trait-bounds">Higher-ranked trait bounds</a></h2>
<p>You can also apply higher-ranked trait bounds (HRTBs) to generic
type parameters, using the same syntax:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Look&lt;'s&gt; { fn method(&amp;self, s: &amp;'s str); }
</span>fn box_it_up&lt;'t, T&gt;(t: T) -&gt; Box&lt;dyn for&lt;'any&gt; Look&lt;'any&gt; + 't&gt;
where
    T: for&lt;'any&gt; Look&lt;'any&gt; + 't,
{
    Box::new(t)
}
<span class="boring">}</span></code></pre></pre>
<p>The sugar for <code>Fn</code> like traits applies here as well.  You've probably
already seen bounds like this on methods that take closures:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct S;
</span><span class="boring">impl S {
</span>fn map&lt;'s, F, R&gt;(&amp;'s self, mut f: F) -&gt; impl Iterator&lt;Item = R&gt; + 's
where
    F: FnMut(&amp;[i32]) -&gt; R + 's
{
    // This part isn't the point ;-)
    [].into_iter().map(f)
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>That bound is actually <code>F: for&lt;'x&gt; FnMut(&amp;'x [i32]) -&gt; R + 's</code>.</p>
<h2 id="thats-all-about-higher-ranked-types-for-now"><a class="header" href="#thats-all-about-higher-ranked-types-for-now">That's all about higher-ranked types for now</a></h2>
<p>Hopefully this has given you a decent overview of higher-ranked
types, HRTBs, and how they relate to the <code>Fn</code> traits.  There
are a lot more details and nuances to those topics and related
concepts such as closures, as you might imagine.  However, an
exploration of those topics deserves its own dedicated guide, so
we won't see too much more about higher-ranked types in this
tour of <code>dyn Trait</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="dyn-covariance.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="dyn-elision.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="dyn-covariance.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="dyn-elision.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
